#![allow(clippy::const_is_empty)]

use itertools::join;
use std::io::Write;
use std::process::{Command, Stdio};

use calamine::{Data, Reader, Xlsx, open_workbook};

const MESSAGES_TO_IMPORT: &[&str] = &["Record", "FieldDescription"];
const BASE_TYPES: &[&str] = &[
    "sint8", "uint8", "uintz8", "sint16", "uint16", "uintz16", "sint32", "uint32", "uintz32",
    "sint64", "uint64", "uintz64", "string", "float32", "float64", "byte",
];
const ENUMS_SKIPPED_VARIANTS: &[&str] = &["mfg_range_min", "mfg_range_max", "pad"];

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    let mut enums = generate_enums();
    let (messages, enums_used) = generate_messages_definitions();

    enums.retain(|(name, _, __)| enums_used.contains(name));

    let enums_names = enums.iter().map(|(name, _, __)| name.clone()).collect();

    let mut code = generate_enums_code(&enums);
    code.push_str(&generate_messages_code(messages, enums_names));
    code = format_code(&code);

    std::fs::write("src/parser/types/generated.rs", code).expect("Could not wirte to ouptut file");
}

fn generate_enums() -> Vec<(String, String, Vec<(usize, String)>)> {
    let mut workbook: Xlsx<_> = open_workbook("Profile.xlsx").expect("Unable to load profile file");
    let range = workbook
        .worksheet_range("Types")
        .expect("The profile file does not contain a Types sheet");

    let mut iterator = range.rows();
    let _ = iterator.next(); // Skip header

    let mut enums = Vec::new();

    let EnumRow {
        name: mut type_name,
        mut enum_type,
        ..
    } = parse_enum_row(iterator.next().expect("Unable to parse row"));

    loop {
        let (mapping, next_type_name, next_base_type) = parse_enum_variants(&mut iterator);

        enums.push((type_name.unwrap(), enum_type.unwrap(), mapping));

        if next_type_name.is_none() && next_base_type.is_none() {
            break;
        }

        type_name = next_type_name;
        enum_type = next_base_type;
    }

    enums
}

#[derive(Debug)]
struct EnumRow {
    name: Option<String>,
    enum_type: Option<String>,
    variant_name: Option<String>,
    value: Option<usize>,
}

fn parse_enum_row(row: &[Data]) -> EnumRow {
    EnumRow {
        name: match row.first() {
            Some(Data::String(name)) => Some(name.clone()),
            _ => None,
        },
        enum_type: match row.get(1) {
            Some(Data::String(enum_type)) => Some(enum_type.clone()),
            _ => None,
        },
        variant_name: match row.get(2) {
            Some(Data::String(variant_name)) => Some(variant_name.clone()),
            _ => None,
        },
        value: match row.get(3) {
            Some(Data::Int(variant)) => Some(*variant as usize),
            Some(Data::Float(variant)) => Some(*variant as usize),
            Some(Data::String(variant)) => {
                if let Some(stripped) = variant.strip_prefix("0x") {
                    usize::from_str_radix(stripped, 16).ok()
                } else {
                    None
                }
            }

            _ => None,
        },
    }
}

fn parse_enum_variants<'a, I>(
    iterator: &mut I,
) -> (Vec<(usize, String)>, Option<String>, Option<String>)
where
    I: Iterator<Item = &'a [Data]>,
{
    let mut mapping = Vec::new();
    let mut next_type_name = None;
    let mut next_base_type = None;

    for row in iterator {
        let row = parse_enum_row(row);

        if row.name.is_some() && row.enum_type.is_some() {
            next_type_name = row.name;
            next_base_type = row.enum_type;
            break;
        }

        if row.variant_name.is_some()
            && row.value.is_some()
            && !ENUMS_SKIPPED_VARIANTS.contains(&row.variant_name.clone().unwrap().as_str())
        {
            mapping.push((row.value.unwrap(), row.variant_name.unwrap()));
        }
    }

    (mapping, next_type_name, next_base_type)
}

fn map_type(val: &str) -> Option<String> {
    match val {
        "enum" => Some("u8".to_string()),
        "uint8" => Some("u8".to_string()),
        "uint8z" => Some("u8".to_string()),
        "uint16" => Some("u16".to_string()),
        "uint32" => Some("u32".to_string()),
        "uint32z" => Some("u32".to_string()),
        _ => None,
    }
}

fn map_type_size(val: &str) -> Option<u8> {
    match val {
        "enum" => Some(1),
        "uint8" => Some(1),
        "uint8z" => Some(1),
        "uint16" => Some(2),
        "uint32" => Some(4),
        "uint32z" => Some(4),
        _ => None,
    }
}

fn generate_enums_code(enums: &[(String, String, Vec<(usize, String)>)]) -> String {
    let mut code = String::new();
    code.push_str("// Code generated by build.rs - do not modify manually\n");
    code.push_str("#![allow(dead_code)]\n");
    code.push_str("#![allow(unused_imports)]\n");
    code.push_str("#![allow(unused_variables)]\n");
    code.push_str("#![allow(unreachable_patterns)]\n\n");
    code.push_str("#![allow(clippy::enum_variant_names)]\n");
    code.push_str("#![allow(clippy::upper_case_acronyms)]\n\n");
    code.push_str("#![allow(clippy::identity_op)]\n\n");
    code.push_str("#![allow(clippy::match_single_binding)]\n\n");
    code.push_str("#![allow(clippy::match_overlapping_arm)]\n\n");
    code.push_str("use crate::{parser::reader::Reader};\n");
    code.push_str(
        "use crate::parser::types::{parse_uint8, parse_uint8z, parse_sint8,
        parse_uint16, parse_uint16z, parse_sint16,
        parse_uint32, parse_uint32z, parse_sint32,
        parse_uint64, parse_uint64z, parse_sint64,
        parse_float32, parse_float64, parse_string,
        parse_unknown, parse_byte_array as parse_byte, ScaleOffset,
        DataValue, DataTypeError};",
    );
    code.push_str("use crate::parser::definition::{Endianness};\n\n");

    let enum_names: Vec<String> = enums.iter().map(|(name, _, __)| name.to_string()).collect();

    code.push_str(&template_main_enum(&enum_names));

    for (name, base_type, mapping) in enums.iter() {
        let name = snake_to_camel_case(name);

        let mut variants = join(mapping.iter().map(|(_, v)| snake_to_camel_case(v)), ",\n");
        if !variants.is_empty() {
            variants.push(',');
        }

        let mut enum_mapping = join(
            mapping
                .iter()
                .map(|(k, v)| format!("{k} => {name}::{}", snake_to_camel_case(v))),
            ",\n",
        );
        if !enum_mapping.is_empty() {
            enum_mapping.push(',');
        }

        if name.contains("DateTime") {
            code.push_str(&format!(
                "
#[derive(Debug, PartialEq, Clone)]
pub struct {name}(u32);
            ",
            ));
        } else {
            code.push_str(&format!(
                "
#[derive(Debug, PartialEq, Clone)]
pub enum {name} {{
    {variants}
    UnknownVariant
}}"
            ));
        }
        code.push_str(&template_enum_impl(&name, base_type, mapping));
    }

    // Add special parsing for FitBaseType
    code.push_str(
        "
impl FitBaseType {
    pub fn get_parse_fn(
        &self
    ) -> fn(&mut Reader, &Endianness, u8) -> Result<Vec<DataValue>, DataTypeError> {
        match self {
            Self::Byte => parse_byte,
            Self::Enum => parse_unknown,
            Self::Float32 => parse_float32,
            Self::Float64 => parse_float64,
            Self::Sint8 => parse_sint8,
            Self::Sint16 => parse_sint16,
            Self::Sint32 => parse_sint32,
            Self::Sint64 => parse_sint64,
            Self::String => parse_string,
            Self::Uint8 => parse_uint8,
            Self::Uint8z => parse_uint8z,
            Self::Uint16 => parse_uint16,
            Self::Uint16z => parse_uint16z,
            Self::Uint32 => parse_uint32,
            Self::Uint32z => parse_uint32z,
            Self::Uint64 => parse_uint64,
            Self::Uint64z => parse_uint64z,
            Self::UnknownVariant => parse_unknown,
        }
    }
}
    ",
    );

    code
}

fn template_main_enum(enum_names: &[String]) -> String {
    let variants = join(
        enum_names.iter().map(|name| {
            format!(
                "{}({})",
                snake_to_camel_case(name),
                snake_to_camel_case(name)
            )
        }),
        ",\n",
    );

    format!(
        r#"
#[derive(Debug, PartialEq, Clone)]
pub enum FitEnum {{
    {variants}
}}
"#
    )
}

fn template_enum_impl(name: &str, base_type: &str, mapping: &[(usize, String)]) -> String {
    let enum_type = map_type(base_type).expect("Expected not None enum type");
    let enum_type_size = map_type_size(base_type).expect("Expected not None enum type");
    let mut enum_mapping = join(
        mapping
            .iter()
            .map(|(k, v)| format!("{k} => {name}::{}", snake_to_camel_case(v))),
        ",\n",
    );
    if !enum_mapping.is_empty() {
        enum_mapping.push(',');
    }

    let parse_arguments = if enum_type.contains("8") {
        ""
    } else {
        "endianness"
    };

    // DateTime like are directly parsed as u32
    let from_code = if name.contains("DateTime") {
        "Self(content)".to_string()
    } else {
        format!(
            "match content {{
            {enum_mapping}
            _ => {name}::UnknownVariant
        }}"
        )
    };

    let parse_code = if name.contains("DateTime") {
        "
        for _ in 0..number_of_bytes/4 {{
            values.push(DataValue::DateTime(reader.next_u32(endianness)?));
        }}"
        .to_string()
    } else {
        format!(
            "for _ in 0..number_of_bytes/{enum_type_size} {{
            values.push(DataValue::Enum(FitEnum::{name}(
                Self::from(reader.next_{enum_type}({parse_arguments})?)
            )));
        }}"
        )
    };

    let mut code = format!(
        r#"
impl {name} {{
    pub fn from(content: {enum_type}) -> {name} {{
        {from_code}
    }}

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8
    ) -> Result<Vec<DataValue>, DataTypeError> {{
        let mut values = Vec::new();
        {parse_code}
        Ok(values)
    }}"#,
    );

    // MesgNum need special treatment to be able to link to a FitMessage
    if name == "MesgNum" {
        let mapping_field = join(
            mapping
                .iter()
                .map(|(_, v)| {
                    format!(
                        "Self::{} => FitMessage::{}({}Field::from(def_number))",
                        snake_to_camel_case(v),
                        snake_to_camel_case(v),
                        snake_to_camel_case(v)
                    )
                })
                .chain(vec![
                    "Self::UnknownVariant => FitMessage::UnknownVariant".to_string(),
                ]),
            ",\n",
        );

        let mapping_parse = join(
            mapping
                .iter()
                .map(|(_, v)| {
                    format!(
                        "Self::{} => {}Field::get_parse_function(def_number)",
                        snake_to_camel_case(v),
                        snake_to_camel_case(v)
                    )
                })
                .chain(vec!["Self::UnknownVariant => parse_unknown".to_string()]),
            ",\n",
        );

        let mapping_scale_offset = join(
            mapping
                .iter()
                .map(|(_, v)| {
                    format!(
                        "Self::{} => {}Field::get_scale_offset(def_number)",
                        snake_to_camel_case(v),
                        snake_to_camel_case(v)
                    )
                })
                .chain(vec!["Self::UnknownVariant => None".to_string()]),
            ",\n",
        );

        code.push_str(&format!(
            "
    pub fn message_field(&self, def_number: u8) -> FitMessage {{
        match self {{
            {mapping_field}
        }}
    }}

    pub fn field_parse(
        &self, def_number: u8
    ) -> fn(&mut Reader, &Endianness, u8) -> Result<Vec<DataValue>, DataTypeError> {{
        match self {{
            {mapping_parse}
        }}
    }}

    pub fn scale_offset(
        &self,
        def_number: u8
    ) -> Option<ScaleOffset> {{
        match self {{
            {mapping_scale_offset}
        }}
    }}"
        ));
    }

    code.push_str("}\n");

    code
}

fn snake_to_camel_case(input: &str) -> String {
    let trimmed = input.trim_start_matches(char::is_numeric);
    trimmed
        .split('_')
        .map(|w| {
            let mut new = w.to_string();
            if new.is_empty() {
                return new;
            }
            if let Some((idx, c)) = new.char_indices().next() {
                new.replace_range(idx..idx + 1, &c.to_uppercase().to_string());
            }

            new
        })
        .collect()
}

fn format_code(code: &str) -> String {
    let mut child = Command::new("rustfmt")
        .arg("--emit=stdout")
        .arg("--quiet")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to spawn rustfmt");

    // Write code to rustfmt's stdin
    if let Some(stdin) = child.stdin.as_mut() {
        stdin
            .write_all(code.as_bytes())
            .expect("Failed to write to rustfmt");
    }

    let output = child
        .wait_with_output()
        .expect("Failed to read rustfmt output");

    if output.status.success() {
        String::from_utf8(output.stdout).unwrap_or_else(|_| code.to_string())
    } else {
        println!("cargo:warning=rustfmt failed, using unformatted code");
        code.to_string()
    }
}

#[derive(Debug)]
struct Message {
    field_def: u8,
    name: String,
    base_type: String,
    // array: Option<usize>,
    scale: Option<usize>,
    offset: Option<usize>,
}

fn generate_messages_definitions() -> (Vec<(String, Vec<Message>)>, Vec<String>) {
    let mut workbook: Xlsx<_> = open_workbook("Profile.xlsx").expect("Unable to load profile file");
    let range = workbook
        .worksheet_range("Messages")
        .expect("The profile file does not contain a Types sheet");

    let mut iterator = range.rows();
    let _ = iterator.next(); // Skip header

    let mut messages = Vec::new();

    let mut message_name = match iterator.next().and_then(|r| r.first()) {
        Some(Data::String(name)) => name.to_string(),
        _ => return (messages, Vec::new()),
    };

    loop {
        let (next_message_name, defintions) = parse_definitions(&mut iterator);

        messages.push((message_name, defintions));

        if next_message_name.is_none() {
            break;
        }

        message_name = next_message_name.unwrap();
    }

    if MESSAGES_TO_IMPORT.is_empty() {
        messages.retain(|(msg, _)| {
            MESSAGES_TO_IMPORT.contains(&snake_to_camel_case(msg.as_str()).as_str())
        })
    }

    let enums_used = messages
        .iter()
        .flat_map(|(_, definitions)| {
            definitions
                .iter()
                .filter_map(|def| is_fit_enum(&def.base_type))
        })
        .collect();

    (messages, enums_used)
}

fn is_fit_enum(type_name: &str) -> Option<String> {
    match type_name {
        "sint8" | "uint8" | "uintz8" | "sint16" | "uint16" | "uintz16" | "sint32" | "uint32"
        | "uintz32" | "sint64" | "uint64" | "uintz64" | "string" | "float32" | "float64"
        | "byte" => None,
        val => Some(val.to_string()),
    }
}

fn get_parse_function(enums: &[String], type_name: &str) -> String {
    if BASE_TYPES.contains(&type_name) {
        return format!("parse_{}", type_name).to_string();
    }

    if enums.contains(&type_name.to_string()) {
        return format!("{}::parse", snake_to_camel_case(type_name)).to_string();
    }

    "parse_unknown".to_string()
}

fn parse_definitions<'a, I>(iter: &mut I) -> (Option<String>, Vec<Message>)
where
    I: Iterator<Item = &'a [Data]>,
{
    let mut messages = Vec::new();
    let mut next_message_name: Option<String> = None;

    for row in iter {
        if let Some(Data::String(name)) = row.first() {
            next_message_name = Some(name.to_string());
            break;
        }

        let field_def = match row.get(1) {
            Some(Data::Int(field_def)) => *field_def as u8,
            Some(Data::Float(field_def)) => *field_def as u8,
            _ => {
                continue;
            }
        };

        let name = match row.get(2) {
            Some(Data::String(name)) => name.clone(),
            _ => {
                continue;
            }
        };

        let base_type = match row.get(3) {
            Some(Data::String(enum_type)) => enum_type.clone(),
            _ => {
                continue;
            }
        };

        messages.push(Message {
            field_def,
            name,
            base_type,
            // array: match row.get(4) {
            //     Some(Data::Int(field_def)) => Some(*field_def as usize),
            //     Some(Data::Float(field_def)) => Some(*field_def as usize),
            //     _ => None,
            // },
            scale: match row.get(6) {
                Some(Data::Int(field_def)) => Some(*field_def as usize),
                Some(Data::Float(field_def)) => Some(*field_def as usize),
                _ => None,
            },
            offset: match row.get(7) {
                Some(Data::Int(field_def)) => Some(*field_def as usize),
                Some(Data::Float(field_def)) => Some(*field_def as usize),
                _ => None,
            },
        });
    }

    (next_message_name, messages)
}

fn generate_messages_code(messages: Vec<(String, Vec<Message>)>, enums: Vec<String>) -> String {
    let mut code = String::new();

    let mut messages_enum = join(
        messages.iter().map(|(msg, _)| {
            format!(
                "{}({}Field)",
                snake_to_camel_case(msg),
                snake_to_camel_case(msg)
            )
        }),
        ",\n",
    );
    if !messages_enum.is_empty() {
        messages_enum.push(',');
    }

    code.push_str(&format!(
        r#"
#[derive(Debug, PartialEq, Clone)]
pub enum FitMessage {{
    {messages_enum}
    Custom(CustomField),
    UnknownVariant
}}

#[derive(Debug, PartialEq, Clone)]
pub struct CustomField {{
    pub name: Option<String>,
    pub units: Option<String>,
}}"#
    ));

    for (msg, definitions) in messages.iter() {
        let message = snake_to_camel_case(msg);
        let variants = join(
            definitions
                .iter()
                .map(|def| snake_to_camel_case(&def.name).to_string())
                .chain(vec!["Unknown".to_string()]),
            ",\n",
        );

        code.push_str(&format!(
            r#"
#[derive(Debug, PartialEq, Clone)]
pub enum {message}Field {{
    {variants}
}}"#
        ));

        let from_definition_field_mappings = join(
            definitions
                .iter()
                .map(|def| {
                    format!(
                        "{} => Self::{}",
                        def.field_def,
                        snake_to_camel_case(&def.name)
                    )
                })
                .chain(vec!["_ => Self::Unknown".to_string()]),
            ",\n",
        );

        let parse_mappings = join(
            definitions
                .iter()
                .map(|def| {
                    format!(
                        "{} => {}",
                        def.field_def,
                        get_parse_function(&enums, &def.base_type)
                    )
                })
                .chain(vec!["_ => parse_uint8".to_string()]),
            ",\n",
        );

        let scale_offset_mapping = join(
            definitions
                .iter()
                .filter_map(|def| {
                    if def.offset.is_some() || def.scale.is_some() {
                        Some(format!(
                            "{} => Some(ScaleOffset {{
                                scale: {}_f32,
                                offset: {}_f32
                            }})",
                            def.field_def,
                            def.scale.unwrap_or(1),
                            def.offset.unwrap_or(0)
                        ))
                    } else {
                        None
                    }
                })
                .chain(vec!["_ => None".to_string()]),
            ",\n",
        );
        code.push_str(&format!(
            r#"
impl {message}Field {{

    fn from(definition_field: u8) -> Self {{
        match definition_field {{
            {from_definition_field_mappings}
        }}
    }}

    fn get_parse_function(
        def_number: u8
    ) -> fn(&mut Reader, &Endianness, u8) -> Result<Vec<DataValue>, DataTypeError> {{
        match def_number {{
            {parse_mappings}
        }}
    }}

    fn get_scale_offset(
        def_number: u8
    ) -> Option<ScaleOffset> {{
        match def_number {{
            {scale_offset_mapping}
        }}
    }}
}}"#
        ));
    }

    code
}
