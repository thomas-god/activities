// Code generated by build.rs - do not modify manually
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unreachable_patterns)]
#![allow(clippy::enum_variant_names)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::match_single_binding)]
#![allow(clippy::match_overlapping_arm)]

use crate::parser::definition::Endianness;
use crate::parser::reader::Reader;
use crate::parser::records::DataMessageField;
use crate::parser::types::{
    parse_byte_array as parse_byte, parse_float32, parse_float64, parse_sint16, parse_sint32,
    parse_sint64, parse_sint8, parse_string, parse_uint16, parse_uint16z, parse_uint32,
    parse_uint32z, parse_uint64, parse_uint64z, parse_uint8, parse_uint8z, parse_unknown,
    DataTypeError, DataValue, ScaleOffset,
};

#[derive(Debug, PartialEq, Clone)]
pub enum FitEnum {
    File(File),
    MesgNum(MesgNum),
    FileFlags(FileFlags),
    MesgCount(MesgCount),
    DateTime(DateTime),
    LocalDateTime(LocalDateTime),
    MessageIndex(MessageIndex),
    DeviceIndex(DeviceIndex),
    Gender(Gender),
    Language(Language),
    DisplayMeasure(DisplayMeasure),
    DisplayHeart(DisplayHeart),
    DisplayPower(DisplayPower),
    DisplayPosition(DisplayPosition),
    Switch(Switch),
    Sport(Sport),
    SportBits0(SportBits0),
    SubSport(SubSport),
    SportEvent(SportEvent),
    Activity(Activity),
    Intensity(Intensity),
    SessionTrigger(SessionTrigger),
    LapTrigger(LapTrigger),
    TimeMode(TimeMode),
    BacklightMode(BacklightMode),
    DateMode(DateMode),
    BacklightTimeout(BacklightTimeout),
    Event(Event),
    EventType(EventType),
    Tone(Tone),
    ActivityClass(ActivityClass),
    HrZoneCalc(HrZoneCalc),
    PwrZoneCalc(PwrZoneCalc),
    WktStepDuration(WktStepDuration),
    WktStepTarget(WktStepTarget),
    Goal(Goal),
    GoalRecurrence(GoalRecurrence),
    GoalSource(GoalSource),
    Schedule(Schedule),
    CoursePoint(CoursePoint),
    Manufacturer(Manufacturer),
    AntNetwork(AntNetwork),
    WorkoutCapabilities(WorkoutCapabilities),
    BatteryStatus(BatteryStatus),
    HrType(HrType),
    CourseCapabilities(CourseCapabilities),
    Weight(Weight),
    BpStatus(BpStatus),
    UserLocalId(UserLocalId),
    SwimStroke(SwimStroke),
    ActivityType(ActivityType),
    ActivitySubtype(ActivitySubtype),
    ActivityLevel(ActivityLevel),
    Side(Side),
    LeftRightBalance(LeftRightBalance),
    LeftRightBalance100(LeftRightBalance100),
    LengthType(LengthType),
    DayOfWeek(DayOfWeek),
    ConnectivityCapabilities(ConnectivityCapabilities),
    WeatherReport(WeatherReport),
    WeatherStatus(WeatherStatus),
    WeatherSeverity(WeatherSeverity),
    WeatherSevereType(WeatherSevereType),
    LocaltimeIntoDay(LocaltimeIntoDay),
    StrokeType(StrokeType),
    BodyLocation(BodyLocation),
    SegmentLapStatus(SegmentLapStatus),
    SegmentLeaderboardType(SegmentLeaderboardType),
    SegmentDeleteStatus(SegmentDeleteStatus),
    SegmentSelectionType(SegmentSelectionType),
    SourceType(SourceType),
    AntChannelId(AntChannelId),
    DisplayOrientation(DisplayOrientation),
    WorkoutEquipment(WorkoutEquipment),
    WatchfaceMode(WatchfaceMode),
    CameraEventType(CameraEventType),
    SensorType(SensorType),
    CameraOrientationType(CameraOrientationType),
    AttitudeStage(AttitudeStage),
    AttitudeValidity(AttitudeValidity),
    AutoSyncFrequency(AutoSyncFrequency),
    ExdLayout(ExdLayout),
    ExdDisplayType(ExdDisplayType),
    ExdDataUnits(ExdDataUnits),
    ExdQualifiers(ExdQualifiers),
    ExdDescriptors(ExdDescriptors),
    AutoActivityDetect(AutoActivityDetect),
    FitBaseType(FitBaseType),
    FitBaseUnit(FitBaseUnit),
    SetType(SetType),
    MaxMetCategory(MaxMetCategory),
    ExerciseCategory(ExerciseCategory),
    WaterType(WaterType),
    TissueModelType(TissueModelType),
    DiveGasStatus(DiveGasStatus),
    DiveAlarmType(DiveAlarmType),
    DiveBacklightMode(DiveBacklightMode),
    SleepLevel(SleepLevel),
    Spo2MeasurementType(Spo2MeasurementType),
    CcrSetpointSwitchMode(CcrSetpointSwitchMode),
    DiveGasMode(DiveGasMode),
    ProjectileType(ProjectileType),
    SplitType(SplitType),
    ClimbProEvent(ClimbProEvent),
    GasConsumptionRateType(GasConsumptionRateType),
    TapSensitivity(TapSensitivity),
    RadarThreatLevelType(RadarThreatLevelType),
    MaxMetSpeedSource(MaxMetSpeedSource),
    MaxMetHeartRateSource(MaxMetHeartRateSource),
    HrvStatus(HrvStatus),
    NoFlyTimeMode(NoFlyTimeMode),
}

#[derive(Debug, PartialEq, Clone)]
pub enum File {
    Device,
    Settings,
    Sport,
    Activity,
    Workout,
    Course,
    Schedules,
    Weight,
    Totals,
    Goals,
    BloodPressure,
    MonitoringA,
    ActivitySummary,
    MonitoringDaily,
    MonitoringB,
    Segment,
    SegmentList,
    ExdConfiguration,
    UnknownVariant(u8),
}
impl File {
    pub fn from(content: u8) -> File {
        match content {
            1 => File::Device,
            2 => File::Settings,
            3 => File::Sport,
            4 => File::Activity,
            5 => File::Workout,
            6 => File::Course,
            7 => File::Schedules,
            9 => File::Weight,
            10 => File::Totals,
            11 => File::Goals,
            14 => File::BloodPressure,
            15 => File::MonitoringA,
            20 => File::ActivitySummary,
            28 => File::MonitoringDaily,
            32 => File::MonitoringB,
            34 => File::Segment,
            35 => File::SegmentList,
            40 => File::ExdConfiguration,
            val => File::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::File(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum MesgNum {
    FileId,
    Capabilities,
    DeviceSettings,
    UserProfile,
    HrmProfile,
    SdmProfile,
    BikeProfile,
    ZonesTarget,
    HrZone,
    PowerZone,
    MetZone,
    Sport,
    TrainingSettings,
    Goal,
    Session,
    Lap,
    Record,
    Event,
    DeviceInfo,
    Workout,
    WorkoutStep,
    Schedule,
    WeightScale,
    Course,
    CoursePoint,
    Totals,
    Activity,
    Software,
    FileCapabilities,
    MesgCapabilities,
    FieldCapabilities,
    FileCreator,
    BloodPressure,
    SpeedZone,
    Monitoring,
    TrainingFile,
    Hrv,
    AntRx,
    AntTx,
    AntChannelId,
    Length,
    MonitoringInfo,
    SlaveDevice,
    Connectivity,
    WeatherConditions,
    WeatherAlert,
    CadenceZone,
    Hr,
    SegmentLap,
    MemoGlob,
    SegmentId,
    SegmentLeaderboardEntry,
    SegmentPoint,
    SegmentFile,
    WorkoutSession,
    WatchfaceSettings,
    GpsMetadata,
    CameraEvent,
    TimestampCorrelation,
    GyroscopeData,
    AccelerometerData,
    ThreeDSensorCalibration,
    VideoFrame,
    ObdiiData,
    NmeaSentence,
    AviationAttitude,
    Video,
    VideoTitle,
    VideoDescription,
    VideoClip,
    OhrSettings,
    ExdScreenConfiguration,
    ExdDataFieldConfiguration,
    ExdDataConceptConfiguration,
    FieldDescription,
    DeveloperDataId,
    MagnetometerData,
    BarometerData,
    OneDSensorCalibration,
    MonitoringHrData,
    TimeInZone,
    Set,
    StressLevel,
    MaxMetData,
    DiveSettings,
    DiveGas,
    DiveAlarm,
    ExerciseTitle,
    DiveSummary,
    Spo2Data,
    SleepLevel,
    Jump,
    AadAccelFeatures,
    BeatIntervals,
    RespirationRate,
    HsaAccelerometerData,
    HsaStepData,
    HsaSpo2Data,
    HsaStressData,
    HsaRespirationData,
    HsaHeartRateData,
    Split,
    SplitSummary,
    HsaBodyBatteryData,
    HsaEvent,
    ClimbPro,
    TankUpdate,
    TankSummary,
    SleepAssessment,
    HrvStatusSummary,
    HrvValue,
    RawBbi,
    DeviceAuxBatteryInfo,
    HsaGyroscopeData,
    ChronoShotSession,
    ChronoShotData,
    HsaConfigurationData,
    DiveApneaAlarm,
    SkinTempOvernight,
    HsaWristTemperatureData,
    UnknownVariant(u16),
}
impl MesgNum {
    pub fn from(content: u16) -> MesgNum {
        match content {
            0 => MesgNum::FileId,
            1 => MesgNum::Capabilities,
            2 => MesgNum::DeviceSettings,
            3 => MesgNum::UserProfile,
            4 => MesgNum::HrmProfile,
            5 => MesgNum::SdmProfile,
            6 => MesgNum::BikeProfile,
            7 => MesgNum::ZonesTarget,
            8 => MesgNum::HrZone,
            9 => MesgNum::PowerZone,
            10 => MesgNum::MetZone,
            12 => MesgNum::Sport,
            13 => MesgNum::TrainingSettings,
            15 => MesgNum::Goal,
            18 => MesgNum::Session,
            19 => MesgNum::Lap,
            20 => MesgNum::Record,
            21 => MesgNum::Event,
            23 => MesgNum::DeviceInfo,
            26 => MesgNum::Workout,
            27 => MesgNum::WorkoutStep,
            28 => MesgNum::Schedule,
            30 => MesgNum::WeightScale,
            31 => MesgNum::Course,
            32 => MesgNum::CoursePoint,
            33 => MesgNum::Totals,
            34 => MesgNum::Activity,
            35 => MesgNum::Software,
            37 => MesgNum::FileCapabilities,
            38 => MesgNum::MesgCapabilities,
            39 => MesgNum::FieldCapabilities,
            49 => MesgNum::FileCreator,
            51 => MesgNum::BloodPressure,
            53 => MesgNum::SpeedZone,
            55 => MesgNum::Monitoring,
            72 => MesgNum::TrainingFile,
            78 => MesgNum::Hrv,
            80 => MesgNum::AntRx,
            81 => MesgNum::AntTx,
            82 => MesgNum::AntChannelId,
            101 => MesgNum::Length,
            103 => MesgNum::MonitoringInfo,
            106 => MesgNum::SlaveDevice,
            127 => MesgNum::Connectivity,
            128 => MesgNum::WeatherConditions,
            129 => MesgNum::WeatherAlert,
            131 => MesgNum::CadenceZone,
            132 => MesgNum::Hr,
            142 => MesgNum::SegmentLap,
            145 => MesgNum::MemoGlob,
            148 => MesgNum::SegmentId,
            149 => MesgNum::SegmentLeaderboardEntry,
            150 => MesgNum::SegmentPoint,
            151 => MesgNum::SegmentFile,
            158 => MesgNum::WorkoutSession,
            159 => MesgNum::WatchfaceSettings,
            160 => MesgNum::GpsMetadata,
            161 => MesgNum::CameraEvent,
            162 => MesgNum::TimestampCorrelation,
            164 => MesgNum::GyroscopeData,
            165 => MesgNum::AccelerometerData,
            167 => MesgNum::ThreeDSensorCalibration,
            169 => MesgNum::VideoFrame,
            174 => MesgNum::ObdiiData,
            177 => MesgNum::NmeaSentence,
            178 => MesgNum::AviationAttitude,
            184 => MesgNum::Video,
            185 => MesgNum::VideoTitle,
            186 => MesgNum::VideoDescription,
            187 => MesgNum::VideoClip,
            188 => MesgNum::OhrSettings,
            200 => MesgNum::ExdScreenConfiguration,
            201 => MesgNum::ExdDataFieldConfiguration,
            202 => MesgNum::ExdDataConceptConfiguration,
            206 => MesgNum::FieldDescription,
            207 => MesgNum::DeveloperDataId,
            208 => MesgNum::MagnetometerData,
            209 => MesgNum::BarometerData,
            210 => MesgNum::OneDSensorCalibration,
            211 => MesgNum::MonitoringHrData,
            216 => MesgNum::TimeInZone,
            225 => MesgNum::Set,
            227 => MesgNum::StressLevel,
            229 => MesgNum::MaxMetData,
            258 => MesgNum::DiveSettings,
            259 => MesgNum::DiveGas,
            262 => MesgNum::DiveAlarm,
            264 => MesgNum::ExerciseTitle,
            268 => MesgNum::DiveSummary,
            269 => MesgNum::Spo2Data,
            275 => MesgNum::SleepLevel,
            285 => MesgNum::Jump,
            289 => MesgNum::AadAccelFeatures,
            290 => MesgNum::BeatIntervals,
            297 => MesgNum::RespirationRate,
            302 => MesgNum::HsaAccelerometerData,
            304 => MesgNum::HsaStepData,
            305 => MesgNum::HsaSpo2Data,
            306 => MesgNum::HsaStressData,
            307 => MesgNum::HsaRespirationData,
            308 => MesgNum::HsaHeartRateData,
            312 => MesgNum::Split,
            313 => MesgNum::SplitSummary,
            314 => MesgNum::HsaBodyBatteryData,
            315 => MesgNum::HsaEvent,
            317 => MesgNum::ClimbPro,
            319 => MesgNum::TankUpdate,
            323 => MesgNum::TankSummary,
            346 => MesgNum::SleepAssessment,
            370 => MesgNum::HrvStatusSummary,
            371 => MesgNum::HrvValue,
            372 => MesgNum::RawBbi,
            375 => MesgNum::DeviceAuxBatteryInfo,
            376 => MesgNum::HsaGyroscopeData,
            387 => MesgNum::ChronoShotSession,
            388 => MesgNum::ChronoShotData,
            389 => MesgNum::HsaConfigurationData,
            393 => MesgNum::DiveApneaAlarm,
            398 => MesgNum::SkinTempOvernight,
            409 => MesgNum::HsaWristTemperatureData,
            val => MesgNum::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::MesgNum(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
    pub fn message_field(&self, def_number: u8) -> FitMessage {
        match self {
            Self::FileId => FitMessage::FileId(FileIdField::from(def_number)),
            Self::Capabilities => FitMessage::Capabilities(CapabilitiesField::from(def_number)),
            Self::DeviceSettings => {
                FitMessage::DeviceSettings(DeviceSettingsField::from(def_number))
            }
            Self::UserProfile => FitMessage::UserProfile(UserProfileField::from(def_number)),
            Self::HrmProfile => FitMessage::HrmProfile(HrmProfileField::from(def_number)),
            Self::SdmProfile => FitMessage::SdmProfile(SdmProfileField::from(def_number)),
            Self::BikeProfile => FitMessage::BikeProfile(BikeProfileField::from(def_number)),
            Self::ZonesTarget => FitMessage::ZonesTarget(ZonesTargetField::from(def_number)),
            Self::HrZone => FitMessage::HrZone(HrZoneField::from(def_number)),
            Self::PowerZone => FitMessage::PowerZone(PowerZoneField::from(def_number)),
            Self::MetZone => FitMessage::MetZone(MetZoneField::from(def_number)),
            Self::Sport => FitMessage::Sport(SportField::from(def_number)),
            Self::TrainingSettings => {
                FitMessage::TrainingSettings(TrainingSettingsField::from(def_number))
            }
            Self::Goal => FitMessage::Goal(GoalField::from(def_number)),
            Self::Session => FitMessage::Session(SessionField::from(def_number)),
            Self::Lap => FitMessage::Lap(LapField::from(def_number)),
            Self::Record => FitMessage::Record(RecordField::from(def_number)),
            Self::Event => FitMessage::Event(EventField::from(def_number)),
            Self::DeviceInfo => FitMessage::DeviceInfo(DeviceInfoField::from(def_number)),
            Self::Workout => FitMessage::Workout(WorkoutField::from(def_number)),
            Self::WorkoutStep => FitMessage::WorkoutStep(WorkoutStepField::from(def_number)),
            Self::Schedule => FitMessage::Schedule(ScheduleField::from(def_number)),
            Self::WeightScale => FitMessage::WeightScale(WeightScaleField::from(def_number)),
            Self::Course => FitMessage::Course(CourseField::from(def_number)),
            Self::CoursePoint => FitMessage::CoursePoint(CoursePointField::from(def_number)),
            Self::Totals => FitMessage::Totals(TotalsField::from(def_number)),
            Self::Activity => FitMessage::Activity(ActivityField::from(def_number)),
            Self::Software => FitMessage::Software(SoftwareField::from(def_number)),
            Self::FileCapabilities => {
                FitMessage::FileCapabilities(FileCapabilitiesField::from(def_number))
            }
            Self::MesgCapabilities => {
                FitMessage::MesgCapabilities(MesgCapabilitiesField::from(def_number))
            }
            Self::FieldCapabilities => {
                FitMessage::FieldCapabilities(FieldCapabilitiesField::from(def_number))
            }
            Self::FileCreator => FitMessage::FileCreator(FileCreatorField::from(def_number)),
            Self::BloodPressure => FitMessage::BloodPressure(BloodPressureField::from(def_number)),
            Self::SpeedZone => FitMessage::SpeedZone(SpeedZoneField::from(def_number)),
            Self::Monitoring => FitMessage::Monitoring(MonitoringField::from(def_number)),
            Self::TrainingFile => FitMessage::TrainingFile(TrainingFileField::from(def_number)),
            Self::Hrv => FitMessage::Hrv(HrvField::from(def_number)),
            Self::AntRx => FitMessage::AntRx(AntRxField::from(def_number)),
            Self::AntTx => FitMessage::AntTx(AntTxField::from(def_number)),
            Self::AntChannelId => FitMessage::AntChannelId(AntChannelIdField::from(def_number)),
            Self::Length => FitMessage::Length(LengthField::from(def_number)),
            Self::MonitoringInfo => {
                FitMessage::MonitoringInfo(MonitoringInfoField::from(def_number))
            }
            Self::SlaveDevice => FitMessage::SlaveDevice(SlaveDeviceField::from(def_number)),
            Self::Connectivity => FitMessage::Connectivity(ConnectivityField::from(def_number)),
            Self::WeatherConditions => {
                FitMessage::WeatherConditions(WeatherConditionsField::from(def_number))
            }
            Self::WeatherAlert => FitMessage::WeatherAlert(WeatherAlertField::from(def_number)),
            Self::CadenceZone => FitMessage::CadenceZone(CadenceZoneField::from(def_number)),
            Self::Hr => FitMessage::Hr(HrField::from(def_number)),
            Self::SegmentLap => FitMessage::SegmentLap(SegmentLapField::from(def_number)),
            Self::MemoGlob => FitMessage::MemoGlob(MemoGlobField::from(def_number)),
            Self::SegmentId => FitMessage::SegmentId(SegmentIdField::from(def_number)),
            Self::SegmentLeaderboardEntry => {
                FitMessage::SegmentLeaderboardEntry(SegmentLeaderboardEntryField::from(def_number))
            }
            Self::SegmentPoint => FitMessage::SegmentPoint(SegmentPointField::from(def_number)),
            Self::SegmentFile => FitMessage::SegmentFile(SegmentFileField::from(def_number)),
            Self::WorkoutSession => {
                FitMessage::WorkoutSession(WorkoutSessionField::from(def_number))
            }
            Self::WatchfaceSettings => {
                FitMessage::WatchfaceSettings(WatchfaceSettingsField::from(def_number))
            }
            Self::GpsMetadata => FitMessage::GpsMetadata(GpsMetadataField::from(def_number)),
            Self::CameraEvent => FitMessage::CameraEvent(CameraEventField::from(def_number)),
            Self::TimestampCorrelation => {
                FitMessage::TimestampCorrelation(TimestampCorrelationField::from(def_number))
            }
            Self::GyroscopeData => FitMessage::GyroscopeData(GyroscopeDataField::from(def_number)),
            Self::AccelerometerData => {
                FitMessage::AccelerometerData(AccelerometerDataField::from(def_number))
            }
            Self::ThreeDSensorCalibration => {
                FitMessage::ThreeDSensorCalibration(ThreeDSensorCalibrationField::from(def_number))
            }
            Self::VideoFrame => FitMessage::VideoFrame(VideoFrameField::from(def_number)),
            Self::ObdiiData => FitMessage::ObdiiData(ObdiiDataField::from(def_number)),
            Self::NmeaSentence => FitMessage::NmeaSentence(NmeaSentenceField::from(def_number)),
            Self::AviationAttitude => {
                FitMessage::AviationAttitude(AviationAttitudeField::from(def_number))
            }
            Self::Video => FitMessage::Video(VideoField::from(def_number)),
            Self::VideoTitle => FitMessage::VideoTitle(VideoTitleField::from(def_number)),
            Self::VideoDescription => {
                FitMessage::VideoDescription(VideoDescriptionField::from(def_number))
            }
            Self::VideoClip => FitMessage::VideoClip(VideoClipField::from(def_number)),
            Self::OhrSettings => FitMessage::OhrSettings(OhrSettingsField::from(def_number)),
            Self::ExdScreenConfiguration => {
                FitMessage::ExdScreenConfiguration(ExdScreenConfigurationField::from(def_number))
            }
            Self::ExdDataFieldConfiguration => FitMessage::ExdDataFieldConfiguration(
                ExdDataFieldConfigurationField::from(def_number),
            ),
            Self::ExdDataConceptConfiguration => FitMessage::ExdDataConceptConfiguration(
                ExdDataConceptConfigurationField::from(def_number),
            ),
            Self::FieldDescription => {
                FitMessage::FieldDescription(FieldDescriptionField::from(def_number))
            }
            Self::DeveloperDataId => {
                FitMessage::DeveloperDataId(DeveloperDataIdField::from(def_number))
            }
            Self::MagnetometerData => {
                FitMessage::MagnetometerData(MagnetometerDataField::from(def_number))
            }
            Self::BarometerData => FitMessage::BarometerData(BarometerDataField::from(def_number)),
            Self::OneDSensorCalibration => {
                FitMessage::OneDSensorCalibration(OneDSensorCalibrationField::from(def_number))
            }
            Self::MonitoringHrData => {
                FitMessage::MonitoringHrData(MonitoringHrDataField::from(def_number))
            }
            Self::TimeInZone => FitMessage::TimeInZone(TimeInZoneField::from(def_number)),
            Self::Set => FitMessage::Set(SetField::from(def_number)),
            Self::StressLevel => FitMessage::StressLevel(StressLevelField::from(def_number)),
            Self::MaxMetData => FitMessage::MaxMetData(MaxMetDataField::from(def_number)),
            Self::DiveSettings => FitMessage::DiveSettings(DiveSettingsField::from(def_number)),
            Self::DiveGas => FitMessage::DiveGas(DiveGasField::from(def_number)),
            Self::DiveAlarm => FitMessage::DiveAlarm(DiveAlarmField::from(def_number)),
            Self::ExerciseTitle => FitMessage::ExerciseTitle(ExerciseTitleField::from(def_number)),
            Self::DiveSummary => FitMessage::DiveSummary(DiveSummaryField::from(def_number)),
            Self::Spo2Data => FitMessage::Spo2Data(Spo2DataField::from(def_number)),
            Self::SleepLevel => FitMessage::SleepLevel(SleepLevelField::from(def_number)),
            Self::Jump => FitMessage::Jump(JumpField::from(def_number)),
            Self::AadAccelFeatures => {
                FitMessage::AadAccelFeatures(AadAccelFeaturesField::from(def_number))
            }
            Self::BeatIntervals => FitMessage::BeatIntervals(BeatIntervalsField::from(def_number)),
            Self::RespirationRate => {
                FitMessage::RespirationRate(RespirationRateField::from(def_number))
            }
            Self::HsaAccelerometerData => {
                FitMessage::HsaAccelerometerData(HsaAccelerometerDataField::from(def_number))
            }
            Self::HsaStepData => FitMessage::HsaStepData(HsaStepDataField::from(def_number)),
            Self::HsaSpo2Data => FitMessage::HsaSpo2Data(HsaSpo2DataField::from(def_number)),
            Self::HsaStressData => FitMessage::HsaStressData(HsaStressDataField::from(def_number)),
            Self::HsaRespirationData => {
                FitMessage::HsaRespirationData(HsaRespirationDataField::from(def_number))
            }
            Self::HsaHeartRateData => {
                FitMessage::HsaHeartRateData(HsaHeartRateDataField::from(def_number))
            }
            Self::Split => FitMessage::Split(SplitField::from(def_number)),
            Self::SplitSummary => FitMessage::SplitSummary(SplitSummaryField::from(def_number)),
            Self::HsaBodyBatteryData => {
                FitMessage::HsaBodyBatteryData(HsaBodyBatteryDataField::from(def_number))
            }
            Self::HsaEvent => FitMessage::HsaEvent(HsaEventField::from(def_number)),
            Self::ClimbPro => FitMessage::ClimbPro(ClimbProField::from(def_number)),
            Self::TankUpdate => FitMessage::TankUpdate(TankUpdateField::from(def_number)),
            Self::TankSummary => FitMessage::TankSummary(TankSummaryField::from(def_number)),
            Self::SleepAssessment => {
                FitMessage::SleepAssessment(SleepAssessmentField::from(def_number))
            }
            Self::HrvStatusSummary => {
                FitMessage::HrvStatusSummary(HrvStatusSummaryField::from(def_number))
            }
            Self::HrvValue => FitMessage::HrvValue(HrvValueField::from(def_number)),
            Self::RawBbi => FitMessage::RawBbi(RawBbiField::from(def_number)),
            Self::DeviceAuxBatteryInfo => {
                FitMessage::DeviceAuxBatteryInfo(DeviceAuxBatteryInfoField::from(def_number))
            }
            Self::HsaGyroscopeData => {
                FitMessage::HsaGyroscopeData(HsaGyroscopeDataField::from(def_number))
            }
            Self::ChronoShotSession => {
                FitMessage::ChronoShotSession(ChronoShotSessionField::from(def_number))
            }
            Self::ChronoShotData => {
                FitMessage::ChronoShotData(ChronoShotDataField::from(def_number))
            }
            Self::HsaConfigurationData => {
                FitMessage::HsaConfigurationData(HsaConfigurationDataField::from(def_number))
            }
            Self::DiveApneaAlarm => {
                FitMessage::DiveApneaAlarm(DiveApneaAlarmField::from(def_number))
            }
            Self::SkinTempOvernight => {
                FitMessage::SkinTempOvernight(SkinTempOvernightField::from(def_number))
            }
            Self::HsaWristTemperatureData => {
                FitMessage::HsaWristTemperatureData(HsaWristTemperatureDataField::from(def_number))
            }
            _ => FitMessage::UnknownVariant(0),
        }
    }

    pub fn field_parse(&self, def_number: u8) -> ParseFunction {
        match self {
            Self::FileId => FileIdField::get_parse_function(def_number),
            Self::Capabilities => CapabilitiesField::get_parse_function(def_number),
            Self::DeviceSettings => DeviceSettingsField::get_parse_function(def_number),
            Self::UserProfile => UserProfileField::get_parse_function(def_number),
            Self::HrmProfile => HrmProfileField::get_parse_function(def_number),
            Self::SdmProfile => SdmProfileField::get_parse_function(def_number),
            Self::BikeProfile => BikeProfileField::get_parse_function(def_number),
            Self::ZonesTarget => ZonesTargetField::get_parse_function(def_number),
            Self::HrZone => HrZoneField::get_parse_function(def_number),
            Self::PowerZone => PowerZoneField::get_parse_function(def_number),
            Self::MetZone => MetZoneField::get_parse_function(def_number),
            Self::Sport => SportField::get_parse_function(def_number),
            Self::TrainingSettings => TrainingSettingsField::get_parse_function(def_number),
            Self::Goal => GoalField::get_parse_function(def_number),
            Self::Session => SessionField::get_parse_function(def_number),
            Self::Lap => LapField::get_parse_function(def_number),
            Self::Record => RecordField::get_parse_function(def_number),
            Self::Event => EventField::get_parse_function(def_number),
            Self::DeviceInfo => DeviceInfoField::get_parse_function(def_number),
            Self::Workout => WorkoutField::get_parse_function(def_number),
            Self::WorkoutStep => WorkoutStepField::get_parse_function(def_number),
            Self::Schedule => ScheduleField::get_parse_function(def_number),
            Self::WeightScale => WeightScaleField::get_parse_function(def_number),
            Self::Course => CourseField::get_parse_function(def_number),
            Self::CoursePoint => CoursePointField::get_parse_function(def_number),
            Self::Totals => TotalsField::get_parse_function(def_number),
            Self::Activity => ActivityField::get_parse_function(def_number),
            Self::Software => SoftwareField::get_parse_function(def_number),
            Self::FileCapabilities => FileCapabilitiesField::get_parse_function(def_number),
            Self::MesgCapabilities => MesgCapabilitiesField::get_parse_function(def_number),
            Self::FieldCapabilities => FieldCapabilitiesField::get_parse_function(def_number),
            Self::FileCreator => FileCreatorField::get_parse_function(def_number),
            Self::BloodPressure => BloodPressureField::get_parse_function(def_number),
            Self::SpeedZone => SpeedZoneField::get_parse_function(def_number),
            Self::Monitoring => MonitoringField::get_parse_function(def_number),
            Self::TrainingFile => TrainingFileField::get_parse_function(def_number),
            Self::Hrv => HrvField::get_parse_function(def_number),
            Self::AntRx => AntRxField::get_parse_function(def_number),
            Self::AntTx => AntTxField::get_parse_function(def_number),
            Self::AntChannelId => AntChannelIdField::get_parse_function(def_number),
            Self::Length => LengthField::get_parse_function(def_number),
            Self::MonitoringInfo => MonitoringInfoField::get_parse_function(def_number),
            Self::SlaveDevice => SlaveDeviceField::get_parse_function(def_number),
            Self::Connectivity => ConnectivityField::get_parse_function(def_number),
            Self::WeatherConditions => WeatherConditionsField::get_parse_function(def_number),
            Self::WeatherAlert => WeatherAlertField::get_parse_function(def_number),
            Self::CadenceZone => CadenceZoneField::get_parse_function(def_number),
            Self::Hr => HrField::get_parse_function(def_number),
            Self::SegmentLap => SegmentLapField::get_parse_function(def_number),
            Self::MemoGlob => MemoGlobField::get_parse_function(def_number),
            Self::SegmentId => SegmentIdField::get_parse_function(def_number),
            Self::SegmentLeaderboardEntry => {
                SegmentLeaderboardEntryField::get_parse_function(def_number)
            }
            Self::SegmentPoint => SegmentPointField::get_parse_function(def_number),
            Self::SegmentFile => SegmentFileField::get_parse_function(def_number),
            Self::WorkoutSession => WorkoutSessionField::get_parse_function(def_number),
            Self::WatchfaceSettings => WatchfaceSettingsField::get_parse_function(def_number),
            Self::GpsMetadata => GpsMetadataField::get_parse_function(def_number),
            Self::CameraEvent => CameraEventField::get_parse_function(def_number),
            Self::TimestampCorrelation => TimestampCorrelationField::get_parse_function(def_number),
            Self::GyroscopeData => GyroscopeDataField::get_parse_function(def_number),
            Self::AccelerometerData => AccelerometerDataField::get_parse_function(def_number),
            Self::ThreeDSensorCalibration => {
                ThreeDSensorCalibrationField::get_parse_function(def_number)
            }
            Self::VideoFrame => VideoFrameField::get_parse_function(def_number),
            Self::ObdiiData => ObdiiDataField::get_parse_function(def_number),
            Self::NmeaSentence => NmeaSentenceField::get_parse_function(def_number),
            Self::AviationAttitude => AviationAttitudeField::get_parse_function(def_number),
            Self::Video => VideoField::get_parse_function(def_number),
            Self::VideoTitle => VideoTitleField::get_parse_function(def_number),
            Self::VideoDescription => VideoDescriptionField::get_parse_function(def_number),
            Self::VideoClip => VideoClipField::get_parse_function(def_number),
            Self::OhrSettings => OhrSettingsField::get_parse_function(def_number),
            Self::ExdScreenConfiguration => {
                ExdScreenConfigurationField::get_parse_function(def_number)
            }
            Self::ExdDataFieldConfiguration => {
                ExdDataFieldConfigurationField::get_parse_function(def_number)
            }
            Self::ExdDataConceptConfiguration => {
                ExdDataConceptConfigurationField::get_parse_function(def_number)
            }
            Self::FieldDescription => FieldDescriptionField::get_parse_function(def_number),
            Self::DeveloperDataId => DeveloperDataIdField::get_parse_function(def_number),
            Self::MagnetometerData => MagnetometerDataField::get_parse_function(def_number),
            Self::BarometerData => BarometerDataField::get_parse_function(def_number),
            Self::OneDSensorCalibration => {
                OneDSensorCalibrationField::get_parse_function(def_number)
            }
            Self::MonitoringHrData => MonitoringHrDataField::get_parse_function(def_number),
            Self::TimeInZone => TimeInZoneField::get_parse_function(def_number),
            Self::Set => SetField::get_parse_function(def_number),
            Self::StressLevel => StressLevelField::get_parse_function(def_number),
            Self::MaxMetData => MaxMetDataField::get_parse_function(def_number),
            Self::DiveSettings => DiveSettingsField::get_parse_function(def_number),
            Self::DiveGas => DiveGasField::get_parse_function(def_number),
            Self::DiveAlarm => DiveAlarmField::get_parse_function(def_number),
            Self::ExerciseTitle => ExerciseTitleField::get_parse_function(def_number),
            Self::DiveSummary => DiveSummaryField::get_parse_function(def_number),
            Self::Spo2Data => Spo2DataField::get_parse_function(def_number),
            Self::SleepLevel => SleepLevelField::get_parse_function(def_number),
            Self::Jump => JumpField::get_parse_function(def_number),
            Self::AadAccelFeatures => AadAccelFeaturesField::get_parse_function(def_number),
            Self::BeatIntervals => BeatIntervalsField::get_parse_function(def_number),
            Self::RespirationRate => RespirationRateField::get_parse_function(def_number),
            Self::HsaAccelerometerData => HsaAccelerometerDataField::get_parse_function(def_number),
            Self::HsaStepData => HsaStepDataField::get_parse_function(def_number),
            Self::HsaSpo2Data => HsaSpo2DataField::get_parse_function(def_number),
            Self::HsaStressData => HsaStressDataField::get_parse_function(def_number),
            Self::HsaRespirationData => HsaRespirationDataField::get_parse_function(def_number),
            Self::HsaHeartRateData => HsaHeartRateDataField::get_parse_function(def_number),
            Self::Split => SplitField::get_parse_function(def_number),
            Self::SplitSummary => SplitSummaryField::get_parse_function(def_number),
            Self::HsaBodyBatteryData => HsaBodyBatteryDataField::get_parse_function(def_number),
            Self::HsaEvent => HsaEventField::get_parse_function(def_number),
            Self::ClimbPro => ClimbProField::get_parse_function(def_number),
            Self::TankUpdate => TankUpdateField::get_parse_function(def_number),
            Self::TankSummary => TankSummaryField::get_parse_function(def_number),
            Self::SleepAssessment => SleepAssessmentField::get_parse_function(def_number),
            Self::HrvStatusSummary => HrvStatusSummaryField::get_parse_function(def_number),
            Self::HrvValue => HrvValueField::get_parse_function(def_number),
            Self::RawBbi => RawBbiField::get_parse_function(def_number),
            Self::DeviceAuxBatteryInfo => DeviceAuxBatteryInfoField::get_parse_function(def_number),
            Self::HsaGyroscopeData => HsaGyroscopeDataField::get_parse_function(def_number),
            Self::ChronoShotSession => ChronoShotSessionField::get_parse_function(def_number),
            Self::ChronoShotData => ChronoShotDataField::get_parse_function(def_number),
            Self::HsaConfigurationData => HsaConfigurationDataField::get_parse_function(def_number),
            Self::DiveApneaAlarm => DiveApneaAlarmField::get_parse_function(def_number),
            Self::SkinTempOvernight => SkinTempOvernightField::get_parse_function(def_number),
            Self::HsaWristTemperatureData => {
                HsaWristTemperatureDataField::get_parse_function(def_number)
            }
            _ => ParseFunction::Simple(parse_unknown),
        }
    }

    pub fn scale_offset(&self, def_number: u8) -> Option<ScaleOffset> {
        match self {
            Self::FileId => FileIdField::get_scale_offset(def_number),
            Self::Capabilities => CapabilitiesField::get_scale_offset(def_number),
            Self::DeviceSettings => DeviceSettingsField::get_scale_offset(def_number),
            Self::UserProfile => UserProfileField::get_scale_offset(def_number),
            Self::HrmProfile => HrmProfileField::get_scale_offset(def_number),
            Self::SdmProfile => SdmProfileField::get_scale_offset(def_number),
            Self::BikeProfile => BikeProfileField::get_scale_offset(def_number),
            Self::ZonesTarget => ZonesTargetField::get_scale_offset(def_number),
            Self::HrZone => HrZoneField::get_scale_offset(def_number),
            Self::PowerZone => PowerZoneField::get_scale_offset(def_number),
            Self::MetZone => MetZoneField::get_scale_offset(def_number),
            Self::Sport => SportField::get_scale_offset(def_number),
            Self::TrainingSettings => TrainingSettingsField::get_scale_offset(def_number),
            Self::Goal => GoalField::get_scale_offset(def_number),
            Self::Session => SessionField::get_scale_offset(def_number),
            Self::Lap => LapField::get_scale_offset(def_number),
            Self::Record => RecordField::get_scale_offset(def_number),
            Self::Event => EventField::get_scale_offset(def_number),
            Self::DeviceInfo => DeviceInfoField::get_scale_offset(def_number),
            Self::Workout => WorkoutField::get_scale_offset(def_number),
            Self::WorkoutStep => WorkoutStepField::get_scale_offset(def_number),
            Self::Schedule => ScheduleField::get_scale_offset(def_number),
            Self::WeightScale => WeightScaleField::get_scale_offset(def_number),
            Self::Course => CourseField::get_scale_offset(def_number),
            Self::CoursePoint => CoursePointField::get_scale_offset(def_number),
            Self::Totals => TotalsField::get_scale_offset(def_number),
            Self::Activity => ActivityField::get_scale_offset(def_number),
            Self::Software => SoftwareField::get_scale_offset(def_number),
            Self::FileCapabilities => FileCapabilitiesField::get_scale_offset(def_number),
            Self::MesgCapabilities => MesgCapabilitiesField::get_scale_offset(def_number),
            Self::FieldCapabilities => FieldCapabilitiesField::get_scale_offset(def_number),
            Self::FileCreator => FileCreatorField::get_scale_offset(def_number),
            Self::BloodPressure => BloodPressureField::get_scale_offset(def_number),
            Self::SpeedZone => SpeedZoneField::get_scale_offset(def_number),
            Self::Monitoring => MonitoringField::get_scale_offset(def_number),
            Self::TrainingFile => TrainingFileField::get_scale_offset(def_number),
            Self::Hrv => HrvField::get_scale_offset(def_number),
            Self::AntRx => AntRxField::get_scale_offset(def_number),
            Self::AntTx => AntTxField::get_scale_offset(def_number),
            Self::AntChannelId => AntChannelIdField::get_scale_offset(def_number),
            Self::Length => LengthField::get_scale_offset(def_number),
            Self::MonitoringInfo => MonitoringInfoField::get_scale_offset(def_number),
            Self::SlaveDevice => SlaveDeviceField::get_scale_offset(def_number),
            Self::Connectivity => ConnectivityField::get_scale_offset(def_number),
            Self::WeatherConditions => WeatherConditionsField::get_scale_offset(def_number),
            Self::WeatherAlert => WeatherAlertField::get_scale_offset(def_number),
            Self::CadenceZone => CadenceZoneField::get_scale_offset(def_number),
            Self::Hr => HrField::get_scale_offset(def_number),
            Self::SegmentLap => SegmentLapField::get_scale_offset(def_number),
            Self::MemoGlob => MemoGlobField::get_scale_offset(def_number),
            Self::SegmentId => SegmentIdField::get_scale_offset(def_number),
            Self::SegmentLeaderboardEntry => {
                SegmentLeaderboardEntryField::get_scale_offset(def_number)
            }
            Self::SegmentPoint => SegmentPointField::get_scale_offset(def_number),
            Self::SegmentFile => SegmentFileField::get_scale_offset(def_number),
            Self::WorkoutSession => WorkoutSessionField::get_scale_offset(def_number),
            Self::WatchfaceSettings => WatchfaceSettingsField::get_scale_offset(def_number),
            Self::GpsMetadata => GpsMetadataField::get_scale_offset(def_number),
            Self::CameraEvent => CameraEventField::get_scale_offset(def_number),
            Self::TimestampCorrelation => TimestampCorrelationField::get_scale_offset(def_number),
            Self::GyroscopeData => GyroscopeDataField::get_scale_offset(def_number),
            Self::AccelerometerData => AccelerometerDataField::get_scale_offset(def_number),
            Self::ThreeDSensorCalibration => {
                ThreeDSensorCalibrationField::get_scale_offset(def_number)
            }
            Self::VideoFrame => VideoFrameField::get_scale_offset(def_number),
            Self::ObdiiData => ObdiiDataField::get_scale_offset(def_number),
            Self::NmeaSentence => NmeaSentenceField::get_scale_offset(def_number),
            Self::AviationAttitude => AviationAttitudeField::get_scale_offset(def_number),
            Self::Video => VideoField::get_scale_offset(def_number),
            Self::VideoTitle => VideoTitleField::get_scale_offset(def_number),
            Self::VideoDescription => VideoDescriptionField::get_scale_offset(def_number),
            Self::VideoClip => VideoClipField::get_scale_offset(def_number),
            Self::OhrSettings => OhrSettingsField::get_scale_offset(def_number),
            Self::ExdScreenConfiguration => {
                ExdScreenConfigurationField::get_scale_offset(def_number)
            }
            Self::ExdDataFieldConfiguration => {
                ExdDataFieldConfigurationField::get_scale_offset(def_number)
            }
            Self::ExdDataConceptConfiguration => {
                ExdDataConceptConfigurationField::get_scale_offset(def_number)
            }
            Self::FieldDescription => FieldDescriptionField::get_scale_offset(def_number),
            Self::DeveloperDataId => DeveloperDataIdField::get_scale_offset(def_number),
            Self::MagnetometerData => MagnetometerDataField::get_scale_offset(def_number),
            Self::BarometerData => BarometerDataField::get_scale_offset(def_number),
            Self::OneDSensorCalibration => OneDSensorCalibrationField::get_scale_offset(def_number),
            Self::MonitoringHrData => MonitoringHrDataField::get_scale_offset(def_number),
            Self::TimeInZone => TimeInZoneField::get_scale_offset(def_number),
            Self::Set => SetField::get_scale_offset(def_number),
            Self::StressLevel => StressLevelField::get_scale_offset(def_number),
            Self::MaxMetData => MaxMetDataField::get_scale_offset(def_number),
            Self::DiveSettings => DiveSettingsField::get_scale_offset(def_number),
            Self::DiveGas => DiveGasField::get_scale_offset(def_number),
            Self::DiveAlarm => DiveAlarmField::get_scale_offset(def_number),
            Self::ExerciseTitle => ExerciseTitleField::get_scale_offset(def_number),
            Self::DiveSummary => DiveSummaryField::get_scale_offset(def_number),
            Self::Spo2Data => Spo2DataField::get_scale_offset(def_number),
            Self::SleepLevel => SleepLevelField::get_scale_offset(def_number),
            Self::Jump => JumpField::get_scale_offset(def_number),
            Self::AadAccelFeatures => AadAccelFeaturesField::get_scale_offset(def_number),
            Self::BeatIntervals => BeatIntervalsField::get_scale_offset(def_number),
            Self::RespirationRate => RespirationRateField::get_scale_offset(def_number),
            Self::HsaAccelerometerData => HsaAccelerometerDataField::get_scale_offset(def_number),
            Self::HsaStepData => HsaStepDataField::get_scale_offset(def_number),
            Self::HsaSpo2Data => HsaSpo2DataField::get_scale_offset(def_number),
            Self::HsaStressData => HsaStressDataField::get_scale_offset(def_number),
            Self::HsaRespirationData => HsaRespirationDataField::get_scale_offset(def_number),
            Self::HsaHeartRateData => HsaHeartRateDataField::get_scale_offset(def_number),
            Self::Split => SplitField::get_scale_offset(def_number),
            Self::SplitSummary => SplitSummaryField::get_scale_offset(def_number),
            Self::HsaBodyBatteryData => HsaBodyBatteryDataField::get_scale_offset(def_number),
            Self::HsaEvent => HsaEventField::get_scale_offset(def_number),
            Self::ClimbPro => ClimbProField::get_scale_offset(def_number),
            Self::TankUpdate => TankUpdateField::get_scale_offset(def_number),
            Self::TankSummary => TankSummaryField::get_scale_offset(def_number),
            Self::SleepAssessment => SleepAssessmentField::get_scale_offset(def_number),
            Self::HrvStatusSummary => HrvStatusSummaryField::get_scale_offset(def_number),
            Self::HrvValue => HrvValueField::get_scale_offset(def_number),
            Self::RawBbi => RawBbiField::get_scale_offset(def_number),
            Self::DeviceAuxBatteryInfo => DeviceAuxBatteryInfoField::get_scale_offset(def_number),
            Self::HsaGyroscopeData => HsaGyroscopeDataField::get_scale_offset(def_number),
            Self::ChronoShotSession => ChronoShotSessionField::get_scale_offset(def_number),
            Self::ChronoShotData => ChronoShotDataField::get_scale_offset(def_number),
            Self::HsaConfigurationData => HsaConfigurationDataField::get_scale_offset(def_number),
            Self::DiveApneaAlarm => DiveApneaAlarmField::get_scale_offset(def_number),
            Self::SkinTempOvernight => SkinTempOvernightField::get_scale_offset(def_number),
            Self::HsaWristTemperatureData => {
                HsaWristTemperatureDataField::get_scale_offset(def_number)
            }
            _ => None,
        }
    }

    pub fn timestamp_field(&self) -> Option<FitMessage> {
        match self {
            Self::FileId => FileIdField::timestamp_field(),
            Self::Capabilities => CapabilitiesField::timestamp_field(),
            Self::DeviceSettings => DeviceSettingsField::timestamp_field(),
            Self::UserProfile => UserProfileField::timestamp_field(),
            Self::HrmProfile => HrmProfileField::timestamp_field(),
            Self::SdmProfile => SdmProfileField::timestamp_field(),
            Self::BikeProfile => BikeProfileField::timestamp_field(),
            Self::ZonesTarget => ZonesTargetField::timestamp_field(),
            Self::HrZone => HrZoneField::timestamp_field(),
            Self::PowerZone => PowerZoneField::timestamp_field(),
            Self::MetZone => MetZoneField::timestamp_field(),
            Self::Sport => SportField::timestamp_field(),
            Self::TrainingSettings => TrainingSettingsField::timestamp_field(),
            Self::Goal => GoalField::timestamp_field(),
            Self::Session => SessionField::timestamp_field(),
            Self::Lap => LapField::timestamp_field(),
            Self::Record => RecordField::timestamp_field(),
            Self::Event => EventField::timestamp_field(),
            Self::DeviceInfo => DeviceInfoField::timestamp_field(),
            Self::Workout => WorkoutField::timestamp_field(),
            Self::WorkoutStep => WorkoutStepField::timestamp_field(),
            Self::Schedule => ScheduleField::timestamp_field(),
            Self::WeightScale => WeightScaleField::timestamp_field(),
            Self::Course => CourseField::timestamp_field(),
            Self::CoursePoint => CoursePointField::timestamp_field(),
            Self::Totals => TotalsField::timestamp_field(),
            Self::Activity => ActivityField::timestamp_field(),
            Self::Software => SoftwareField::timestamp_field(),
            Self::FileCapabilities => FileCapabilitiesField::timestamp_field(),
            Self::MesgCapabilities => MesgCapabilitiesField::timestamp_field(),
            Self::FieldCapabilities => FieldCapabilitiesField::timestamp_field(),
            Self::FileCreator => FileCreatorField::timestamp_field(),
            Self::BloodPressure => BloodPressureField::timestamp_field(),
            Self::SpeedZone => SpeedZoneField::timestamp_field(),
            Self::Monitoring => MonitoringField::timestamp_field(),
            Self::TrainingFile => TrainingFileField::timestamp_field(),
            Self::Hrv => HrvField::timestamp_field(),
            Self::AntRx => AntRxField::timestamp_field(),
            Self::AntTx => AntTxField::timestamp_field(),
            Self::AntChannelId => AntChannelIdField::timestamp_field(),
            Self::Length => LengthField::timestamp_field(),
            Self::MonitoringInfo => MonitoringInfoField::timestamp_field(),
            Self::SlaveDevice => SlaveDeviceField::timestamp_field(),
            Self::Connectivity => ConnectivityField::timestamp_field(),
            Self::WeatherConditions => WeatherConditionsField::timestamp_field(),
            Self::WeatherAlert => WeatherAlertField::timestamp_field(),
            Self::CadenceZone => CadenceZoneField::timestamp_field(),
            Self::Hr => HrField::timestamp_field(),
            Self::SegmentLap => SegmentLapField::timestamp_field(),
            Self::MemoGlob => MemoGlobField::timestamp_field(),
            Self::SegmentId => SegmentIdField::timestamp_field(),
            Self::SegmentLeaderboardEntry => SegmentLeaderboardEntryField::timestamp_field(),
            Self::SegmentPoint => SegmentPointField::timestamp_field(),
            Self::SegmentFile => SegmentFileField::timestamp_field(),
            Self::WorkoutSession => WorkoutSessionField::timestamp_field(),
            Self::WatchfaceSettings => WatchfaceSettingsField::timestamp_field(),
            Self::GpsMetadata => GpsMetadataField::timestamp_field(),
            Self::CameraEvent => CameraEventField::timestamp_field(),
            Self::TimestampCorrelation => TimestampCorrelationField::timestamp_field(),
            Self::GyroscopeData => GyroscopeDataField::timestamp_field(),
            Self::AccelerometerData => AccelerometerDataField::timestamp_field(),
            Self::ThreeDSensorCalibration => ThreeDSensorCalibrationField::timestamp_field(),
            Self::VideoFrame => VideoFrameField::timestamp_field(),
            Self::ObdiiData => ObdiiDataField::timestamp_field(),
            Self::NmeaSentence => NmeaSentenceField::timestamp_field(),
            Self::AviationAttitude => AviationAttitudeField::timestamp_field(),
            Self::Video => VideoField::timestamp_field(),
            Self::VideoTitle => VideoTitleField::timestamp_field(),
            Self::VideoDescription => VideoDescriptionField::timestamp_field(),
            Self::VideoClip => VideoClipField::timestamp_field(),
            Self::OhrSettings => OhrSettingsField::timestamp_field(),
            Self::ExdScreenConfiguration => ExdScreenConfigurationField::timestamp_field(),
            Self::ExdDataFieldConfiguration => ExdDataFieldConfigurationField::timestamp_field(),
            Self::ExdDataConceptConfiguration => {
                ExdDataConceptConfigurationField::timestamp_field()
            }
            Self::FieldDescription => FieldDescriptionField::timestamp_field(),
            Self::DeveloperDataId => DeveloperDataIdField::timestamp_field(),
            Self::MagnetometerData => MagnetometerDataField::timestamp_field(),
            Self::BarometerData => BarometerDataField::timestamp_field(),
            Self::OneDSensorCalibration => OneDSensorCalibrationField::timestamp_field(),
            Self::MonitoringHrData => MonitoringHrDataField::timestamp_field(),
            Self::TimeInZone => TimeInZoneField::timestamp_field(),
            Self::Set => SetField::timestamp_field(),
            Self::StressLevel => StressLevelField::timestamp_field(),
            Self::MaxMetData => MaxMetDataField::timestamp_field(),
            Self::DiveSettings => DiveSettingsField::timestamp_field(),
            Self::DiveGas => DiveGasField::timestamp_field(),
            Self::DiveAlarm => DiveAlarmField::timestamp_field(),
            Self::ExerciseTitle => ExerciseTitleField::timestamp_field(),
            Self::DiveSummary => DiveSummaryField::timestamp_field(),
            Self::Spo2Data => Spo2DataField::timestamp_field(),
            Self::SleepLevel => SleepLevelField::timestamp_field(),
            Self::Jump => JumpField::timestamp_field(),
            Self::AadAccelFeatures => AadAccelFeaturesField::timestamp_field(),
            Self::BeatIntervals => BeatIntervalsField::timestamp_field(),
            Self::RespirationRate => RespirationRateField::timestamp_field(),
            Self::HsaAccelerometerData => HsaAccelerometerDataField::timestamp_field(),
            Self::HsaStepData => HsaStepDataField::timestamp_field(),
            Self::HsaSpo2Data => HsaSpo2DataField::timestamp_field(),
            Self::HsaStressData => HsaStressDataField::timestamp_field(),
            Self::HsaRespirationData => HsaRespirationDataField::timestamp_field(),
            Self::HsaHeartRateData => HsaHeartRateDataField::timestamp_field(),
            Self::Split => SplitField::timestamp_field(),
            Self::SplitSummary => SplitSummaryField::timestamp_field(),
            Self::HsaBodyBatteryData => HsaBodyBatteryDataField::timestamp_field(),
            Self::HsaEvent => HsaEventField::timestamp_field(),
            Self::ClimbPro => ClimbProField::timestamp_field(),
            Self::TankUpdate => TankUpdateField::timestamp_field(),
            Self::TankSummary => TankSummaryField::timestamp_field(),
            Self::SleepAssessment => SleepAssessmentField::timestamp_field(),
            Self::HrvStatusSummary => HrvStatusSummaryField::timestamp_field(),
            Self::HrvValue => HrvValueField::timestamp_field(),
            Self::RawBbi => RawBbiField::timestamp_field(),
            Self::DeviceAuxBatteryInfo => DeviceAuxBatteryInfoField::timestamp_field(),
            Self::HsaGyroscopeData => HsaGyroscopeDataField::timestamp_field(),
            Self::ChronoShotSession => ChronoShotSessionField::timestamp_field(),
            Self::ChronoShotData => ChronoShotDataField::timestamp_field(),
            Self::HsaConfigurationData => HsaConfigurationDataField::timestamp_field(),
            Self::DiveApneaAlarm => DiveApneaAlarmField::timestamp_field(),
            Self::SkinTempOvernight => SkinTempOvernightField::timestamp_field(),
            Self::HsaWristTemperatureData => HsaWristTemperatureDataField::timestamp_field(),
            _ => None,
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum FileFlags {
    Read,
    Write,
    Erase,
    UnknownVariant(u8),
}
impl FileFlags {
    pub fn from(content: u8) -> FileFlags {
        match content {
            2 => FileFlags::Read,
            4 => FileFlags::Write,
            8 => FileFlags::Erase,
            val => FileFlags::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::FileFlags(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum MesgCount {
    NumPerFile,
    MaxPerFile,
    MaxPerFileType,
    UnknownVariant(u8),
}
impl MesgCount {
    pub fn from(content: u8) -> MesgCount {
        match content {
            0 => MesgCount::NumPerFile,
            1 => MesgCount::MaxPerFile,
            2 => MesgCount::MaxPerFileType,
            val => MesgCount::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::MesgCount(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct DateTime(u32);

impl DateTime {
    pub fn from(content: u32) -> DateTime {
        Self(content)
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();

        for _ in 0..number_of_bytes / 4 {
            values.push(DataValue::DateTime(reader.next_u32(endianness)?));
        }

        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LocalDateTime(u32);

impl LocalDateTime {
    pub fn from(content: u32) -> LocalDateTime {
        Self(content)
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();

        for _ in 0..number_of_bytes / 4 {
            values.push(DataValue::DateTime(reader.next_u32(endianness)?));
        }

        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum MessageIndex {
    Selected,
    Reserved,
    Mask,
    UnknownVariant(u16),
}
impl MessageIndex {
    pub fn from(content: u16) -> MessageIndex {
        match content {
            32768 => MessageIndex::Selected,
            28672 => MessageIndex::Reserved,
            4095 => MessageIndex::Mask,
            val => MessageIndex::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::MessageIndex(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DeviceIndex {
    Creator,
    UnknownVariant(u8),
}
impl DeviceIndex {
    pub fn from(content: u8) -> DeviceIndex {
        match content {
            0 => DeviceIndex::Creator,
            val => DeviceIndex::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DeviceIndex(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Gender {
    Female,
    Male,
    UnknownVariant(u8),
}
impl Gender {
    pub fn from(content: u8) -> Gender {
        match content {
            0 => Gender::Female,
            1 => Gender::Male,
            val => Gender::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Gender(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Language {
    English,
    French,
    Italian,
    German,
    Spanish,
    Croatian,
    Czech,
    Danish,
    Dutch,
    Finnish,
    Greek,
    Hungarian,
    Norwegian,
    Polish,
    Portuguese,
    Slovakian,
    Slovenian,
    Swedish,
    Russian,
    Turkish,
    Latvian,
    Ukrainian,
    Arabic,
    Farsi,
    Bulgarian,
    Romanian,
    Chinese,
    Japanese,
    Korean,
    Taiwanese,
    Thai,
    Hebrew,
    BrazilianPortuguese,
    Indonesian,
    Malaysian,
    Vietnamese,
    Burmese,
    Mongolian,
    Custom,
    UnknownVariant(u8),
}
impl Language {
    pub fn from(content: u8) -> Language {
        match content {
            0 => Language::English,
            1 => Language::French,
            2 => Language::Italian,
            3 => Language::German,
            4 => Language::Spanish,
            5 => Language::Croatian,
            6 => Language::Czech,
            7 => Language::Danish,
            8 => Language::Dutch,
            9 => Language::Finnish,
            10 => Language::Greek,
            11 => Language::Hungarian,
            12 => Language::Norwegian,
            13 => Language::Polish,
            14 => Language::Portuguese,
            15 => Language::Slovakian,
            16 => Language::Slovenian,
            17 => Language::Swedish,
            18 => Language::Russian,
            19 => Language::Turkish,
            20 => Language::Latvian,
            21 => Language::Ukrainian,
            22 => Language::Arabic,
            23 => Language::Farsi,
            24 => Language::Bulgarian,
            25 => Language::Romanian,
            26 => Language::Chinese,
            27 => Language::Japanese,
            28 => Language::Korean,
            29 => Language::Taiwanese,
            30 => Language::Thai,
            31 => Language::Hebrew,
            32 => Language::BrazilianPortuguese,
            33 => Language::Indonesian,
            34 => Language::Malaysian,
            35 => Language::Vietnamese,
            36 => Language::Burmese,
            37 => Language::Mongolian,
            254 => Language::Custom,
            val => Language::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Language(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DisplayMeasure {
    Metric,
    Statute,
    Nautical,
    UnknownVariant(u8),
}
impl DisplayMeasure {
    pub fn from(content: u8) -> DisplayMeasure {
        match content {
            0 => DisplayMeasure::Metric,
            1 => DisplayMeasure::Statute,
            2 => DisplayMeasure::Nautical,
            val => DisplayMeasure::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DisplayMeasure(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DisplayHeart {
    Bpm,
    Max,
    Reserve,
    UnknownVariant(u8),
}
impl DisplayHeart {
    pub fn from(content: u8) -> DisplayHeart {
        match content {
            0 => DisplayHeart::Bpm,
            1 => DisplayHeart::Max,
            2 => DisplayHeart::Reserve,
            val => DisplayHeart::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DisplayHeart(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DisplayPower {
    Watts,
    PercentFtp,
    UnknownVariant(u8),
}
impl DisplayPower {
    pub fn from(content: u8) -> DisplayPower {
        match content {
            0 => DisplayPower::Watts,
            1 => DisplayPower::PercentFtp,
            val => DisplayPower::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DisplayPower(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DisplayPosition {
    Degree,
    DegreeMinute,
    DegreeMinuteSecond,
    AustrianGrid,
    BritishGrid,
    DutchGrid,
    HungarianGrid,
    FinnishGrid,
    GermanGrid,
    IcelandicGrid,
    IndonesianEquatorial,
    IndonesianIrian,
    IndonesianSouthern,
    IndiaZone0,
    IndiaZoneIA,
    IndiaZoneIB,
    IndiaZoneIIA,
    IndiaZoneIIB,
    IndiaZoneIIIA,
    IndiaZoneIIIB,
    IndiaZoneIVA,
    IndiaZoneIVB,
    IrishTransverse,
    IrishGrid,
    Loran,
    MaidenheadGrid,
    MgrsGrid,
    NewZealandGrid,
    NewZealandTransverse,
    QatarGrid,
    ModifiedSwedishGrid,
    SwedishGrid,
    SouthAfricanGrid,
    SwissGrid,
    TaiwanGrid,
    UnitedStatesGrid,
    UtmUpsGrid,
    WestMalayan,
    BorneoRso,
    EstonianGrid,
    LatvianGrid,
    SwedishRef99Grid,
    UnknownVariant(u8),
}
impl DisplayPosition {
    pub fn from(content: u8) -> DisplayPosition {
        match content {
            0 => DisplayPosition::Degree,
            1 => DisplayPosition::DegreeMinute,
            2 => DisplayPosition::DegreeMinuteSecond,
            3 => DisplayPosition::AustrianGrid,
            4 => DisplayPosition::BritishGrid,
            5 => DisplayPosition::DutchGrid,
            6 => DisplayPosition::HungarianGrid,
            7 => DisplayPosition::FinnishGrid,
            8 => DisplayPosition::GermanGrid,
            9 => DisplayPosition::IcelandicGrid,
            10 => DisplayPosition::IndonesianEquatorial,
            11 => DisplayPosition::IndonesianIrian,
            12 => DisplayPosition::IndonesianSouthern,
            13 => DisplayPosition::IndiaZone0,
            14 => DisplayPosition::IndiaZoneIA,
            15 => DisplayPosition::IndiaZoneIB,
            16 => DisplayPosition::IndiaZoneIIA,
            17 => DisplayPosition::IndiaZoneIIB,
            18 => DisplayPosition::IndiaZoneIIIA,
            19 => DisplayPosition::IndiaZoneIIIB,
            20 => DisplayPosition::IndiaZoneIVA,
            21 => DisplayPosition::IndiaZoneIVB,
            22 => DisplayPosition::IrishTransverse,
            23 => DisplayPosition::IrishGrid,
            24 => DisplayPosition::Loran,
            25 => DisplayPosition::MaidenheadGrid,
            26 => DisplayPosition::MgrsGrid,
            27 => DisplayPosition::NewZealandGrid,
            28 => DisplayPosition::NewZealandTransverse,
            29 => DisplayPosition::QatarGrid,
            30 => DisplayPosition::ModifiedSwedishGrid,
            31 => DisplayPosition::SwedishGrid,
            32 => DisplayPosition::SouthAfricanGrid,
            33 => DisplayPosition::SwissGrid,
            34 => DisplayPosition::TaiwanGrid,
            35 => DisplayPosition::UnitedStatesGrid,
            36 => DisplayPosition::UtmUpsGrid,
            37 => DisplayPosition::WestMalayan,
            38 => DisplayPosition::BorneoRso,
            39 => DisplayPosition::EstonianGrid,
            40 => DisplayPosition::LatvianGrid,
            41 => DisplayPosition::SwedishRef99Grid,
            val => DisplayPosition::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DisplayPosition(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Switch {
    Off,
    On,
    Auto,
    UnknownVariant(u8),
}
impl Switch {
    pub fn from(content: u8) -> Switch {
        match content {
            0 => Switch::Off,
            1 => Switch::On,
            2 => Switch::Auto,
            val => Switch::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Switch(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Sport {
    Generic,
    Running,
    Cycling,
    Transition,
    FitnessEquipment,
    Swimming,
    Basketball,
    Soccer,
    Tennis,
    AmericanFootball,
    Training,
    Walking,
    CrossCountrySkiing,
    AlpineSkiing,
    Snowboarding,
    Rowing,
    Mountaineering,
    Hiking,
    Multisport,
    Paddling,
    Flying,
    EBiking,
    Motorcycling,
    Boating,
    Driving,
    Golf,
    HangGliding,
    HorsebackRiding,
    Hunting,
    Fishing,
    InlineSkating,
    RockClimbing,
    Sailing,
    IceSkating,
    SkyDiving,
    Snowshoeing,
    Snowmobiling,
    StandUpPaddleboarding,
    Surfing,
    Wakeboarding,
    WaterSkiing,
    Kayaking,
    Rafting,
    Windsurfing,
    Kitesurfing,
    Tactical,
    Jumpmaster,
    Boxing,
    FloorClimbing,
    Baseball,
    Diving,
    Hiit,
    Racket,
    WheelchairPushWalk,
    WheelchairPushRun,
    Meditation,
    DiscGolf,
    Cricket,
    Rugby,
    Hockey,
    Lacrosse,
    Volleyball,
    WaterTubing,
    Wakesurfing,
    MixedMartialArts,
    Snorkeling,
    Dance,
    JumpRope,
    All,
    UnknownVariant(u8),
}
impl Sport {
    pub fn from(content: u8) -> Sport {
        match content {
            0 => Sport::Generic,
            1 => Sport::Running,
            2 => Sport::Cycling,
            3 => Sport::Transition,
            4 => Sport::FitnessEquipment,
            5 => Sport::Swimming,
            6 => Sport::Basketball,
            7 => Sport::Soccer,
            8 => Sport::Tennis,
            9 => Sport::AmericanFootball,
            10 => Sport::Training,
            11 => Sport::Walking,
            12 => Sport::CrossCountrySkiing,
            13 => Sport::AlpineSkiing,
            14 => Sport::Snowboarding,
            15 => Sport::Rowing,
            16 => Sport::Mountaineering,
            17 => Sport::Hiking,
            18 => Sport::Multisport,
            19 => Sport::Paddling,
            20 => Sport::Flying,
            21 => Sport::EBiking,
            22 => Sport::Motorcycling,
            23 => Sport::Boating,
            24 => Sport::Driving,
            25 => Sport::Golf,
            26 => Sport::HangGliding,
            27 => Sport::HorsebackRiding,
            28 => Sport::Hunting,
            29 => Sport::Fishing,
            30 => Sport::InlineSkating,
            31 => Sport::RockClimbing,
            32 => Sport::Sailing,
            33 => Sport::IceSkating,
            34 => Sport::SkyDiving,
            35 => Sport::Snowshoeing,
            36 => Sport::Snowmobiling,
            37 => Sport::StandUpPaddleboarding,
            38 => Sport::Surfing,
            39 => Sport::Wakeboarding,
            40 => Sport::WaterSkiing,
            41 => Sport::Kayaking,
            42 => Sport::Rafting,
            43 => Sport::Windsurfing,
            44 => Sport::Kitesurfing,
            45 => Sport::Tactical,
            46 => Sport::Jumpmaster,
            47 => Sport::Boxing,
            48 => Sport::FloorClimbing,
            49 => Sport::Baseball,
            53 => Sport::Diving,
            62 => Sport::Hiit,
            64 => Sport::Racket,
            65 => Sport::WheelchairPushWalk,
            66 => Sport::WheelchairPushRun,
            67 => Sport::Meditation,
            69 => Sport::DiscGolf,
            71 => Sport::Cricket,
            72 => Sport::Rugby,
            73 => Sport::Hockey,
            74 => Sport::Lacrosse,
            75 => Sport::Volleyball,
            76 => Sport::WaterTubing,
            77 => Sport::Wakesurfing,
            80 => Sport::MixedMartialArts,
            82 => Sport::Snorkeling,
            83 => Sport::Dance,
            84 => Sport::JumpRope,
            254 => Sport::All,
            val => Sport::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Sport(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SportBits0 {
    Generic,
    Running,
    Cycling,
    Transition,
    FitnessEquipment,
    Swimming,
    Basketball,
    Soccer,
    UnknownVariant(u8),
}
impl SportBits0 {
    pub fn from(content: u8) -> SportBits0 {
        match content {
            1 => SportBits0::Generic,
            2 => SportBits0::Running,
            4 => SportBits0::Cycling,
            8 => SportBits0::Transition,
            16 => SportBits0::FitnessEquipment,
            32 => SportBits0::Swimming,
            64 => SportBits0::Basketball,
            128 => SportBits0::Soccer,
            val => SportBits0::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SportBits0(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SubSport {
    Generic,
    Treadmill,
    Street,
    Trail,
    Track,
    Spin,
    IndoorCycling,
    Road,
    Mountain,
    Downhill,
    Recumbent,
    Cyclocross,
    HandCycling,
    TrackCycling,
    IndoorRowing,
    Elliptical,
    StairClimbing,
    LapSwimming,
    OpenWater,
    FlexibilityTraining,
    StrengthTraining,
    WarmUp,
    Match,
    Exercise,
    Challenge,
    IndoorSkiing,
    CardioTraining,
    IndoorWalking,
    EBikeFitness,
    Bmx,
    CasualWalking,
    SpeedWalking,
    BikeToRunTransition,
    RunToBikeTransition,
    SwimToBikeTransition,
    Atv,
    Motocross,
    Backcountry,
    Resort,
    RcDrone,
    Wingsuit,
    Whitewater,
    SkateSkiing,
    Yoga,
    Pilates,
    IndoorRunning,
    GravelCycling,
    EBikeMountain,
    Commuting,
    MixedSurface,
    Navigate,
    TrackMe,
    Map,
    SingleGasDiving,
    MultiGasDiving,
    GaugeDiving,
    ApneaDiving,
    ApneaHunting,
    VirtualActivity,
    Obstacle,
    Breathing,
    SailRace,
    Ultra,
    IndoorClimbing,
    Bouldering,
    Hiit,
    Amrap,
    Emom,
    Tabata,
    Pickleball,
    Padel,
    IndoorWheelchairWalk,
    IndoorWheelchairRun,
    IndoorHandCycling,
    Squash,
    Badminton,
    Racquetball,
    TableTennis,
    FlyCanopy,
    FlyParaglide,
    FlyParamotor,
    FlyPressurized,
    FlyNavigate,
    FlyTimer,
    FlyAltimeter,
    FlyWx,
    FlyVfr,
    FlyIfr,
    All,
    UnknownVariant(u8),
}
impl SubSport {
    pub fn from(content: u8) -> SubSport {
        match content {
            0 => SubSport::Generic,
            1 => SubSport::Treadmill,
            2 => SubSport::Street,
            3 => SubSport::Trail,
            4 => SubSport::Track,
            5 => SubSport::Spin,
            6 => SubSport::IndoorCycling,
            7 => SubSport::Road,
            8 => SubSport::Mountain,
            9 => SubSport::Downhill,
            10 => SubSport::Recumbent,
            11 => SubSport::Cyclocross,
            12 => SubSport::HandCycling,
            13 => SubSport::TrackCycling,
            14 => SubSport::IndoorRowing,
            15 => SubSport::Elliptical,
            16 => SubSport::StairClimbing,
            17 => SubSport::LapSwimming,
            18 => SubSport::OpenWater,
            19 => SubSport::FlexibilityTraining,
            20 => SubSport::StrengthTraining,
            21 => SubSport::WarmUp,
            22 => SubSport::Match,
            23 => SubSport::Exercise,
            24 => SubSport::Challenge,
            25 => SubSport::IndoorSkiing,
            26 => SubSport::CardioTraining,
            27 => SubSport::IndoorWalking,
            28 => SubSport::EBikeFitness,
            29 => SubSport::Bmx,
            30 => SubSport::CasualWalking,
            31 => SubSport::SpeedWalking,
            32 => SubSport::BikeToRunTransition,
            33 => SubSport::RunToBikeTransition,
            34 => SubSport::SwimToBikeTransition,
            35 => SubSport::Atv,
            36 => SubSport::Motocross,
            37 => SubSport::Backcountry,
            38 => SubSport::Resort,
            39 => SubSport::RcDrone,
            40 => SubSport::Wingsuit,
            41 => SubSport::Whitewater,
            42 => SubSport::SkateSkiing,
            43 => SubSport::Yoga,
            44 => SubSport::Pilates,
            45 => SubSport::IndoorRunning,
            46 => SubSport::GravelCycling,
            47 => SubSport::EBikeMountain,
            48 => SubSport::Commuting,
            49 => SubSport::MixedSurface,
            50 => SubSport::Navigate,
            51 => SubSport::TrackMe,
            52 => SubSport::Map,
            53 => SubSport::SingleGasDiving,
            54 => SubSport::MultiGasDiving,
            55 => SubSport::GaugeDiving,
            56 => SubSport::ApneaDiving,
            57 => SubSport::ApneaHunting,
            58 => SubSport::VirtualActivity,
            59 => SubSport::Obstacle,
            62 => SubSport::Breathing,
            65 => SubSport::SailRace,
            67 => SubSport::Ultra,
            68 => SubSport::IndoorClimbing,
            69 => SubSport::Bouldering,
            70 => SubSport::Hiit,
            73 => SubSport::Amrap,
            74 => SubSport::Emom,
            75 => SubSport::Tabata,
            84 => SubSport::Pickleball,
            85 => SubSport::Padel,
            86 => SubSport::IndoorWheelchairWalk,
            87 => SubSport::IndoorWheelchairRun,
            88 => SubSport::IndoorHandCycling,
            94 => SubSport::Squash,
            95 => SubSport::Badminton,
            96 => SubSport::Racquetball,
            97 => SubSport::TableTennis,
            110 => SubSport::FlyCanopy,
            111 => SubSport::FlyParaglide,
            112 => SubSport::FlyParamotor,
            113 => SubSport::FlyPressurized,
            114 => SubSport::FlyNavigate,
            115 => SubSport::FlyTimer,
            116 => SubSport::FlyAltimeter,
            117 => SubSport::FlyWx,
            118 => SubSport::FlyVfr,
            119 => SubSport::FlyIfr,
            254 => SubSport::All,
            val => SubSport::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SubSport(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SportEvent {
    Uncategorized,
    Geocaching,
    Fitness,
    Recreation,
    Race,
    SpecialEvent,
    Training,
    Transportation,
    Touring,
    UnknownVariant(u8),
}
impl SportEvent {
    pub fn from(content: u8) -> SportEvent {
        match content {
            0 => SportEvent::Uncategorized,
            1 => SportEvent::Geocaching,
            2 => SportEvent::Fitness,
            3 => SportEvent::Recreation,
            4 => SportEvent::Race,
            5 => SportEvent::SpecialEvent,
            6 => SportEvent::Training,
            7 => SportEvent::Transportation,
            8 => SportEvent::Touring,
            val => SportEvent::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SportEvent(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Activity {
    Manual,
    AutoMultiSport,
    UnknownVariant(u8),
}
impl Activity {
    pub fn from(content: u8) -> Activity {
        match content {
            0 => Activity::Manual,
            1 => Activity::AutoMultiSport,
            val => Activity::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Activity(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Intensity {
    Active,
    Rest,
    Warmup,
    Cooldown,
    Recovery,
    Interval,
    Other,
    UnknownVariant(u8),
}
impl Intensity {
    pub fn from(content: u8) -> Intensity {
        match content {
            0 => Intensity::Active,
            1 => Intensity::Rest,
            2 => Intensity::Warmup,
            3 => Intensity::Cooldown,
            4 => Intensity::Recovery,
            5 => Intensity::Interval,
            6 => Intensity::Other,
            val => Intensity::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Intensity(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SessionTrigger {
    ActivityEnd,
    Manual,
    AutoMultiSport,
    FitnessEquipment,
    UnknownVariant(u8),
}
impl SessionTrigger {
    pub fn from(content: u8) -> SessionTrigger {
        match content {
            0 => SessionTrigger::ActivityEnd,
            1 => SessionTrigger::Manual,
            2 => SessionTrigger::AutoMultiSport,
            3 => SessionTrigger::FitnessEquipment,
            val => SessionTrigger::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SessionTrigger(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum LapTrigger {
    Manual,
    Time,
    Distance,
    PositionStart,
    PositionLap,
    PositionWaypoint,
    PositionMarked,
    SessionEnd,
    FitnessEquipment,
    UnknownVariant(u8),
}
impl LapTrigger {
    pub fn from(content: u8) -> LapTrigger {
        match content {
            0 => LapTrigger::Manual,
            1 => LapTrigger::Time,
            2 => LapTrigger::Distance,
            3 => LapTrigger::PositionStart,
            4 => LapTrigger::PositionLap,
            5 => LapTrigger::PositionWaypoint,
            6 => LapTrigger::PositionMarked,
            7 => LapTrigger::SessionEnd,
            8 => LapTrigger::FitnessEquipment,
            val => LapTrigger::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::LapTrigger(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum TimeMode {
    Hour12,
    Hour24,
    Military,
    Hour12WithSeconds,
    Hour24WithSeconds,
    Utc,
    UnknownVariant(u8),
}
impl TimeMode {
    pub fn from(content: u8) -> TimeMode {
        match content {
            0 => TimeMode::Hour12,
            1 => TimeMode::Hour24,
            2 => TimeMode::Military,
            3 => TimeMode::Hour12WithSeconds,
            4 => TimeMode::Hour24WithSeconds,
            5 => TimeMode::Utc,
            val => TimeMode::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::TimeMode(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum BacklightMode {
    Off,
    Manual,
    KeyAndMessages,
    AutoBrightness,
    SmartNotifications,
    KeyAndMessagesNight,
    KeyAndMessagesAndSmartNotifications,
    UnknownVariant(u8),
}
impl BacklightMode {
    pub fn from(content: u8) -> BacklightMode {
        match content {
            0 => BacklightMode::Off,
            1 => BacklightMode::Manual,
            2 => BacklightMode::KeyAndMessages,
            3 => BacklightMode::AutoBrightness,
            4 => BacklightMode::SmartNotifications,
            5 => BacklightMode::KeyAndMessagesNight,
            6 => BacklightMode::KeyAndMessagesAndSmartNotifications,
            val => BacklightMode::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::BacklightMode(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DateMode {
    DayMonth,
    MonthDay,
    UnknownVariant(u8),
}
impl DateMode {
    pub fn from(content: u8) -> DateMode {
        match content {
            0 => DateMode::DayMonth,
            1 => DateMode::MonthDay,
            val => DateMode::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DateMode(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum BacklightTimeout {
    Infinite,
    UnknownVariant(u8),
}
impl BacklightTimeout {
    pub fn from(content: u8) -> BacklightTimeout {
        match content {
            0 => BacklightTimeout::Infinite,
            val => BacklightTimeout::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::BacklightTimeout(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Event {
    Timer,
    Workout,
    WorkoutStep,
    PowerDown,
    PowerUp,
    OffCourse,
    Session,
    Lap,
    CoursePoint,
    Battery,
    VirtualPartnerPace,
    HrHighAlert,
    HrLowAlert,
    SpeedHighAlert,
    SpeedLowAlert,
    CadHighAlert,
    CadLowAlert,
    PowerHighAlert,
    PowerLowAlert,
    RecoveryHr,
    BatteryLow,
    TimeDurationAlert,
    DistanceDurationAlert,
    CalorieDurationAlert,
    Activity,
    FitnessEquipment,
    Length,
    UserMarker,
    SportPoint,
    Calibration,
    FrontGearChange,
    RearGearChange,
    RiderPositionChange,
    ElevHighAlert,
    ElevLowAlert,
    CommTimeout,
    AutoActivityDetect,
    DiveAlert,
    DiveGasSwitched,
    TankPressureReserve,
    TankPressureCritical,
    TankLost,
    RadarThreatAlert,
    TankBatteryLow,
    TankPodConnected,
    TankPodDisconnected,
    UnknownVariant(u8),
}
impl Event {
    pub fn from(content: u8) -> Event {
        match content {
            0 => Event::Timer,
            3 => Event::Workout,
            4 => Event::WorkoutStep,
            5 => Event::PowerDown,
            6 => Event::PowerUp,
            7 => Event::OffCourse,
            8 => Event::Session,
            9 => Event::Lap,
            10 => Event::CoursePoint,
            11 => Event::Battery,
            12 => Event::VirtualPartnerPace,
            13 => Event::HrHighAlert,
            14 => Event::HrLowAlert,
            15 => Event::SpeedHighAlert,
            16 => Event::SpeedLowAlert,
            17 => Event::CadHighAlert,
            18 => Event::CadLowAlert,
            19 => Event::PowerHighAlert,
            20 => Event::PowerLowAlert,
            21 => Event::RecoveryHr,
            22 => Event::BatteryLow,
            23 => Event::TimeDurationAlert,
            24 => Event::DistanceDurationAlert,
            25 => Event::CalorieDurationAlert,
            26 => Event::Activity,
            27 => Event::FitnessEquipment,
            28 => Event::Length,
            32 => Event::UserMarker,
            33 => Event::SportPoint,
            36 => Event::Calibration,
            42 => Event::FrontGearChange,
            43 => Event::RearGearChange,
            44 => Event::RiderPositionChange,
            45 => Event::ElevHighAlert,
            46 => Event::ElevLowAlert,
            47 => Event::CommTimeout,
            54 => Event::AutoActivityDetect,
            56 => Event::DiveAlert,
            57 => Event::DiveGasSwitched,
            71 => Event::TankPressureReserve,
            72 => Event::TankPressureCritical,
            73 => Event::TankLost,
            75 => Event::RadarThreatAlert,
            76 => Event::TankBatteryLow,
            81 => Event::TankPodConnected,
            82 => Event::TankPodDisconnected,
            val => Event::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Event(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum EventType {
    Start,
    Stop,
    ConsecutiveDepreciated,
    Marker,
    StopAll,
    BeginDepreciated,
    EndDepreciated,
    EndAllDepreciated,
    StopDisable,
    StopDisableAll,
    UnknownVariant(u8),
}
impl EventType {
    pub fn from(content: u8) -> EventType {
        match content {
            0 => EventType::Start,
            1 => EventType::Stop,
            2 => EventType::ConsecutiveDepreciated,
            3 => EventType::Marker,
            4 => EventType::StopAll,
            5 => EventType::BeginDepreciated,
            6 => EventType::EndDepreciated,
            7 => EventType::EndAllDepreciated,
            8 => EventType::StopDisable,
            9 => EventType::StopDisableAll,
            val => EventType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::EventType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Tone {
    Off,
    Tone,
    Vibrate,
    ToneAndVibrate,
    UnknownVariant(u8),
}
impl Tone {
    pub fn from(content: u8) -> Tone {
        match content {
            0 => Tone::Off,
            1 => Tone::Tone,
            2 => Tone::Vibrate,
            3 => Tone::ToneAndVibrate,
            val => Tone::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Tone(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ActivityClass {
    Level,
    LevelMax,
    Athlete,
    UnknownVariant(u8),
}
impl ActivityClass {
    pub fn from(content: u8) -> ActivityClass {
        match content {
            127 => ActivityClass::Level,
            100 => ActivityClass::LevelMax,
            128 => ActivityClass::Athlete,
            val => ActivityClass::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ActivityClass(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum HrZoneCalc {
    Custom,
    PercentMaxHr,
    PercentHrr,
    PercentLthr,
    UnknownVariant(u8),
}
impl HrZoneCalc {
    pub fn from(content: u8) -> HrZoneCalc {
        match content {
            0 => HrZoneCalc::Custom,
            1 => HrZoneCalc::PercentMaxHr,
            2 => HrZoneCalc::PercentHrr,
            3 => HrZoneCalc::PercentLthr,
            val => HrZoneCalc::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::HrZoneCalc(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum PwrZoneCalc {
    Custom,
    PercentFtp,
    UnknownVariant(u8),
}
impl PwrZoneCalc {
    pub fn from(content: u8) -> PwrZoneCalc {
        match content {
            0 => PwrZoneCalc::Custom,
            1 => PwrZoneCalc::PercentFtp,
            val => PwrZoneCalc::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::PwrZoneCalc(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WktStepDuration {
    Time,
    Distance,
    HrLessThan,
    HrGreaterThan,
    Calories,
    Open,
    RepeatUntilStepsCmplt,
    RepeatUntilTime,
    RepeatUntilDistance,
    RepeatUntilCalories,
    RepeatUntilHrLessThan,
    RepeatUntilHrGreaterThan,
    RepeatUntilPowerLessThan,
    RepeatUntilPowerGreaterThan,
    PowerLessThan,
    PowerGreaterThan,
    TrainingPeaksTss,
    RepeatUntilPowerLastLapLessThan,
    RepeatUntilMaxPowerLastLapLessThan,
    Power3sLessThan,
    Power10sLessThan,
    Power30sLessThan,
    Power3sGreaterThan,
    Power10sGreaterThan,
    Power30sGreaterThan,
    PowerLapLessThan,
    PowerLapGreaterThan,
    RepeatUntilTrainingPeaksTss,
    RepetitionTime,
    Reps,
    TimeOnly,
    UnknownVariant(u8),
}
impl WktStepDuration {
    pub fn from(content: u8) -> WktStepDuration {
        match content {
            0 => WktStepDuration::Time,
            1 => WktStepDuration::Distance,
            2 => WktStepDuration::HrLessThan,
            3 => WktStepDuration::HrGreaterThan,
            4 => WktStepDuration::Calories,
            5 => WktStepDuration::Open,
            6 => WktStepDuration::RepeatUntilStepsCmplt,
            7 => WktStepDuration::RepeatUntilTime,
            8 => WktStepDuration::RepeatUntilDistance,
            9 => WktStepDuration::RepeatUntilCalories,
            10 => WktStepDuration::RepeatUntilHrLessThan,
            11 => WktStepDuration::RepeatUntilHrGreaterThan,
            12 => WktStepDuration::RepeatUntilPowerLessThan,
            13 => WktStepDuration::RepeatUntilPowerGreaterThan,
            14 => WktStepDuration::PowerLessThan,
            15 => WktStepDuration::PowerGreaterThan,
            16 => WktStepDuration::TrainingPeaksTss,
            17 => WktStepDuration::RepeatUntilPowerLastLapLessThan,
            18 => WktStepDuration::RepeatUntilMaxPowerLastLapLessThan,
            19 => WktStepDuration::Power3sLessThan,
            20 => WktStepDuration::Power10sLessThan,
            21 => WktStepDuration::Power30sLessThan,
            22 => WktStepDuration::Power3sGreaterThan,
            23 => WktStepDuration::Power10sGreaterThan,
            24 => WktStepDuration::Power30sGreaterThan,
            25 => WktStepDuration::PowerLapLessThan,
            26 => WktStepDuration::PowerLapGreaterThan,
            27 => WktStepDuration::RepeatUntilTrainingPeaksTss,
            28 => WktStepDuration::RepetitionTime,
            29 => WktStepDuration::Reps,
            31 => WktStepDuration::TimeOnly,
            val => WktStepDuration::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WktStepDuration(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WktStepTarget {
    Speed,
    HeartRate,
    Open,
    Cadence,
    Power,
    Grade,
    Resistance,
    Power3s,
    Power10s,
    Power30s,
    PowerLap,
    SwimStroke,
    SpeedLap,
    HeartRateLap,
    UnknownVariant(u8),
}
impl WktStepTarget {
    pub fn from(content: u8) -> WktStepTarget {
        match content {
            0 => WktStepTarget::Speed,
            1 => WktStepTarget::HeartRate,
            2 => WktStepTarget::Open,
            3 => WktStepTarget::Cadence,
            4 => WktStepTarget::Power,
            5 => WktStepTarget::Grade,
            6 => WktStepTarget::Resistance,
            7 => WktStepTarget::Power3s,
            8 => WktStepTarget::Power10s,
            9 => WktStepTarget::Power30s,
            10 => WktStepTarget::PowerLap,
            11 => WktStepTarget::SwimStroke,
            12 => WktStepTarget::SpeedLap,
            13 => WktStepTarget::HeartRateLap,
            val => WktStepTarget::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WktStepTarget(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Goal {
    Time,
    Distance,
    Calories,
    Frequency,
    Steps,
    Ascent,
    ActiveMinutes,
    UnknownVariant(u8),
}
impl Goal {
    pub fn from(content: u8) -> Goal {
        match content {
            0 => Goal::Time,
            1 => Goal::Distance,
            2 => Goal::Calories,
            3 => Goal::Frequency,
            4 => Goal::Steps,
            5 => Goal::Ascent,
            6 => Goal::ActiveMinutes,
            val => Goal::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Goal(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum GoalRecurrence {
    Off,
    Daily,
    Weekly,
    Monthly,
    Yearly,
    Custom,
    UnknownVariant(u8),
}
impl GoalRecurrence {
    pub fn from(content: u8) -> GoalRecurrence {
        match content {
            0 => GoalRecurrence::Off,
            1 => GoalRecurrence::Daily,
            2 => GoalRecurrence::Weekly,
            3 => GoalRecurrence::Monthly,
            4 => GoalRecurrence::Yearly,
            5 => GoalRecurrence::Custom,
            val => GoalRecurrence::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::GoalRecurrence(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum GoalSource {
    Auto,
    Community,
    User,
    UnknownVariant(u8),
}
impl GoalSource {
    pub fn from(content: u8) -> GoalSource {
        match content {
            0 => GoalSource::Auto,
            1 => GoalSource::Community,
            2 => GoalSource::User,
            val => GoalSource::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::GoalSource(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Schedule {
    Workout,
    Course,
    UnknownVariant(u8),
}
impl Schedule {
    pub fn from(content: u8) -> Schedule {
        match content {
            0 => Schedule::Workout,
            1 => Schedule::Course,
            val => Schedule::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Schedule(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum CoursePoint {
    Generic,
    Summit,
    Valley,
    Water,
    Food,
    Danger,
    Left,
    Right,
    Straight,
    FirstAid,
    FourthCategory,
    ThirdCategory,
    SecondCategory,
    FirstCategory,
    HorsCategory,
    Sprint,
    LeftFork,
    RightFork,
    MiddleFork,
    SlightLeft,
    SharpLeft,
    SlightRight,
    SharpRight,
    UTurn,
    SegmentStart,
    SegmentEnd,
    Campsite,
    AidStation,
    RestArea,
    GeneralDistance,
    Service,
    EnergyGel,
    SportsDrink,
    MileMarker,
    Checkpoint,
    Shelter,
    MeetingSpot,
    Overlook,
    Toilet,
    Shower,
    Gear,
    SharpCurve,
    SteepIncline,
    Tunnel,
    Bridge,
    Obstacle,
    Crossing,
    Store,
    Transition,
    Navaid,
    Transport,
    Alert,
    Info,
    UnknownVariant(u8),
}
impl CoursePoint {
    pub fn from(content: u8) -> CoursePoint {
        match content {
            0 => CoursePoint::Generic,
            1 => CoursePoint::Summit,
            2 => CoursePoint::Valley,
            3 => CoursePoint::Water,
            4 => CoursePoint::Food,
            5 => CoursePoint::Danger,
            6 => CoursePoint::Left,
            7 => CoursePoint::Right,
            8 => CoursePoint::Straight,
            9 => CoursePoint::FirstAid,
            10 => CoursePoint::FourthCategory,
            11 => CoursePoint::ThirdCategory,
            12 => CoursePoint::SecondCategory,
            13 => CoursePoint::FirstCategory,
            14 => CoursePoint::HorsCategory,
            15 => CoursePoint::Sprint,
            16 => CoursePoint::LeftFork,
            17 => CoursePoint::RightFork,
            18 => CoursePoint::MiddleFork,
            19 => CoursePoint::SlightLeft,
            20 => CoursePoint::SharpLeft,
            21 => CoursePoint::SlightRight,
            22 => CoursePoint::SharpRight,
            23 => CoursePoint::UTurn,
            24 => CoursePoint::SegmentStart,
            25 => CoursePoint::SegmentEnd,
            27 => CoursePoint::Campsite,
            28 => CoursePoint::AidStation,
            29 => CoursePoint::RestArea,
            30 => CoursePoint::GeneralDistance,
            31 => CoursePoint::Service,
            32 => CoursePoint::EnergyGel,
            33 => CoursePoint::SportsDrink,
            34 => CoursePoint::MileMarker,
            35 => CoursePoint::Checkpoint,
            36 => CoursePoint::Shelter,
            37 => CoursePoint::MeetingSpot,
            38 => CoursePoint::Overlook,
            39 => CoursePoint::Toilet,
            40 => CoursePoint::Shower,
            41 => CoursePoint::Gear,
            42 => CoursePoint::SharpCurve,
            43 => CoursePoint::SteepIncline,
            44 => CoursePoint::Tunnel,
            45 => CoursePoint::Bridge,
            46 => CoursePoint::Obstacle,
            47 => CoursePoint::Crossing,
            48 => CoursePoint::Store,
            49 => CoursePoint::Transition,
            50 => CoursePoint::Navaid,
            51 => CoursePoint::Transport,
            52 => CoursePoint::Alert,
            53 => CoursePoint::Info,
            val => CoursePoint::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::CoursePoint(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Manufacturer {
    Garmin,
    GarminFr405Antfs,
    Zephyr,
    Dayton,
    Idt,
    Srm,
    Quarq,
    Ibike,
    Saris,
    SparkHk,
    Tanita,
    Echowell,
    DynastreamOem,
    Nautilus,
    Dynastream,
    Timex,
    Metrigear,
    Xelic,
    Beurer,
    Cardiosport,
    AAndD,
    Hmm,
    Suunto,
    ThitaElektronik,
    Gpulse,
    CleanMobile,
    PedalBrain,
    Peaksware,
    Saxonar,
    LemondFitness,
    Dexcom,
    WahooFitness,
    OctaneFitness,
    Archinoetics,
    TheHurtBox,
    CitizenSystems,
    Magellan,
    Osynce,
    Holux,
    Concept2,
    Shimano,
    OneGiantLeap,
    AceSensor,
    BrimBrothers,
    Xplova,
    PerceptionDigital,
    Bf1systems,
    Pioneer,
    Spantec,
    Metalogics,
    Iiiis,
    SeikoEpson,
    SeikoEpsonOem,
    IforPowell,
    MaxwellGuider,
    StarTrac,
    Breakaway,
    AlatechTechnologyLtd,
    MioTechnologyEurope,
    Rotor,
    Geonaute,
    IdBike,
    Specialized,
    Wtek,
    PhysicalEnterprises,
    NorthPoleEngineering,
    Bkool,
    Cateye,
    StagesCycling,
    Sigmasport,
    Tomtom,
    Peripedal,
    Wattbike,
    Moxy,
    Ciclosport,
    Powerbahn,
    AcornProjectsAps,
    Lifebeam,
    Bontrager,
    Wellgo,
    Scosche,
    Magura,
    Woodway,
    Elite,
    NielsenKellerman,
    DkCity,
    Tacx,
    DirectionTechnology,
    Magtonic,
    Partcarbon,
    InsideRideTechnologies,
    SoundOfMotion,
    Stryd,
    Icg,
    MiPulse,
    BsxAthletics,
    Look,
    CampagnoloSrl,
    BodyBikeSmart,
    Praxisworks,
    LimitsTechnology,
    TopactionTechnology,
    Cosinuss,
    Fitcare,
    Magene,
    GiantManufacturingCo,
    Tigrasport,
    Salutron,
    Technogym,
    BrytonSensors,
    LatitudeLimited,
    SoaringTechnology,
    Igpsport,
    Thinkrider,
    GopherSport,
    Waterrower,
    Orangetheory,
    Inpeak,
    Kinetic,
    JohnsonHealthTech,
    PolarElectro,
    Seesense,
    NciTechnology,
    Iqsquare,
    Leomo,
    IfitCom,
    CorosByte,
    VersaDesign,
    Chileaf,
    Cycplus,
    GravaaByte,
    Sigeyi,
    Coospo,
    Geoid,
    Bosch,
    Kyto,
    KineticSports,
    DecathlonByte,
    TqSystems,
    TagHeuer,
    KeiserFitness,
    ZwiftByte,
    PorscheEp,
    Blackbird,
    MeilanByte,
    Ezon,
    Laisi,
    Myzone,
    Abawo,
    Bafang,
    LuhongTechnology,
    Development,
    Healthandlife,
    Lezyne,
    ScribeLabs,
    Zwift,
    Watteam,
    Recon,
    FaveroElectronics,
    Dynovelo,
    Strava,
    Precor,
    Bryton,
    Sram,
    Navman,
    Cobi,
    Spivi,
    MioMagellan,
    Evesports,
    SensitivusGauge,
    Podoon,
    LifeTimeFitness,
    FalcoEMotors,
    Minoura,
    Cycliq,
    Luxottica,
    TrainerRoad,
    TheSufferfest,
    Fullspeedahead,
    Virtualtraining,
    Feedbacksports,
    Omata,
    Vdo,
    Magneticdays,
    Hammerhead,
    KineticByKurt,
    Shapelog,
    Dabuziduo,
    Jetblack,
    Coros,
    Virtugo,
    Velosense,
    Cycligentinc,
    Trailforks,
    MahleEbikemotion,
    Nurvv,
    Microprogram,
    Zone5cloud,
    Greenteg,
    YamahaMotors,
    Whoop,
    Gravaa,
    Onelap,
    MonarkExercise,
    Form,
    Decathlon,
    Syncros,
    Heatup,
    Cannondale,
    TrueFitness,
    RGTCycling,
    Vasa,
    RaceRepublic,
    Fazua,
    OrekaTraining,
    Lsec,
    LululemonStudio,
    Shanyue,
    SpinningMda,
    Hilldating,
    AeroSensor,
    Nike,
    Magicshine,
    Ictrainer,
    AbsoluteCycling,
    EoSwimbetter,
    Mywhoosh,
    Ravemen,
    TektroRacingProducts,
    DaradInnovationCorporation,
    Cycloptim,
    Actigraphcorp,
    UnknownVariant(u16),
}
impl Manufacturer {
    pub fn from(content: u16) -> Manufacturer {
        match content {
            1 => Manufacturer::Garmin,
            2 => Manufacturer::GarminFr405Antfs,
            3 => Manufacturer::Zephyr,
            4 => Manufacturer::Dayton,
            5 => Manufacturer::Idt,
            6 => Manufacturer::Srm,
            7 => Manufacturer::Quarq,
            8 => Manufacturer::Ibike,
            9 => Manufacturer::Saris,
            10 => Manufacturer::SparkHk,
            11 => Manufacturer::Tanita,
            12 => Manufacturer::Echowell,
            13 => Manufacturer::DynastreamOem,
            14 => Manufacturer::Nautilus,
            15 => Manufacturer::Dynastream,
            16 => Manufacturer::Timex,
            17 => Manufacturer::Metrigear,
            18 => Manufacturer::Xelic,
            19 => Manufacturer::Beurer,
            20 => Manufacturer::Cardiosport,
            21 => Manufacturer::AAndD,
            22 => Manufacturer::Hmm,
            23 => Manufacturer::Suunto,
            24 => Manufacturer::ThitaElektronik,
            25 => Manufacturer::Gpulse,
            26 => Manufacturer::CleanMobile,
            27 => Manufacturer::PedalBrain,
            28 => Manufacturer::Peaksware,
            29 => Manufacturer::Saxonar,
            30 => Manufacturer::LemondFitness,
            31 => Manufacturer::Dexcom,
            32 => Manufacturer::WahooFitness,
            33 => Manufacturer::OctaneFitness,
            34 => Manufacturer::Archinoetics,
            35 => Manufacturer::TheHurtBox,
            36 => Manufacturer::CitizenSystems,
            37 => Manufacturer::Magellan,
            38 => Manufacturer::Osynce,
            39 => Manufacturer::Holux,
            40 => Manufacturer::Concept2,
            41 => Manufacturer::Shimano,
            42 => Manufacturer::OneGiantLeap,
            43 => Manufacturer::AceSensor,
            44 => Manufacturer::BrimBrothers,
            45 => Manufacturer::Xplova,
            46 => Manufacturer::PerceptionDigital,
            47 => Manufacturer::Bf1systems,
            48 => Manufacturer::Pioneer,
            49 => Manufacturer::Spantec,
            50 => Manufacturer::Metalogics,
            51 => Manufacturer::Iiiis,
            52 => Manufacturer::SeikoEpson,
            53 => Manufacturer::SeikoEpsonOem,
            54 => Manufacturer::IforPowell,
            55 => Manufacturer::MaxwellGuider,
            56 => Manufacturer::StarTrac,
            57 => Manufacturer::Breakaway,
            58 => Manufacturer::AlatechTechnologyLtd,
            59 => Manufacturer::MioTechnologyEurope,
            60 => Manufacturer::Rotor,
            61 => Manufacturer::Geonaute,
            62 => Manufacturer::IdBike,
            63 => Manufacturer::Specialized,
            64 => Manufacturer::Wtek,
            65 => Manufacturer::PhysicalEnterprises,
            66 => Manufacturer::NorthPoleEngineering,
            67 => Manufacturer::Bkool,
            68 => Manufacturer::Cateye,
            69 => Manufacturer::StagesCycling,
            70 => Manufacturer::Sigmasport,
            71 => Manufacturer::Tomtom,
            72 => Manufacturer::Peripedal,
            73 => Manufacturer::Wattbike,
            76 => Manufacturer::Moxy,
            77 => Manufacturer::Ciclosport,
            78 => Manufacturer::Powerbahn,
            79 => Manufacturer::AcornProjectsAps,
            80 => Manufacturer::Lifebeam,
            81 => Manufacturer::Bontrager,
            82 => Manufacturer::Wellgo,
            83 => Manufacturer::Scosche,
            84 => Manufacturer::Magura,
            85 => Manufacturer::Woodway,
            86 => Manufacturer::Elite,
            87 => Manufacturer::NielsenKellerman,
            88 => Manufacturer::DkCity,
            89 => Manufacturer::Tacx,
            90 => Manufacturer::DirectionTechnology,
            91 => Manufacturer::Magtonic,
            92 => Manufacturer::Partcarbon,
            93 => Manufacturer::InsideRideTechnologies,
            94 => Manufacturer::SoundOfMotion,
            95 => Manufacturer::Stryd,
            96 => Manufacturer::Icg,
            97 => Manufacturer::MiPulse,
            98 => Manufacturer::BsxAthletics,
            99 => Manufacturer::Look,
            100 => Manufacturer::CampagnoloSrl,
            101 => Manufacturer::BodyBikeSmart,
            102 => Manufacturer::Praxisworks,
            103 => Manufacturer::LimitsTechnology,
            104 => Manufacturer::TopactionTechnology,
            105 => Manufacturer::Cosinuss,
            106 => Manufacturer::Fitcare,
            107 => Manufacturer::Magene,
            108 => Manufacturer::GiantManufacturingCo,
            109 => Manufacturer::Tigrasport,
            110 => Manufacturer::Salutron,
            111 => Manufacturer::Technogym,
            112 => Manufacturer::BrytonSensors,
            113 => Manufacturer::LatitudeLimited,
            114 => Manufacturer::SoaringTechnology,
            115 => Manufacturer::Igpsport,
            116 => Manufacturer::Thinkrider,
            117 => Manufacturer::GopherSport,
            118 => Manufacturer::Waterrower,
            119 => Manufacturer::Orangetheory,
            120 => Manufacturer::Inpeak,
            121 => Manufacturer::Kinetic,
            122 => Manufacturer::JohnsonHealthTech,
            123 => Manufacturer::PolarElectro,
            124 => Manufacturer::Seesense,
            125 => Manufacturer::NciTechnology,
            126 => Manufacturer::Iqsquare,
            127 => Manufacturer::Leomo,
            128 => Manufacturer::IfitCom,
            129 => Manufacturer::CorosByte,
            130 => Manufacturer::VersaDesign,
            131 => Manufacturer::Chileaf,
            132 => Manufacturer::Cycplus,
            133 => Manufacturer::GravaaByte,
            134 => Manufacturer::Sigeyi,
            135 => Manufacturer::Coospo,
            136 => Manufacturer::Geoid,
            137 => Manufacturer::Bosch,
            138 => Manufacturer::Kyto,
            139 => Manufacturer::KineticSports,
            140 => Manufacturer::DecathlonByte,
            141 => Manufacturer::TqSystems,
            142 => Manufacturer::TagHeuer,
            143 => Manufacturer::KeiserFitness,
            144 => Manufacturer::ZwiftByte,
            145 => Manufacturer::PorscheEp,
            146 => Manufacturer::Blackbird,
            147 => Manufacturer::MeilanByte,
            148 => Manufacturer::Ezon,
            149 => Manufacturer::Laisi,
            150 => Manufacturer::Myzone,
            151 => Manufacturer::Abawo,
            152 => Manufacturer::Bafang,
            153 => Manufacturer::LuhongTechnology,
            255 => Manufacturer::Development,
            257 => Manufacturer::Healthandlife,
            258 => Manufacturer::Lezyne,
            259 => Manufacturer::ScribeLabs,
            260 => Manufacturer::Zwift,
            261 => Manufacturer::Watteam,
            262 => Manufacturer::Recon,
            263 => Manufacturer::FaveroElectronics,
            264 => Manufacturer::Dynovelo,
            265 => Manufacturer::Strava,
            266 => Manufacturer::Precor,
            267 => Manufacturer::Bryton,
            268 => Manufacturer::Sram,
            269 => Manufacturer::Navman,
            270 => Manufacturer::Cobi,
            271 => Manufacturer::Spivi,
            272 => Manufacturer::MioMagellan,
            273 => Manufacturer::Evesports,
            274 => Manufacturer::SensitivusGauge,
            275 => Manufacturer::Podoon,
            276 => Manufacturer::LifeTimeFitness,
            277 => Manufacturer::FalcoEMotors,
            278 => Manufacturer::Minoura,
            279 => Manufacturer::Cycliq,
            280 => Manufacturer::Luxottica,
            281 => Manufacturer::TrainerRoad,
            282 => Manufacturer::TheSufferfest,
            283 => Manufacturer::Fullspeedahead,
            284 => Manufacturer::Virtualtraining,
            285 => Manufacturer::Feedbacksports,
            286 => Manufacturer::Omata,
            287 => Manufacturer::Vdo,
            288 => Manufacturer::Magneticdays,
            289 => Manufacturer::Hammerhead,
            290 => Manufacturer::KineticByKurt,
            291 => Manufacturer::Shapelog,
            292 => Manufacturer::Dabuziduo,
            293 => Manufacturer::Jetblack,
            294 => Manufacturer::Coros,
            295 => Manufacturer::Virtugo,
            296 => Manufacturer::Velosense,
            297 => Manufacturer::Cycligentinc,
            298 => Manufacturer::Trailforks,
            299 => Manufacturer::MahleEbikemotion,
            300 => Manufacturer::Nurvv,
            301 => Manufacturer::Microprogram,
            302 => Manufacturer::Zone5cloud,
            303 => Manufacturer::Greenteg,
            304 => Manufacturer::YamahaMotors,
            305 => Manufacturer::Whoop,
            306 => Manufacturer::Gravaa,
            307 => Manufacturer::Onelap,
            308 => Manufacturer::MonarkExercise,
            309 => Manufacturer::Form,
            310 => Manufacturer::Decathlon,
            311 => Manufacturer::Syncros,
            312 => Manufacturer::Heatup,
            313 => Manufacturer::Cannondale,
            314 => Manufacturer::TrueFitness,
            315 => Manufacturer::RGTCycling,
            316 => Manufacturer::Vasa,
            317 => Manufacturer::RaceRepublic,
            318 => Manufacturer::Fazua,
            319 => Manufacturer::OrekaTraining,
            320 => Manufacturer::Lsec,
            321 => Manufacturer::LululemonStudio,
            322 => Manufacturer::Shanyue,
            323 => Manufacturer::SpinningMda,
            324 => Manufacturer::Hilldating,
            325 => Manufacturer::AeroSensor,
            326 => Manufacturer::Nike,
            327 => Manufacturer::Magicshine,
            328 => Manufacturer::Ictrainer,
            329 => Manufacturer::AbsoluteCycling,
            330 => Manufacturer::EoSwimbetter,
            331 => Manufacturer::Mywhoosh,
            332 => Manufacturer::Ravemen,
            333 => Manufacturer::TektroRacingProducts,
            334 => Manufacturer::DaradInnovationCorporation,
            335 => Manufacturer::Cycloptim,
            5759 => Manufacturer::Actigraphcorp,
            val => Manufacturer::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::Manufacturer(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum AntNetwork {
    Public,
    Antplus,
    Antfs,
    Private,
    UnknownVariant(u8),
}
impl AntNetwork {
    pub fn from(content: u8) -> AntNetwork {
        match content {
            0 => AntNetwork::Public,
            1 => AntNetwork::Antplus,
            2 => AntNetwork::Antfs,
            3 => AntNetwork::Private,
            val => AntNetwork::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::AntNetwork(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WorkoutCapabilities {
    Interval,
    Custom,
    FitnessEquipment,
    Firstbeat,
    NewLeaf,
    Tcx,
    Speed,
    HeartRate,
    Distance,
    Cadence,
    Power,
    Grade,
    Resistance,
    Protected,
    UnknownVariant(u32),
}
impl WorkoutCapabilities {
    pub fn from(content: u32) -> WorkoutCapabilities {
        match content {
            1 => WorkoutCapabilities::Interval,
            2 => WorkoutCapabilities::Custom,
            4 => WorkoutCapabilities::FitnessEquipment,
            8 => WorkoutCapabilities::Firstbeat,
            16 => WorkoutCapabilities::NewLeaf,
            32 => WorkoutCapabilities::Tcx,
            128 => WorkoutCapabilities::Speed,
            256 => WorkoutCapabilities::HeartRate,
            512 => WorkoutCapabilities::Distance,
            1024 => WorkoutCapabilities::Cadence,
            2048 => WorkoutCapabilities::Power,
            4096 => WorkoutCapabilities::Grade,
            8192 => WorkoutCapabilities::Resistance,
            16384 => WorkoutCapabilities::Protected,
            val => WorkoutCapabilities::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 4 {
            values.push(DataValue::Enum(FitEnum::WorkoutCapabilities(Self::from(
                reader.next_u32(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum BatteryStatus {
    New,
    Good,
    Ok,
    Low,
    Critical,
    Charging,
    Unknown,
    UnknownVariant(u8),
}
impl BatteryStatus {
    pub fn from(content: u8) -> BatteryStatus {
        match content {
            1 => BatteryStatus::New,
            2 => BatteryStatus::Good,
            3 => BatteryStatus::Ok,
            4 => BatteryStatus::Low,
            5 => BatteryStatus::Critical,
            6 => BatteryStatus::Charging,
            7 => BatteryStatus::Unknown,
            val => BatteryStatus::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::BatteryStatus(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum HrType {
    Normal,
    Irregular,
    UnknownVariant(u8),
}
impl HrType {
    pub fn from(content: u8) -> HrType {
        match content {
            0 => HrType::Normal,
            1 => HrType::Irregular,
            val => HrType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::HrType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum CourseCapabilities {
    Processed,
    Valid,
    Time,
    Distance,
    Position,
    HeartRate,
    Power,
    Cadence,
    Training,
    Navigation,
    Bikeway,
    Aviation,
    UnknownVariant(u32),
}
impl CourseCapabilities {
    pub fn from(content: u32) -> CourseCapabilities {
        match content {
            1 => CourseCapabilities::Processed,
            2 => CourseCapabilities::Valid,
            4 => CourseCapabilities::Time,
            8 => CourseCapabilities::Distance,
            16 => CourseCapabilities::Position,
            32 => CourseCapabilities::HeartRate,
            64 => CourseCapabilities::Power,
            128 => CourseCapabilities::Cadence,
            256 => CourseCapabilities::Training,
            512 => CourseCapabilities::Navigation,
            1024 => CourseCapabilities::Bikeway,
            4096 => CourseCapabilities::Aviation,
            val => CourseCapabilities::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 4 {
            values.push(DataValue::Enum(FitEnum::CourseCapabilities(Self::from(
                reader.next_u32(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Weight {
    Calculating,
    UnknownVariant(u16),
}
impl Weight {
    pub fn from(content: u16) -> Weight {
        match content {
            65534 => Weight::Calculating,
            val => Weight::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::Weight(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum BpStatus {
    NoError,
    ErrorIncompleteData,
    ErrorNoMeasurement,
    ErrorDataOutOfRange,
    ErrorIrregularHeartRate,
    UnknownVariant(u8),
}
impl BpStatus {
    pub fn from(content: u8) -> BpStatus {
        match content {
            0 => BpStatus::NoError,
            1 => BpStatus::ErrorIncompleteData,
            2 => BpStatus::ErrorNoMeasurement,
            3 => BpStatus::ErrorDataOutOfRange,
            4 => BpStatus::ErrorIrregularHeartRate,
            val => BpStatus::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::BpStatus(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum UserLocalId {
    LocalMin,
    LocalMax,
    StationaryMin,
    StationaryMax,
    PortableMin,
    PortableMax,
    UnknownVariant(u16),
}
impl UserLocalId {
    pub fn from(content: u16) -> UserLocalId {
        match content {
            0 => UserLocalId::LocalMin,
            15 => UserLocalId::LocalMax,
            16 => UserLocalId::StationaryMin,
            255 => UserLocalId::StationaryMax,
            256 => UserLocalId::PortableMin,
            65534 => UserLocalId::PortableMax,
            val => UserLocalId::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::UserLocalId(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SwimStroke {
    Freestyle,
    Backstroke,
    Breaststroke,
    Butterfly,
    Drill,
    Mixed,
    Im,
    ImByRound,
    Rimo,
    UnknownVariant(u8),
}
impl SwimStroke {
    pub fn from(content: u8) -> SwimStroke {
        match content {
            0 => SwimStroke::Freestyle,
            1 => SwimStroke::Backstroke,
            2 => SwimStroke::Breaststroke,
            3 => SwimStroke::Butterfly,
            4 => SwimStroke::Drill,
            5 => SwimStroke::Mixed,
            6 => SwimStroke::Im,
            7 => SwimStroke::ImByRound,
            8 => SwimStroke::Rimo,
            val => SwimStroke::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SwimStroke(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ActivityType {
    Generic,
    Running,
    Cycling,
    Transition,
    FitnessEquipment,
    Swimming,
    Walking,
    Sedentary,
    All,
    UnknownVariant(u8),
}
impl ActivityType {
    pub fn from(content: u8) -> ActivityType {
        match content {
            0 => ActivityType::Generic,
            1 => ActivityType::Running,
            2 => ActivityType::Cycling,
            3 => ActivityType::Transition,
            4 => ActivityType::FitnessEquipment,
            5 => ActivityType::Swimming,
            6 => ActivityType::Walking,
            8 => ActivityType::Sedentary,
            254 => ActivityType::All,
            val => ActivityType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ActivityType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ActivitySubtype {
    Generic,
    Treadmill,
    Street,
    Trail,
    Track,
    Spin,
    IndoorCycling,
    Road,
    Mountain,
    Downhill,
    Recumbent,
    Cyclocross,
    HandCycling,
    TrackCycling,
    IndoorRowing,
    Elliptical,
    StairClimbing,
    LapSwimming,
    OpenWater,
    All,
    UnknownVariant(u8),
}
impl ActivitySubtype {
    pub fn from(content: u8) -> ActivitySubtype {
        match content {
            0 => ActivitySubtype::Generic,
            1 => ActivitySubtype::Treadmill,
            2 => ActivitySubtype::Street,
            3 => ActivitySubtype::Trail,
            4 => ActivitySubtype::Track,
            5 => ActivitySubtype::Spin,
            6 => ActivitySubtype::IndoorCycling,
            7 => ActivitySubtype::Road,
            8 => ActivitySubtype::Mountain,
            9 => ActivitySubtype::Downhill,
            10 => ActivitySubtype::Recumbent,
            11 => ActivitySubtype::Cyclocross,
            12 => ActivitySubtype::HandCycling,
            13 => ActivitySubtype::TrackCycling,
            14 => ActivitySubtype::IndoorRowing,
            15 => ActivitySubtype::Elliptical,
            16 => ActivitySubtype::StairClimbing,
            17 => ActivitySubtype::LapSwimming,
            18 => ActivitySubtype::OpenWater,
            254 => ActivitySubtype::All,
            val => ActivitySubtype::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ActivitySubtype(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ActivityLevel {
    Low,
    Medium,
    High,
    UnknownVariant(u8),
}
impl ActivityLevel {
    pub fn from(content: u8) -> ActivityLevel {
        match content {
            0 => ActivityLevel::Low,
            1 => ActivityLevel::Medium,
            2 => ActivityLevel::High,
            val => ActivityLevel::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ActivityLevel(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Side {
    Right,
    Left,
    UnknownVariant(u8),
}
impl Side {
    pub fn from(content: u8) -> Side {
        match content {
            0 => Side::Right,
            1 => Side::Left,
            val => Side::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Side(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum LeftRightBalance {
    Mask,
    Right,
    UnknownVariant(u8),
}
impl LeftRightBalance {
    pub fn from(content: u8) -> LeftRightBalance {
        match content {
            127 => LeftRightBalance::Mask,
            128 => LeftRightBalance::Right,
            val => LeftRightBalance::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::LeftRightBalance(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum LeftRightBalance100 {
    Mask,
    Right,
    UnknownVariant(u16),
}
impl LeftRightBalance100 {
    pub fn from(content: u16) -> LeftRightBalance100 {
        match content {
            16383 => LeftRightBalance100::Mask,
            32768 => LeftRightBalance100::Right,
            val => LeftRightBalance100::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::LeftRightBalance100(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum LengthType {
    Idle,
    Active,
    UnknownVariant(u8),
}
impl LengthType {
    pub fn from(content: u8) -> LengthType {
        match content {
            0 => LengthType::Idle,
            1 => LengthType::Active,
            val => LengthType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::LengthType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DayOfWeek {
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    UnknownVariant(u8),
}
impl DayOfWeek {
    pub fn from(content: u8) -> DayOfWeek {
        match content {
            0 => DayOfWeek::Sunday,
            1 => DayOfWeek::Monday,
            2 => DayOfWeek::Tuesday,
            3 => DayOfWeek::Wednesday,
            4 => DayOfWeek::Thursday,
            5 => DayOfWeek::Friday,
            6 => DayOfWeek::Saturday,
            val => DayOfWeek::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DayOfWeek(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ConnectivityCapabilities {
    Bluetooth,
    BluetoothLe,
    Ant,
    ActivityUpload,
    CourseDownload,
    WorkoutDownload,
    LiveTrack,
    WeatherConditions,
    WeatherAlerts,
    GpsEphemerisDownload,
    ExplicitArchive,
    SetupIncomplete,
    ContinueSyncAfterSoftwareUpdate,
    ConnectIqAppDownload,
    GolfCourseDownload,
    DeviceInitiatesSync,
    ConnectIqWatchAppDownload,
    ConnectIqWidgetDownload,
    ConnectIqWatchFaceDownload,
    ConnectIqDataFieldDownload,
    ConnectIqAppManagment,
    SwingSensor,
    SwingSensorRemote,
    IncidentDetection,
    AudioPrompts,
    WifiVerification,
    TrueUp,
    FindMyWatch,
    RemoteManualSync,
    LiveTrackAutoStart,
    LiveTrackMessaging,
    InstantInput,
    UnknownVariant(u32),
}
impl ConnectivityCapabilities {
    pub fn from(content: u32) -> ConnectivityCapabilities {
        match content {
            1 => ConnectivityCapabilities::Bluetooth,
            2 => ConnectivityCapabilities::BluetoothLe,
            4 => ConnectivityCapabilities::Ant,
            8 => ConnectivityCapabilities::ActivityUpload,
            16 => ConnectivityCapabilities::CourseDownload,
            32 => ConnectivityCapabilities::WorkoutDownload,
            64 => ConnectivityCapabilities::LiveTrack,
            128 => ConnectivityCapabilities::WeatherConditions,
            256 => ConnectivityCapabilities::WeatherAlerts,
            512 => ConnectivityCapabilities::GpsEphemerisDownload,
            1024 => ConnectivityCapabilities::ExplicitArchive,
            2048 => ConnectivityCapabilities::SetupIncomplete,
            4096 => ConnectivityCapabilities::ContinueSyncAfterSoftwareUpdate,
            8192 => ConnectivityCapabilities::ConnectIqAppDownload,
            16384 => ConnectivityCapabilities::GolfCourseDownload,
            32768 => ConnectivityCapabilities::DeviceInitiatesSync,
            65536 => ConnectivityCapabilities::ConnectIqWatchAppDownload,
            131072 => ConnectivityCapabilities::ConnectIqWidgetDownload,
            262144 => ConnectivityCapabilities::ConnectIqWatchFaceDownload,
            524288 => ConnectivityCapabilities::ConnectIqDataFieldDownload,
            1048576 => ConnectivityCapabilities::ConnectIqAppManagment,
            2097152 => ConnectivityCapabilities::SwingSensor,
            4194304 => ConnectivityCapabilities::SwingSensorRemote,
            8388608 => ConnectivityCapabilities::IncidentDetection,
            16777216 => ConnectivityCapabilities::AudioPrompts,
            33554432 => ConnectivityCapabilities::WifiVerification,
            67108864 => ConnectivityCapabilities::TrueUp,
            134217728 => ConnectivityCapabilities::FindMyWatch,
            268435456 => ConnectivityCapabilities::RemoteManualSync,
            536870912 => ConnectivityCapabilities::LiveTrackAutoStart,
            1073741824 => ConnectivityCapabilities::LiveTrackMessaging,
            2147483648 => ConnectivityCapabilities::InstantInput,
            val => ConnectivityCapabilities::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 4 {
            values.push(DataValue::Enum(FitEnum::ConnectivityCapabilities(
                Self::from(reader.next_u32(endianness)?),
            )));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WeatherReport {
    Current,
    Forecast,
    HourlyForecast,
    DailyForecast,
    UnknownVariant(u8),
}
impl WeatherReport {
    pub fn from(content: u8) -> WeatherReport {
        match content {
            0 => WeatherReport::Current,
            1 => WeatherReport::Forecast,
            1 => WeatherReport::HourlyForecast,
            2 => WeatherReport::DailyForecast,
            val => WeatherReport::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WeatherReport(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WeatherStatus {
    Clear,
    PartlyCloudy,
    MostlyCloudy,
    Rain,
    Snow,
    Windy,
    Thunderstorms,
    WintryMix,
    Fog,
    Hazy,
    Hail,
    ScatteredShowers,
    ScatteredThunderstorms,
    UnknownPrecipitation,
    LightRain,
    HeavyRain,
    LightSnow,
    HeavySnow,
    LightRainSnow,
    HeavyRainSnow,
    Cloudy,
    UnknownVariant(u8),
}
impl WeatherStatus {
    pub fn from(content: u8) -> WeatherStatus {
        match content {
            0 => WeatherStatus::Clear,
            1 => WeatherStatus::PartlyCloudy,
            2 => WeatherStatus::MostlyCloudy,
            3 => WeatherStatus::Rain,
            4 => WeatherStatus::Snow,
            5 => WeatherStatus::Windy,
            6 => WeatherStatus::Thunderstorms,
            7 => WeatherStatus::WintryMix,
            8 => WeatherStatus::Fog,
            11 => WeatherStatus::Hazy,
            12 => WeatherStatus::Hail,
            13 => WeatherStatus::ScatteredShowers,
            14 => WeatherStatus::ScatteredThunderstorms,
            15 => WeatherStatus::UnknownPrecipitation,
            16 => WeatherStatus::LightRain,
            17 => WeatherStatus::HeavyRain,
            18 => WeatherStatus::LightSnow,
            19 => WeatherStatus::HeavySnow,
            20 => WeatherStatus::LightRainSnow,
            21 => WeatherStatus::HeavyRainSnow,
            22 => WeatherStatus::Cloudy,
            val => WeatherStatus::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WeatherStatus(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WeatherSeverity {
    Unknown,
    Warning,
    Watch,
    Advisory,
    Statement,
    UnknownVariant(u8),
}
impl WeatherSeverity {
    pub fn from(content: u8) -> WeatherSeverity {
        match content {
            0 => WeatherSeverity::Unknown,
            1 => WeatherSeverity::Warning,
            2 => WeatherSeverity::Watch,
            3 => WeatherSeverity::Advisory,
            4 => WeatherSeverity::Statement,
            val => WeatherSeverity::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WeatherSeverity(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WeatherSevereType {
    Unspecified,
    Tornado,
    Tsunami,
    Hurricane,
    ExtremeWind,
    Typhoon,
    InlandHurricane,
    HurricaneForceWind,
    Waterspout,
    SevereThunderstorm,
    WreckhouseWinds,
    LesSuetesWind,
    Avalanche,
    FlashFlood,
    TropicalStorm,
    InlandTropicalStorm,
    Blizzard,
    IceStorm,
    FreezingRain,
    DebrisFlow,
    FlashFreeze,
    DustStorm,
    HighWind,
    WinterStorm,
    HeavyFreezingSpray,
    ExtremeCold,
    WindChill,
    ColdWave,
    HeavySnowAlert,
    LakeEffectBlowingSnow,
    SnowSquall,
    LakeEffectSnow,
    WinterWeather,
    Sleet,
    Snowfall,
    SnowAndBlowingSnow,
    BlowingSnow,
    SnowAlert,
    ArcticOutflow,
    FreezingDrizzle,
    Storm,
    StormSurge,
    Rainfall,
    ArealFlood,
    CoastalFlood,
    LakeshoreFlood,
    ExcessiveHeat,
    Heat,
    Weather,
    HighHeatAndHumidity,
    HumidexAndHealth,
    Humidex,
    Gale,
    FreezingSpray,
    SpecialMarine,
    Squall,
    StrongWind,
    LakeWind,
    MarineWeather,
    Wind,
    SmallCraftHazardousSeas,
    HazardousSeas,
    SmallCraft,
    SmallCraftWinds,
    SmallCraftRoughBar,
    HighWaterLevel,
    Ashfall,
    FreezingFog,
    DenseFog,
    DenseSmoke,
    BlowingDust,
    HardFreeze,
    Freeze,
    Frost,
    FireWeather,
    Flood,
    RipTide,
    HighSurf,
    Smog,
    AirQuality,
    BriskWind,
    AirStagnation,
    LowWater,
    Hydrological,
    SpecialWeather,
    UnknownVariant(u8),
}
impl WeatherSevereType {
    pub fn from(content: u8) -> WeatherSevereType {
        match content {
            0 => WeatherSevereType::Unspecified,
            1 => WeatherSevereType::Tornado,
            2 => WeatherSevereType::Tsunami,
            3 => WeatherSevereType::Hurricane,
            4 => WeatherSevereType::ExtremeWind,
            5 => WeatherSevereType::Typhoon,
            6 => WeatherSevereType::InlandHurricane,
            7 => WeatherSevereType::HurricaneForceWind,
            8 => WeatherSevereType::Waterspout,
            9 => WeatherSevereType::SevereThunderstorm,
            10 => WeatherSevereType::WreckhouseWinds,
            11 => WeatherSevereType::LesSuetesWind,
            12 => WeatherSevereType::Avalanche,
            13 => WeatherSevereType::FlashFlood,
            14 => WeatherSevereType::TropicalStorm,
            15 => WeatherSevereType::InlandTropicalStorm,
            16 => WeatherSevereType::Blizzard,
            17 => WeatherSevereType::IceStorm,
            18 => WeatherSevereType::FreezingRain,
            19 => WeatherSevereType::DebrisFlow,
            20 => WeatherSevereType::FlashFreeze,
            21 => WeatherSevereType::DustStorm,
            22 => WeatherSevereType::HighWind,
            23 => WeatherSevereType::WinterStorm,
            24 => WeatherSevereType::HeavyFreezingSpray,
            25 => WeatherSevereType::ExtremeCold,
            26 => WeatherSevereType::WindChill,
            27 => WeatherSevereType::ColdWave,
            28 => WeatherSevereType::HeavySnowAlert,
            29 => WeatherSevereType::LakeEffectBlowingSnow,
            30 => WeatherSevereType::SnowSquall,
            31 => WeatherSevereType::LakeEffectSnow,
            32 => WeatherSevereType::WinterWeather,
            33 => WeatherSevereType::Sleet,
            34 => WeatherSevereType::Snowfall,
            35 => WeatherSevereType::SnowAndBlowingSnow,
            36 => WeatherSevereType::BlowingSnow,
            37 => WeatherSevereType::SnowAlert,
            38 => WeatherSevereType::ArcticOutflow,
            39 => WeatherSevereType::FreezingDrizzle,
            40 => WeatherSevereType::Storm,
            41 => WeatherSevereType::StormSurge,
            42 => WeatherSevereType::Rainfall,
            43 => WeatherSevereType::ArealFlood,
            44 => WeatherSevereType::CoastalFlood,
            45 => WeatherSevereType::LakeshoreFlood,
            46 => WeatherSevereType::ExcessiveHeat,
            47 => WeatherSevereType::Heat,
            48 => WeatherSevereType::Weather,
            49 => WeatherSevereType::HighHeatAndHumidity,
            50 => WeatherSevereType::HumidexAndHealth,
            51 => WeatherSevereType::Humidex,
            52 => WeatherSevereType::Gale,
            53 => WeatherSevereType::FreezingSpray,
            54 => WeatherSevereType::SpecialMarine,
            55 => WeatherSevereType::Squall,
            56 => WeatherSevereType::StrongWind,
            57 => WeatherSevereType::LakeWind,
            58 => WeatherSevereType::MarineWeather,
            59 => WeatherSevereType::Wind,
            60 => WeatherSevereType::SmallCraftHazardousSeas,
            61 => WeatherSevereType::HazardousSeas,
            62 => WeatherSevereType::SmallCraft,
            63 => WeatherSevereType::SmallCraftWinds,
            64 => WeatherSevereType::SmallCraftRoughBar,
            65 => WeatherSevereType::HighWaterLevel,
            66 => WeatherSevereType::Ashfall,
            67 => WeatherSevereType::FreezingFog,
            68 => WeatherSevereType::DenseFog,
            69 => WeatherSevereType::DenseSmoke,
            70 => WeatherSevereType::BlowingDust,
            71 => WeatherSevereType::HardFreeze,
            72 => WeatherSevereType::Freeze,
            73 => WeatherSevereType::Frost,
            74 => WeatherSevereType::FireWeather,
            75 => WeatherSevereType::Flood,
            76 => WeatherSevereType::RipTide,
            77 => WeatherSevereType::HighSurf,
            78 => WeatherSevereType::Smog,
            79 => WeatherSevereType::AirQuality,
            80 => WeatherSevereType::BriskWind,
            81 => WeatherSevereType::AirStagnation,
            82 => WeatherSevereType::LowWater,
            83 => WeatherSevereType::Hydrological,
            84 => WeatherSevereType::SpecialWeather,
            val => WeatherSevereType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WeatherSevereType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum LocaltimeIntoDay {
    UnknownVariant(u32),
}
impl LocaltimeIntoDay {
    pub fn from(content: u32) -> LocaltimeIntoDay {
        match content {
            val => LocaltimeIntoDay::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 4 {
            values.push(DataValue::Enum(FitEnum::LocaltimeIntoDay(Self::from(
                reader.next_u32(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum StrokeType {
    NoEvent,
    Other,
    Serve,
    Forehand,
    Backhand,
    Smash,
    UnknownVariant(u8),
}
impl StrokeType {
    pub fn from(content: u8) -> StrokeType {
        match content {
            0 => StrokeType::NoEvent,
            1 => StrokeType::Other,
            2 => StrokeType::Serve,
            3 => StrokeType::Forehand,
            4 => StrokeType::Backhand,
            5 => StrokeType::Smash,
            val => StrokeType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::StrokeType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum BodyLocation {
    LeftLeg,
    LeftCalf,
    LeftShin,
    LeftHamstring,
    LeftQuad,
    LeftGlute,
    RightLeg,
    RightCalf,
    RightShin,
    RightHamstring,
    RightQuad,
    RightGlute,
    TorsoBack,
    LeftLowerBack,
    LeftUpperBack,
    RightLowerBack,
    RightUpperBack,
    TorsoFront,
    LeftAbdomen,
    LeftChest,
    RightAbdomen,
    RightChest,
    LeftArm,
    LeftShoulder,
    LeftBicep,
    LeftTricep,
    LeftBrachioradialis,
    LeftForearmExtensors,
    RightArm,
    RightShoulder,
    RightBicep,
    RightTricep,
    RightBrachioradialis,
    RightForearmExtensors,
    Neck,
    Throat,
    WaistMidBack,
    WaistFront,
    WaistLeft,
    WaistRight,
    UnknownVariant(u8),
}
impl BodyLocation {
    pub fn from(content: u8) -> BodyLocation {
        match content {
            0 => BodyLocation::LeftLeg,
            1 => BodyLocation::LeftCalf,
            2 => BodyLocation::LeftShin,
            3 => BodyLocation::LeftHamstring,
            4 => BodyLocation::LeftQuad,
            5 => BodyLocation::LeftGlute,
            6 => BodyLocation::RightLeg,
            7 => BodyLocation::RightCalf,
            8 => BodyLocation::RightShin,
            9 => BodyLocation::RightHamstring,
            10 => BodyLocation::RightQuad,
            11 => BodyLocation::RightGlute,
            12 => BodyLocation::TorsoBack,
            13 => BodyLocation::LeftLowerBack,
            14 => BodyLocation::LeftUpperBack,
            15 => BodyLocation::RightLowerBack,
            16 => BodyLocation::RightUpperBack,
            17 => BodyLocation::TorsoFront,
            18 => BodyLocation::LeftAbdomen,
            19 => BodyLocation::LeftChest,
            20 => BodyLocation::RightAbdomen,
            21 => BodyLocation::RightChest,
            22 => BodyLocation::LeftArm,
            23 => BodyLocation::LeftShoulder,
            24 => BodyLocation::LeftBicep,
            25 => BodyLocation::LeftTricep,
            26 => BodyLocation::LeftBrachioradialis,
            27 => BodyLocation::LeftForearmExtensors,
            28 => BodyLocation::RightArm,
            29 => BodyLocation::RightShoulder,
            30 => BodyLocation::RightBicep,
            31 => BodyLocation::RightTricep,
            32 => BodyLocation::RightBrachioradialis,
            33 => BodyLocation::RightForearmExtensors,
            34 => BodyLocation::Neck,
            35 => BodyLocation::Throat,
            36 => BodyLocation::WaistMidBack,
            37 => BodyLocation::WaistFront,
            38 => BodyLocation::WaistLeft,
            39 => BodyLocation::WaistRight,
            val => BodyLocation::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::BodyLocation(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SegmentLapStatus {
    End,
    Fail,
    UnknownVariant(u8),
}
impl SegmentLapStatus {
    pub fn from(content: u8) -> SegmentLapStatus {
        match content {
            0 => SegmentLapStatus::End,
            1 => SegmentLapStatus::Fail,
            val => SegmentLapStatus::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SegmentLapStatus(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SegmentLeaderboardType {
    Overall,
    PersonalBest,
    Connections,
    Group,
    Challenger,
    Kom,
    Qom,
    Pr,
    Goal,
    Carrot,
    ClubLeader,
    Rival,
    Last,
    RecentBest,
    CourseRecord,
    UnknownVariant(u8),
}
impl SegmentLeaderboardType {
    pub fn from(content: u8) -> SegmentLeaderboardType {
        match content {
            0 => SegmentLeaderboardType::Overall,
            1 => SegmentLeaderboardType::PersonalBest,
            2 => SegmentLeaderboardType::Connections,
            3 => SegmentLeaderboardType::Group,
            4 => SegmentLeaderboardType::Challenger,
            5 => SegmentLeaderboardType::Kom,
            6 => SegmentLeaderboardType::Qom,
            7 => SegmentLeaderboardType::Pr,
            8 => SegmentLeaderboardType::Goal,
            9 => SegmentLeaderboardType::Carrot,
            10 => SegmentLeaderboardType::ClubLeader,
            11 => SegmentLeaderboardType::Rival,
            12 => SegmentLeaderboardType::Last,
            13 => SegmentLeaderboardType::RecentBest,
            14 => SegmentLeaderboardType::CourseRecord,
            val => SegmentLeaderboardType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SegmentLeaderboardType(
                Self::from(reader.next_u8()?),
            )));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SegmentDeleteStatus {
    DoNotDelete,
    DeleteOne,
    DeleteAll,
    UnknownVariant(u8),
}
impl SegmentDeleteStatus {
    pub fn from(content: u8) -> SegmentDeleteStatus {
        match content {
            0 => SegmentDeleteStatus::DoNotDelete,
            1 => SegmentDeleteStatus::DeleteOne,
            2 => SegmentDeleteStatus::DeleteAll,
            val => SegmentDeleteStatus::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SegmentDeleteStatus(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SegmentSelectionType {
    Starred,
    Suggested,
    UnknownVariant(u8),
}
impl SegmentSelectionType {
    pub fn from(content: u8) -> SegmentSelectionType {
        match content {
            0 => SegmentSelectionType::Starred,
            1 => SegmentSelectionType::Suggested,
            val => SegmentSelectionType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SegmentSelectionType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SourceType {
    Ant,
    Antplus,
    Bluetooth,
    BluetoothLowEnergy,
    Wifi,
    Local,
    UnknownVariant(u8),
}
impl SourceType {
    pub fn from(content: u8) -> SourceType {
        match content {
            0 => SourceType::Ant,
            1 => SourceType::Antplus,
            2 => SourceType::Bluetooth,
            3 => SourceType::BluetoothLowEnergy,
            4 => SourceType::Wifi,
            5 => SourceType::Local,
            val => SourceType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SourceType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum AntChannelId {
    AntExtendedDeviceNumberUpperNibble,
    AntTransmissionTypeLowerNibble,
    AntDeviceType,
    AntDeviceNumber,
    UnknownVariant(u32),
}
impl AntChannelId {
    pub fn from(content: u32) -> AntChannelId {
        match content {
            4026531840 => AntChannelId::AntExtendedDeviceNumberUpperNibble,
            251658240 => AntChannelId::AntTransmissionTypeLowerNibble,
            16711680 => AntChannelId::AntDeviceType,
            65535 => AntChannelId::AntDeviceNumber,
            val => AntChannelId::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 4 {
            values.push(DataValue::Enum(FitEnum::AntChannelId(Self::from(
                reader.next_u32(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DisplayOrientation {
    Auto,
    Portrait,
    Landscape,
    PortraitFlipped,
    LandscapeFlipped,
    UnknownVariant(u8),
}
impl DisplayOrientation {
    pub fn from(content: u8) -> DisplayOrientation {
        match content {
            0 => DisplayOrientation::Auto,
            1 => DisplayOrientation::Portrait,
            2 => DisplayOrientation::Landscape,
            3 => DisplayOrientation::PortraitFlipped,
            4 => DisplayOrientation::LandscapeFlipped,
            val => DisplayOrientation::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DisplayOrientation(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WorkoutEquipment {
    None,
    SwimFins,
    SwimKickboard,
    SwimPaddles,
    SwimPullBuoy,
    SwimSnorkel,
    UnknownVariant(u8),
}
impl WorkoutEquipment {
    pub fn from(content: u8) -> WorkoutEquipment {
        match content {
            0 => WorkoutEquipment::None,
            1 => WorkoutEquipment::SwimFins,
            2 => WorkoutEquipment::SwimKickboard,
            3 => WorkoutEquipment::SwimPaddles,
            4 => WorkoutEquipment::SwimPullBuoy,
            5 => WorkoutEquipment::SwimSnorkel,
            val => WorkoutEquipment::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WorkoutEquipment(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WatchfaceMode {
    Digital,
    Analog,
    ConnectIq,
    Disabled,
    UnknownVariant(u8),
}
impl WatchfaceMode {
    pub fn from(content: u8) -> WatchfaceMode {
        match content {
            0 => WatchfaceMode::Digital,
            1 => WatchfaceMode::Analog,
            2 => WatchfaceMode::ConnectIq,
            3 => WatchfaceMode::Disabled,
            val => WatchfaceMode::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WatchfaceMode(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum CameraEventType {
    VideoStart,
    VideoSplit,
    VideoEnd,
    PhotoTaken,
    VideoSecondStreamStart,
    VideoSecondStreamSplit,
    VideoSecondStreamEnd,
    VideoSplitStart,
    VideoSecondStreamSplitStart,
    VideoPause,
    VideoSecondStreamPause,
    VideoResume,
    VideoSecondStreamResume,
    UnknownVariant(u8),
}
impl CameraEventType {
    pub fn from(content: u8) -> CameraEventType {
        match content {
            0 => CameraEventType::VideoStart,
            1 => CameraEventType::VideoSplit,
            2 => CameraEventType::VideoEnd,
            3 => CameraEventType::PhotoTaken,
            4 => CameraEventType::VideoSecondStreamStart,
            5 => CameraEventType::VideoSecondStreamSplit,
            6 => CameraEventType::VideoSecondStreamEnd,
            7 => CameraEventType::VideoSplitStart,
            8 => CameraEventType::VideoSecondStreamSplitStart,
            11 => CameraEventType::VideoPause,
            12 => CameraEventType::VideoSecondStreamPause,
            13 => CameraEventType::VideoResume,
            14 => CameraEventType::VideoSecondStreamResume,
            val => CameraEventType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::CameraEventType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SensorType {
    Accelerometer,
    Gyroscope,
    Compass,
    Barometer,
    UnknownVariant(u8),
}
impl SensorType {
    pub fn from(content: u8) -> SensorType {
        match content {
            0 => SensorType::Accelerometer,
            1 => SensorType::Gyroscope,
            2 => SensorType::Compass,
            3 => SensorType::Barometer,
            val => SensorType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SensorType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum CameraOrientationType {
    CameraOrientation0,
    CameraOrientation90,
    CameraOrientation180,
    CameraOrientation270,
    UnknownVariant(u8),
}
impl CameraOrientationType {
    pub fn from(content: u8) -> CameraOrientationType {
        match content {
            0 => CameraOrientationType::CameraOrientation0,
            1 => CameraOrientationType::CameraOrientation90,
            2 => CameraOrientationType::CameraOrientation180,
            3 => CameraOrientationType::CameraOrientation270,
            val => CameraOrientationType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::CameraOrientationType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum AttitudeStage {
    Failed,
    Aligning,
    Degraded,
    Valid,
    UnknownVariant(u8),
}
impl AttitudeStage {
    pub fn from(content: u8) -> AttitudeStage {
        match content {
            0 => AttitudeStage::Failed,
            1 => AttitudeStage::Aligning,
            2 => AttitudeStage::Degraded,
            3 => AttitudeStage::Valid,
            val => AttitudeStage::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::AttitudeStage(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum AttitudeValidity {
    TrackAngleHeadingValid,
    PitchValid,
    RollValid,
    LateralBodyAccelValid,
    NormalBodyAccelValid,
    TurnRateValid,
    HwFail,
    MagInvalid,
    NoGps,
    GpsInvalid,
    SolutionCoasting,
    TrueTrackAngle,
    MagneticHeading,
    UnknownVariant(u16),
}
impl AttitudeValidity {
    pub fn from(content: u16) -> AttitudeValidity {
        match content {
            1 => AttitudeValidity::TrackAngleHeadingValid,
            2 => AttitudeValidity::PitchValid,
            4 => AttitudeValidity::RollValid,
            8 => AttitudeValidity::LateralBodyAccelValid,
            16 => AttitudeValidity::NormalBodyAccelValid,
            32 => AttitudeValidity::TurnRateValid,
            64 => AttitudeValidity::HwFail,
            128 => AttitudeValidity::MagInvalid,
            256 => AttitudeValidity::NoGps,
            512 => AttitudeValidity::GpsInvalid,
            1024 => AttitudeValidity::SolutionCoasting,
            2048 => AttitudeValidity::TrueTrackAngle,
            4096 => AttitudeValidity::MagneticHeading,
            val => AttitudeValidity::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::AttitudeValidity(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum AutoSyncFrequency {
    Never,
    Occasionally,
    Frequent,
    OnceADay,
    Remote,
    UnknownVariant(u8),
}
impl AutoSyncFrequency {
    pub fn from(content: u8) -> AutoSyncFrequency {
        match content {
            0 => AutoSyncFrequency::Never,
            1 => AutoSyncFrequency::Occasionally,
            2 => AutoSyncFrequency::Frequent,
            3 => AutoSyncFrequency::OnceADay,
            4 => AutoSyncFrequency::Remote,
            val => AutoSyncFrequency::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::AutoSyncFrequency(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ExdLayout {
    FullScreen,
    HalfVertical,
    HalfHorizontal,
    HalfVerticalRightSplit,
    HalfHorizontalBottomSplit,
    FullQuarterSplit,
    HalfVerticalLeftSplit,
    HalfHorizontalTopSplit,
    Dynamic,
    UnknownVariant(u8),
}
impl ExdLayout {
    pub fn from(content: u8) -> ExdLayout {
        match content {
            0 => ExdLayout::FullScreen,
            1 => ExdLayout::HalfVertical,
            2 => ExdLayout::HalfHorizontal,
            3 => ExdLayout::HalfVerticalRightSplit,
            4 => ExdLayout::HalfHorizontalBottomSplit,
            5 => ExdLayout::FullQuarterSplit,
            6 => ExdLayout::HalfVerticalLeftSplit,
            7 => ExdLayout::HalfHorizontalTopSplit,
            8 => ExdLayout::Dynamic,
            val => ExdLayout::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ExdLayout(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ExdDisplayType {
    Numerical,
    Simple,
    Graph,
    Bar,
    CircleGraph,
    VirtualPartner,
    Balance,
    StringList,
    String,
    SimpleDynamicIcon,
    Gauge,
    UnknownVariant(u8),
}
impl ExdDisplayType {
    pub fn from(content: u8) -> ExdDisplayType {
        match content {
            0 => ExdDisplayType::Numerical,
            1 => ExdDisplayType::Simple,
            2 => ExdDisplayType::Graph,
            3 => ExdDisplayType::Bar,
            4 => ExdDisplayType::CircleGraph,
            5 => ExdDisplayType::VirtualPartner,
            6 => ExdDisplayType::Balance,
            7 => ExdDisplayType::StringList,
            8 => ExdDisplayType::String,
            9 => ExdDisplayType::SimpleDynamicIcon,
            10 => ExdDisplayType::Gauge,
            val => ExdDisplayType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ExdDisplayType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ExdDataUnits {
    NoUnits,
    Laps,
    MilesPerHour,
    KilometersPerHour,
    FeetPerHour,
    MetersPerHour,
    DegreesCelsius,
    DegreesFarenheit,
    Zone,
    Gear,
    Rpm,
    Bpm,
    Degrees,
    Millimeters,
    Meters,
    Kilometers,
    Feet,
    Yards,
    Kilofeet,
    Miles,
    Time,
    EnumTurnType,
    Percent,
    Watts,
    WattsPerKilogram,
    EnumBatteryStatus,
    EnumBikeLightBeamAngleMode,
    EnumBikeLightBatteryStatus,
    EnumBikeLightNetworkConfigType,
    Lights,
    Seconds,
    Minutes,
    Hours,
    Calories,
    Kilojoules,
    Milliseconds,
    SecondPerMile,
    SecondPerKilometer,
    Centimeter,
    EnumCoursePoint,
    Bradians,
    EnumSport,
    InchesHg,
    MmHg,
    Mbars,
    HectoPascals,
    FeetPerMin,
    MetersPerMin,
    MetersPerSec,
    EightCardinal,
    UnknownVariant(u8),
}
impl ExdDataUnits {
    pub fn from(content: u8) -> ExdDataUnits {
        match content {
            0 => ExdDataUnits::NoUnits,
            1 => ExdDataUnits::Laps,
            2 => ExdDataUnits::MilesPerHour,
            3 => ExdDataUnits::KilometersPerHour,
            4 => ExdDataUnits::FeetPerHour,
            5 => ExdDataUnits::MetersPerHour,
            6 => ExdDataUnits::DegreesCelsius,
            7 => ExdDataUnits::DegreesFarenheit,
            8 => ExdDataUnits::Zone,
            9 => ExdDataUnits::Gear,
            10 => ExdDataUnits::Rpm,
            11 => ExdDataUnits::Bpm,
            12 => ExdDataUnits::Degrees,
            13 => ExdDataUnits::Millimeters,
            14 => ExdDataUnits::Meters,
            15 => ExdDataUnits::Kilometers,
            16 => ExdDataUnits::Feet,
            17 => ExdDataUnits::Yards,
            18 => ExdDataUnits::Kilofeet,
            19 => ExdDataUnits::Miles,
            20 => ExdDataUnits::Time,
            21 => ExdDataUnits::EnumTurnType,
            22 => ExdDataUnits::Percent,
            23 => ExdDataUnits::Watts,
            24 => ExdDataUnits::WattsPerKilogram,
            25 => ExdDataUnits::EnumBatteryStatus,
            26 => ExdDataUnits::EnumBikeLightBeamAngleMode,
            27 => ExdDataUnits::EnumBikeLightBatteryStatus,
            28 => ExdDataUnits::EnumBikeLightNetworkConfigType,
            29 => ExdDataUnits::Lights,
            30 => ExdDataUnits::Seconds,
            31 => ExdDataUnits::Minutes,
            32 => ExdDataUnits::Hours,
            33 => ExdDataUnits::Calories,
            34 => ExdDataUnits::Kilojoules,
            35 => ExdDataUnits::Milliseconds,
            36 => ExdDataUnits::SecondPerMile,
            37 => ExdDataUnits::SecondPerKilometer,
            38 => ExdDataUnits::Centimeter,
            39 => ExdDataUnits::EnumCoursePoint,
            40 => ExdDataUnits::Bradians,
            41 => ExdDataUnits::EnumSport,
            42 => ExdDataUnits::InchesHg,
            43 => ExdDataUnits::MmHg,
            44 => ExdDataUnits::Mbars,
            45 => ExdDataUnits::HectoPascals,
            46 => ExdDataUnits::FeetPerMin,
            47 => ExdDataUnits::MetersPerMin,
            48 => ExdDataUnits::MetersPerSec,
            49 => ExdDataUnits::EightCardinal,
            val => ExdDataUnits::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ExdDataUnits(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ExdQualifiers {
    NoQualifier,
    Instantaneous,
    Average,
    Lap,
    Maximum,
    MaximumAverage,
    MaximumLap,
    LastLap,
    AverageLap,
    ToDestination,
    ToGo,
    ToNext,
    NextCoursePoint,
    Total,
    ThreeSecondAverage,
    TenSecondAverage,
    ThirtySecondAverage,
    PercentMaximum,
    PercentMaximumAverage,
    LapPercentMaximum,
    Elapsed,
    Sunrise,
    Sunset,
    ComparedToVirtualPartner,
    Maximum24h,
    Minimum24h,
    Minimum,
    First,
    Second,
    Third,
    Shifter,
    LastSport,
    Moving,
    Stopped,
    EstimatedTotal,
    Zone9,
    Zone8,
    Zone7,
    Zone6,
    Zone5,
    Zone4,
    Zone3,
    Zone2,
    Zone1,
    UnknownVariant(u8),
}
impl ExdQualifiers {
    pub fn from(content: u8) -> ExdQualifiers {
        match content {
            0 => ExdQualifiers::NoQualifier,
            1 => ExdQualifiers::Instantaneous,
            2 => ExdQualifiers::Average,
            3 => ExdQualifiers::Lap,
            4 => ExdQualifiers::Maximum,
            5 => ExdQualifiers::MaximumAverage,
            6 => ExdQualifiers::MaximumLap,
            7 => ExdQualifiers::LastLap,
            8 => ExdQualifiers::AverageLap,
            9 => ExdQualifiers::ToDestination,
            10 => ExdQualifiers::ToGo,
            11 => ExdQualifiers::ToNext,
            12 => ExdQualifiers::NextCoursePoint,
            13 => ExdQualifiers::Total,
            14 => ExdQualifiers::ThreeSecondAverage,
            15 => ExdQualifiers::TenSecondAverage,
            16 => ExdQualifiers::ThirtySecondAverage,
            17 => ExdQualifiers::PercentMaximum,
            18 => ExdQualifiers::PercentMaximumAverage,
            19 => ExdQualifiers::LapPercentMaximum,
            20 => ExdQualifiers::Elapsed,
            21 => ExdQualifiers::Sunrise,
            22 => ExdQualifiers::Sunset,
            23 => ExdQualifiers::ComparedToVirtualPartner,
            24 => ExdQualifiers::Maximum24h,
            25 => ExdQualifiers::Minimum24h,
            26 => ExdQualifiers::Minimum,
            27 => ExdQualifiers::First,
            28 => ExdQualifiers::Second,
            29 => ExdQualifiers::Third,
            30 => ExdQualifiers::Shifter,
            31 => ExdQualifiers::LastSport,
            32 => ExdQualifiers::Moving,
            33 => ExdQualifiers::Stopped,
            34 => ExdQualifiers::EstimatedTotal,
            242 => ExdQualifiers::Zone9,
            243 => ExdQualifiers::Zone8,
            244 => ExdQualifiers::Zone7,
            245 => ExdQualifiers::Zone6,
            246 => ExdQualifiers::Zone5,
            247 => ExdQualifiers::Zone4,
            248 => ExdQualifiers::Zone3,
            249 => ExdQualifiers::Zone2,
            250 => ExdQualifiers::Zone1,
            val => ExdQualifiers::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ExdQualifiers(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ExdDescriptors {
    BikeLightBatteryStatus,
    BeamAngleStatus,
    BateryLevel,
    LightNetworkMode,
    NumberLightsConnected,
    Cadence,
    Distance,
    EstimatedTimeOfArrival,
    Heading,
    Time,
    BatteryLevel,
    TrainerResistance,
    TrainerTargetPower,
    TimeSeated,
    TimeStanding,
    Elevation,
    Grade,
    Ascent,
    Descent,
    VerticalSpeed,
    Di2BatteryLevel,
    FrontGear,
    RearGear,
    GearRatio,
    HeartRate,
    HeartRateZone,
    TimeInHeartRateZone,
    HeartRateReserve,
    Calories,
    GpsAccuracy,
    GpsSignalStrength,
    Temperature,
    TimeOfDay,
    Balance,
    PedalSmoothness,
    Power,
    FunctionalThresholdPower,
    IntensityFactor,
    Work,
    PowerRatio,
    NormalizedPower,
    TrainingStressScore,
    TimeOnZone,
    Speed,
    Laps,
    Reps,
    WorkoutStep,
    CourseDistance,
    NavigationDistance,
    CourseEstimatedTimeOfArrival,
    NavigationEstimatedTimeOfArrival,
    CourseTime,
    NavigationTime,
    CourseHeading,
    NavigationHeading,
    PowerZone,
    TorqueEffectiveness,
    TimerTime,
    PowerWeightRatio,
    LeftPlatformCenterOffset,
    RightPlatformCenterOffset,
    LeftPowerPhaseStartAngle,
    RightPowerPhaseStartAngle,
    LeftPowerPhaseFinishAngle,
    RightPowerPhaseFinishAngle,
    Gears,
    Pace,
    TrainingEffect,
    VerticalOscillation,
    VerticalRatio,
    GroundContactTime,
    LeftGroundContactTimeBalance,
    RightGroundContactTimeBalance,
    StrideLength,
    RunningCadence,
    PerformanceCondition,
    CourseType,
    TimeInPowerZone,
    NavigationTurn,
    CourseLocation,
    NavigationLocation,
    Compass,
    GearCombo,
    MuscleOxygen,
    Icon,
    CompassHeading,
    GpsHeading,
    GpsElevation,
    AnaerobicTrainingEffect,
    Course,
    OffCourse,
    GlideRatio,
    VerticalDistance,
    Vmg,
    AmbientPressure,
    Pressure,
    Vam,
    UnknownVariant(u8),
}
impl ExdDescriptors {
    pub fn from(content: u8) -> ExdDescriptors {
        match content {
            0 => ExdDescriptors::BikeLightBatteryStatus,
            1 => ExdDescriptors::BeamAngleStatus,
            2 => ExdDescriptors::BateryLevel,
            3 => ExdDescriptors::LightNetworkMode,
            4 => ExdDescriptors::NumberLightsConnected,
            5 => ExdDescriptors::Cadence,
            6 => ExdDescriptors::Distance,
            7 => ExdDescriptors::EstimatedTimeOfArrival,
            8 => ExdDescriptors::Heading,
            9 => ExdDescriptors::Time,
            10 => ExdDescriptors::BatteryLevel,
            11 => ExdDescriptors::TrainerResistance,
            12 => ExdDescriptors::TrainerTargetPower,
            13 => ExdDescriptors::TimeSeated,
            14 => ExdDescriptors::TimeStanding,
            15 => ExdDescriptors::Elevation,
            16 => ExdDescriptors::Grade,
            17 => ExdDescriptors::Ascent,
            18 => ExdDescriptors::Descent,
            19 => ExdDescriptors::VerticalSpeed,
            20 => ExdDescriptors::Di2BatteryLevel,
            21 => ExdDescriptors::FrontGear,
            22 => ExdDescriptors::RearGear,
            23 => ExdDescriptors::GearRatio,
            24 => ExdDescriptors::HeartRate,
            25 => ExdDescriptors::HeartRateZone,
            26 => ExdDescriptors::TimeInHeartRateZone,
            27 => ExdDescriptors::HeartRateReserve,
            28 => ExdDescriptors::Calories,
            29 => ExdDescriptors::GpsAccuracy,
            30 => ExdDescriptors::GpsSignalStrength,
            31 => ExdDescriptors::Temperature,
            32 => ExdDescriptors::TimeOfDay,
            33 => ExdDescriptors::Balance,
            34 => ExdDescriptors::PedalSmoothness,
            35 => ExdDescriptors::Power,
            36 => ExdDescriptors::FunctionalThresholdPower,
            37 => ExdDescriptors::IntensityFactor,
            38 => ExdDescriptors::Work,
            39 => ExdDescriptors::PowerRatio,
            40 => ExdDescriptors::NormalizedPower,
            41 => ExdDescriptors::TrainingStressScore,
            42 => ExdDescriptors::TimeOnZone,
            43 => ExdDescriptors::Speed,
            44 => ExdDescriptors::Laps,
            45 => ExdDescriptors::Reps,
            46 => ExdDescriptors::WorkoutStep,
            47 => ExdDescriptors::CourseDistance,
            48 => ExdDescriptors::NavigationDistance,
            49 => ExdDescriptors::CourseEstimatedTimeOfArrival,
            50 => ExdDescriptors::NavigationEstimatedTimeOfArrival,
            51 => ExdDescriptors::CourseTime,
            52 => ExdDescriptors::NavigationTime,
            53 => ExdDescriptors::CourseHeading,
            54 => ExdDescriptors::NavigationHeading,
            55 => ExdDescriptors::PowerZone,
            56 => ExdDescriptors::TorqueEffectiveness,
            57 => ExdDescriptors::TimerTime,
            58 => ExdDescriptors::PowerWeightRatio,
            59 => ExdDescriptors::LeftPlatformCenterOffset,
            60 => ExdDescriptors::RightPlatformCenterOffset,
            61 => ExdDescriptors::LeftPowerPhaseStartAngle,
            62 => ExdDescriptors::RightPowerPhaseStartAngle,
            63 => ExdDescriptors::LeftPowerPhaseFinishAngle,
            64 => ExdDescriptors::RightPowerPhaseFinishAngle,
            65 => ExdDescriptors::Gears,
            66 => ExdDescriptors::Pace,
            67 => ExdDescriptors::TrainingEffect,
            68 => ExdDescriptors::VerticalOscillation,
            69 => ExdDescriptors::VerticalRatio,
            70 => ExdDescriptors::GroundContactTime,
            71 => ExdDescriptors::LeftGroundContactTimeBalance,
            72 => ExdDescriptors::RightGroundContactTimeBalance,
            73 => ExdDescriptors::StrideLength,
            74 => ExdDescriptors::RunningCadence,
            75 => ExdDescriptors::PerformanceCondition,
            76 => ExdDescriptors::CourseType,
            77 => ExdDescriptors::TimeInPowerZone,
            78 => ExdDescriptors::NavigationTurn,
            79 => ExdDescriptors::CourseLocation,
            80 => ExdDescriptors::NavigationLocation,
            81 => ExdDescriptors::Compass,
            82 => ExdDescriptors::GearCombo,
            83 => ExdDescriptors::MuscleOxygen,
            84 => ExdDescriptors::Icon,
            85 => ExdDescriptors::CompassHeading,
            86 => ExdDescriptors::GpsHeading,
            87 => ExdDescriptors::GpsElevation,
            88 => ExdDescriptors::AnaerobicTrainingEffect,
            89 => ExdDescriptors::Course,
            90 => ExdDescriptors::OffCourse,
            91 => ExdDescriptors::GlideRatio,
            92 => ExdDescriptors::VerticalDistance,
            93 => ExdDescriptors::Vmg,
            94 => ExdDescriptors::AmbientPressure,
            95 => ExdDescriptors::Pressure,
            96 => ExdDescriptors::Vam,
            val => ExdDescriptors::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ExdDescriptors(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum AutoActivityDetect {
    None,
    Running,
    Cycling,
    Swimming,
    Walking,
    Elliptical,
    Sedentary,
    UnknownVariant(u32),
}
impl AutoActivityDetect {
    pub fn from(content: u32) -> AutoActivityDetect {
        match content {
            0 => AutoActivityDetect::None,
            1 => AutoActivityDetect::Running,
            2 => AutoActivityDetect::Cycling,
            4 => AutoActivityDetect::Swimming,
            8 => AutoActivityDetect::Walking,
            32 => AutoActivityDetect::Elliptical,
            1024 => AutoActivityDetect::Sedentary,
            val => AutoActivityDetect::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 4 {
            values.push(DataValue::Enum(FitEnum::AutoActivityDetect(Self::from(
                reader.next_u32(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum FitBaseType {
    Enum,
    Sint8,
    Uint8,
    Sint16,
    Uint16,
    Sint32,
    Uint32,
    String,
    Float32,
    Float64,
    Uint8z,
    Uint16z,
    Uint32z,
    Byte,
    Sint64,
    Uint64,
    Uint64z,
    UnknownVariant(u8),
}
impl FitBaseType {
    pub fn from(content: u8) -> FitBaseType {
        match content {
            0 => FitBaseType::Enum,
            1 => FitBaseType::Sint8,
            2 => FitBaseType::Uint8,
            131 => FitBaseType::Sint16,
            132 => FitBaseType::Uint16,
            133 => FitBaseType::Sint32,
            134 => FitBaseType::Uint32,
            7 => FitBaseType::String,
            136 => FitBaseType::Float32,
            137 => FitBaseType::Float64,
            10 => FitBaseType::Uint8z,
            139 => FitBaseType::Uint16z,
            140 => FitBaseType::Uint32z,
            13 => FitBaseType::Byte,
            142 => FitBaseType::Sint64,
            143 => FitBaseType::Uint64,
            144 => FitBaseType::Uint64z,
            val => FitBaseType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::FitBaseType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum FitBaseUnit {
    Other,
    Kilogram,
    Pound,
    UnknownVariant(u16),
}
impl FitBaseUnit {
    pub fn from(content: u16) -> FitBaseUnit {
        match content {
            0 => FitBaseUnit::Other,
            1 => FitBaseUnit::Kilogram,
            2 => FitBaseUnit::Pound,
            val => FitBaseUnit::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::FitBaseUnit(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SetType {
    Rest,
    Active,
    UnknownVariant(u8),
}
impl SetType {
    pub fn from(content: u8) -> SetType {
        match content {
            0 => SetType::Rest,
            1 => SetType::Active,
            val => SetType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SetType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum MaxMetCategory {
    Generic,
    Cycling,
    UnknownVariant(u8),
}
impl MaxMetCategory {
    pub fn from(content: u8) -> MaxMetCategory {
        match content {
            0 => MaxMetCategory::Generic,
            1 => MaxMetCategory::Cycling,
            val => MaxMetCategory::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::MaxMetCategory(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ExerciseCategory {
    BenchPress,
    CalfRaise,
    Cardio,
    Carry,
    Chop,
    Core,
    Crunch,
    Curl,
    Deadlift,
    Flye,
    HipRaise,
    HipStability,
    HipSwing,
    Hyperextension,
    LateralRaise,
    LegCurl,
    LegRaise,
    Lunge,
    OlympicLift,
    Plank,
    Plyo,
    PullUp,
    PushUp,
    Row,
    ShoulderPress,
    ShoulderStability,
    Shrug,
    SitUp,
    Squat,
    TotalBody,
    TricepsExtension,
    WarmUp,
    Run,
    Bike,
    CardioSensors,
    Move,
    Pose,
    BandedExercises,
    BattleRope,
    Elliptical,
    FloorClimb,
    IndoorBike,
    IndoorRow,
    Ladder,
    Sandbag,
    Sled,
    SledgeHammer,
    StairStepper,
    Suspension,
    Tire,
    RunIndoor,
    BikeOutdoor,
    Unknown,
    UnknownVariant(u16),
}
impl ExerciseCategory {
    pub fn from(content: u16) -> ExerciseCategory {
        match content {
            0 => ExerciseCategory::BenchPress,
            1 => ExerciseCategory::CalfRaise,
            2 => ExerciseCategory::Cardio,
            3 => ExerciseCategory::Carry,
            4 => ExerciseCategory::Chop,
            5 => ExerciseCategory::Core,
            6 => ExerciseCategory::Crunch,
            7 => ExerciseCategory::Curl,
            8 => ExerciseCategory::Deadlift,
            9 => ExerciseCategory::Flye,
            10 => ExerciseCategory::HipRaise,
            11 => ExerciseCategory::HipStability,
            12 => ExerciseCategory::HipSwing,
            13 => ExerciseCategory::Hyperextension,
            14 => ExerciseCategory::LateralRaise,
            15 => ExerciseCategory::LegCurl,
            16 => ExerciseCategory::LegRaise,
            17 => ExerciseCategory::Lunge,
            18 => ExerciseCategory::OlympicLift,
            19 => ExerciseCategory::Plank,
            20 => ExerciseCategory::Plyo,
            21 => ExerciseCategory::PullUp,
            22 => ExerciseCategory::PushUp,
            23 => ExerciseCategory::Row,
            24 => ExerciseCategory::ShoulderPress,
            25 => ExerciseCategory::ShoulderStability,
            26 => ExerciseCategory::Shrug,
            27 => ExerciseCategory::SitUp,
            28 => ExerciseCategory::Squat,
            29 => ExerciseCategory::TotalBody,
            30 => ExerciseCategory::TricepsExtension,
            31 => ExerciseCategory::WarmUp,
            32 => ExerciseCategory::Run,
            33 => ExerciseCategory::Bike,
            34 => ExerciseCategory::CardioSensors,
            35 => ExerciseCategory::Move,
            36 => ExerciseCategory::Pose,
            37 => ExerciseCategory::BandedExercises,
            38 => ExerciseCategory::BattleRope,
            39 => ExerciseCategory::Elliptical,
            40 => ExerciseCategory::FloorClimb,
            41 => ExerciseCategory::IndoorBike,
            42 => ExerciseCategory::IndoorRow,
            43 => ExerciseCategory::Ladder,
            44 => ExerciseCategory::Sandbag,
            45 => ExerciseCategory::Sled,
            46 => ExerciseCategory::SledgeHammer,
            47 => ExerciseCategory::StairStepper,
            49 => ExerciseCategory::Suspension,
            50 => ExerciseCategory::Tire,
            52 => ExerciseCategory::RunIndoor,
            53 => ExerciseCategory::BikeOutdoor,
            65534 => ExerciseCategory::Unknown,
            val => ExerciseCategory::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 2 {
            values.push(DataValue::Enum(FitEnum::ExerciseCategory(Self::from(
                reader.next_u16(endianness)?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum WaterType {
    Fresh,
    Salt,
    En13319,
    Custom,
    UnknownVariant(u8),
}
impl WaterType {
    pub fn from(content: u8) -> WaterType {
        match content {
            0 => WaterType::Fresh,
            1 => WaterType::Salt,
            2 => WaterType::En13319,
            3 => WaterType::Custom,
            val => WaterType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::WaterType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum TissueModelType {
    Zhl16c,
    UnknownVariant(u8),
}
impl TissueModelType {
    pub fn from(content: u8) -> TissueModelType {
        match content {
            0 => TissueModelType::Zhl16c,
            val => TissueModelType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::TissueModelType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DiveGasStatus {
    Disabled,
    Enabled,
    BackupOnly,
    UnknownVariant(u8),
}
impl DiveGasStatus {
    pub fn from(content: u8) -> DiveGasStatus {
        match content {
            0 => DiveGasStatus::Disabled,
            1 => DiveGasStatus::Enabled,
            2 => DiveGasStatus::BackupOnly,
            val => DiveGasStatus::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DiveGasStatus(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DiveAlarmType {
    Depth,
    Time,
    Speed,
    UnknownVariant(u8),
}
impl DiveAlarmType {
    pub fn from(content: u8) -> DiveAlarmType {
        match content {
            0 => DiveAlarmType::Depth,
            1 => DiveAlarmType::Time,
            2 => DiveAlarmType::Speed,
            val => DiveAlarmType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DiveAlarmType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DiveBacklightMode {
    AtDepth,
    AlwaysOn,
    UnknownVariant(u8),
}
impl DiveBacklightMode {
    pub fn from(content: u8) -> DiveBacklightMode {
        match content {
            0 => DiveBacklightMode::AtDepth,
            1 => DiveBacklightMode::AlwaysOn,
            val => DiveBacklightMode::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DiveBacklightMode(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SleepLevel {
    Unmeasurable,
    Awake,
    Light,
    Deep,
    Rem,
    UnknownVariant(u8),
}
impl SleepLevel {
    pub fn from(content: u8) -> SleepLevel {
        match content {
            0 => SleepLevel::Unmeasurable,
            1 => SleepLevel::Awake,
            2 => SleepLevel::Light,
            3 => SleepLevel::Deep,
            4 => SleepLevel::Rem,
            val => SleepLevel::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SleepLevel(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Spo2MeasurementType {
    OffWrist,
    SpotCheck,
    ContinuousCheck,
    Periodic,
    UnknownVariant(u8),
}
impl Spo2MeasurementType {
    pub fn from(content: u8) -> Spo2MeasurementType {
        match content {
            0 => Spo2MeasurementType::OffWrist,
            1 => Spo2MeasurementType::SpotCheck,
            2 => Spo2MeasurementType::ContinuousCheck,
            3 => Spo2MeasurementType::Periodic,
            val => Spo2MeasurementType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::Spo2MeasurementType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum CcrSetpointSwitchMode {
    Manual,
    Automatic,
    UnknownVariant(u8),
}
impl CcrSetpointSwitchMode {
    pub fn from(content: u8) -> CcrSetpointSwitchMode {
        match content {
            0 => CcrSetpointSwitchMode::Manual,
            1 => CcrSetpointSwitchMode::Automatic,
            val => CcrSetpointSwitchMode::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::CcrSetpointSwitchMode(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum DiveGasMode {
    OpenCircuit,
    ClosedCircuitDiluent,
    UnknownVariant(u8),
}
impl DiveGasMode {
    pub fn from(content: u8) -> DiveGasMode {
        match content {
            0 => DiveGasMode::OpenCircuit,
            1 => DiveGasMode::ClosedCircuitDiluent,
            val => DiveGasMode::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::DiveGasMode(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ProjectileType {
    Arrow,
    RifleCartridge,
    PistolCartridge,
    Shotshell,
    AirRiflePellet,
    Other,
    UnknownVariant(u8),
}
impl ProjectileType {
    pub fn from(content: u8) -> ProjectileType {
        match content {
            0 => ProjectileType::Arrow,
            1 => ProjectileType::RifleCartridge,
            2 => ProjectileType::PistolCartridge,
            3 => ProjectileType::Shotshell,
            4 => ProjectileType::AirRiflePellet,
            5 => ProjectileType::Other,
            val => ProjectileType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ProjectileType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum SplitType {
    AscentSplit,
    DescentSplit,
    IntervalActive,
    IntervalRest,
    IntervalWarmup,
    IntervalCooldown,
    IntervalRecovery,
    IntervalOther,
    ClimbActive,
    ClimbRest,
    SurfActive,
    RunActive,
    RunRest,
    WorkoutRound,
    RwdRun,
    RwdWalk,
    WindsurfActive,
    RwdStand,
    Transition,
    SkiLiftSplit,
    SkiRunSplit,
    UnknownVariant(u8),
}
impl SplitType {
    pub fn from(content: u8) -> SplitType {
        match content {
            1 => SplitType::AscentSplit,
            2 => SplitType::DescentSplit,
            3 => SplitType::IntervalActive,
            4 => SplitType::IntervalRest,
            5 => SplitType::IntervalWarmup,
            6 => SplitType::IntervalCooldown,
            7 => SplitType::IntervalRecovery,
            8 => SplitType::IntervalOther,
            9 => SplitType::ClimbActive,
            10 => SplitType::ClimbRest,
            11 => SplitType::SurfActive,
            12 => SplitType::RunActive,
            13 => SplitType::RunRest,
            14 => SplitType::WorkoutRound,
            17 => SplitType::RwdRun,
            18 => SplitType::RwdWalk,
            21 => SplitType::WindsurfActive,
            22 => SplitType::RwdStand,
            23 => SplitType::Transition,
            28 => SplitType::SkiLiftSplit,
            29 => SplitType::SkiRunSplit,
            val => SplitType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::SplitType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ClimbProEvent {
    Approach,
    Start,
    Complete,
    UnknownVariant(u8),
}
impl ClimbProEvent {
    pub fn from(content: u8) -> ClimbProEvent {
        match content {
            0 => ClimbProEvent::Approach,
            1 => ClimbProEvent::Start,
            2 => ClimbProEvent::Complete,
            val => ClimbProEvent::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::ClimbProEvent(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum GasConsumptionRateType {
    PressureSac,
    VolumeSac,
    Rmv,
    UnknownVariant(u8),
}
impl GasConsumptionRateType {
    pub fn from(content: u8) -> GasConsumptionRateType {
        match content {
            0 => GasConsumptionRateType::PressureSac,
            1 => GasConsumptionRateType::VolumeSac,
            2 => GasConsumptionRateType::Rmv,
            val => GasConsumptionRateType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::GasConsumptionRateType(
                Self::from(reader.next_u8()?),
            )));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum TapSensitivity {
    High,
    Medium,
    Low,
    UnknownVariant(u8),
}
impl TapSensitivity {
    pub fn from(content: u8) -> TapSensitivity {
        match content {
            0 => TapSensitivity::High,
            1 => TapSensitivity::Medium,
            2 => TapSensitivity::Low,
            val => TapSensitivity::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::TapSensitivity(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum RadarThreatLevelType {
    ThreatUnknown,
    ThreatNone,
    ThreatApproaching,
    ThreatApproachingFast,
    UnknownVariant(u8),
}
impl RadarThreatLevelType {
    pub fn from(content: u8) -> RadarThreatLevelType {
        match content {
            0 => RadarThreatLevelType::ThreatUnknown,
            1 => RadarThreatLevelType::ThreatNone,
            2 => RadarThreatLevelType::ThreatApproaching,
            3 => RadarThreatLevelType::ThreatApproachingFast,
            val => RadarThreatLevelType::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::RadarThreatLevelType(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum MaxMetSpeedSource {
    OnboardGps,
    ConnectedGps,
    Cadence,
    UnknownVariant(u8),
}
impl MaxMetSpeedSource {
    pub fn from(content: u8) -> MaxMetSpeedSource {
        match content {
            0 => MaxMetSpeedSource::OnboardGps,
            1 => MaxMetSpeedSource::ConnectedGps,
            2 => MaxMetSpeedSource::Cadence,
            val => MaxMetSpeedSource::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::MaxMetSpeedSource(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum MaxMetHeartRateSource {
    Whr,
    Hrm,
    UnknownVariant(u8),
}
impl MaxMetHeartRateSource {
    pub fn from(content: u8) -> MaxMetHeartRateSource {
        match content {
            0 => MaxMetHeartRateSource::Whr,
            1 => MaxMetHeartRateSource::Hrm,
            val => MaxMetHeartRateSource::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::MaxMetHeartRateSource(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum HrvStatus {
    None,
    Poor,
    Low,
    Unbalanced,
    Balanced,
    UnknownVariant(u8),
}
impl HrvStatus {
    pub fn from(content: u8) -> HrvStatus {
        match content {
            0 => HrvStatus::None,
            1 => HrvStatus::Poor,
            2 => HrvStatus::Low,
            3 => HrvStatus::Unbalanced,
            4 => HrvStatus::Balanced,
            val => HrvStatus::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::HrvStatus(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum NoFlyTimeMode {
    Standard,
    Flat24Hours,
    UnknownVariant(u8),
}
impl NoFlyTimeMode {
    pub fn from(content: u8) -> NoFlyTimeMode {
        match content {
            0 => NoFlyTimeMode::Standard,
            1 => NoFlyTimeMode::Flat24Hours,
            val => NoFlyTimeMode::UnknownVariant(val),
        }
    }

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8,
    ) -> Result<Vec<DataValue>, DataTypeError> {
        let mut values = Vec::new();
        for _ in 0..number_of_bytes / 1 {
            values.push(DataValue::Enum(FitEnum::NoFlyTimeMode(Self::from(
                reader.next_u8()?,
            ))));
        }
        Ok(values)
    }
}

impl FitBaseType {
    pub fn get_parse_fn(
        &self,
    ) -> fn(&mut Reader, &Endianness, u8) -> Result<Vec<DataValue>, DataTypeError> {
        match self {
            Self::Byte => parse_byte,
            Self::Enum => parse_unknown,
            Self::Float32 => parse_float32,
            Self::Float64 => parse_float64,
            Self::Sint8 => parse_sint8,
            Self::Sint16 => parse_sint16,
            Self::Sint32 => parse_sint32,
            Self::Sint64 => parse_sint64,
            Self::String => parse_string,
            Self::Uint8 => parse_uint8,
            Self::Uint8z => parse_uint8z,
            Self::Uint16 => parse_uint16,
            Self::Uint16z => parse_uint16z,
            Self::Uint32 => parse_uint32,
            Self::Uint32z => parse_uint32z,
            Self::Uint64 => parse_uint64,
            Self::Uint64z => parse_uint64z,
            Self::UnknownVariant(_) => parse_unknown,
        }
    }
}

#[derive(Debug, Clone)]
pub enum ParseFunction {
    Simple(fn(&mut Reader, &Endianness, u8) -> Result<Vec<DataValue>, DataTypeError>),
    Dynamic(
        fn(
            &mut Reader,
            &Endianness,
            u8,
            &[DataMessageField],
        ) -> Result<Vec<DataValue>, DataTypeError>,
    ),
}

#[derive(Debug, PartialEq, Clone)]
pub enum FitMessage {
    FileId(FileIdField),
    FileCreator(FileCreatorField),
    TimestampCorrelation(TimestampCorrelationField),
    Software(SoftwareField),
    SlaveDevice(SlaveDeviceField),
    Capabilities(CapabilitiesField),
    FileCapabilities(FileCapabilitiesField),
    MesgCapabilities(MesgCapabilitiesField),
    FieldCapabilities(FieldCapabilitiesField),
    DeviceSettings(DeviceSettingsField),
    UserProfile(UserProfileField),
    HrmProfile(HrmProfileField),
    SdmProfile(SdmProfileField),
    BikeProfile(BikeProfileField),
    Connectivity(ConnectivityField),
    WatchfaceSettings(WatchfaceSettingsField),
    OhrSettings(OhrSettingsField),
    TimeInZone(TimeInZoneField),
    ZonesTarget(ZonesTargetField),
    Sport(SportField),
    HrZone(HrZoneField),
    SpeedZone(SpeedZoneField),
    CadenceZone(CadenceZoneField),
    PowerZone(PowerZoneField),
    MetZone(MetZoneField),
    TrainingSettings(TrainingSettingsField),
    DiveSettings(DiveSettingsField),
    DiveAlarm(DiveAlarmField),
    DiveApneaAlarm(DiveApneaAlarmField),
    DiveGas(DiveGasField),
    Goal(GoalField),
    Activity(ActivityField),
    Session(SessionField),
    Lap(LapField),
    Length(LengthField),
    Record(RecordField),
    Event(EventField),
    DeviceInfo(DeviceInfoField),
    DeviceAuxBatteryInfo(DeviceAuxBatteryInfoField),
    TrainingFile(TrainingFileField),
    WeatherConditions(WeatherConditionsField),
    WeatherAlert(WeatherAlertField),
    GpsMetadata(GpsMetadataField),
    CameraEvent(CameraEventField),
    GyroscopeData(GyroscopeDataField),
    AccelerometerData(AccelerometerDataField),
    MagnetometerData(MagnetometerDataField),
    BarometerData(BarometerDataField),
    ThreeDSensorCalibration(ThreeDSensorCalibrationField),
    OneDSensorCalibration(OneDSensorCalibrationField),
    VideoFrame(VideoFrameField),
    ObdiiData(ObdiiDataField),
    NmeaSentence(NmeaSentenceField),
    AviationAttitude(AviationAttitudeField),
    Video(VideoField),
    VideoTitle(VideoTitleField),
    VideoDescription(VideoDescriptionField),
    VideoClip(VideoClipField),
    Set(SetField),
    Jump(JumpField),
    Split(SplitField),
    SplitSummary(SplitSummaryField),
    ClimbPro(ClimbProField),
    FieldDescription(FieldDescriptionField),
    DeveloperDataId(DeveloperDataIdField),
    Course(CourseField),
    CoursePoint(CoursePointField),
    SegmentId(SegmentIdField),
    SegmentLeaderboardEntry(SegmentLeaderboardEntryField),
    SegmentPoint(SegmentPointField),
    SegmentLap(SegmentLapField),
    SegmentFile(SegmentFileField),
    Workout(WorkoutField),
    WorkoutSession(WorkoutSessionField),
    WorkoutStep(WorkoutStepField),
    ExerciseTitle(ExerciseTitleField),
    Schedule(ScheduleField),
    Totals(TotalsField),
    WeightScale(WeightScaleField),
    BloodPressure(BloodPressureField),
    MonitoringInfo(MonitoringInfoField),
    Monitoring(MonitoringField),
    MonitoringHrData(MonitoringHrDataField),
    Spo2Data(Spo2DataField),
    Hr(HrField),
    StressLevel(StressLevelField),
    MaxMetData(MaxMetDataField),
    HsaBodyBatteryData(HsaBodyBatteryDataField),
    HsaEvent(HsaEventField),
    HsaAccelerometerData(HsaAccelerometerDataField),
    HsaGyroscopeData(HsaGyroscopeDataField),
    HsaStepData(HsaStepDataField),
    HsaSpo2Data(HsaSpo2DataField),
    HsaStressData(HsaStressDataField),
    HsaRespirationData(HsaRespirationDataField),
    HsaHeartRateData(HsaHeartRateDataField),
    HsaConfigurationData(HsaConfigurationDataField),
    HsaWristTemperatureData(HsaWristTemperatureDataField),
    MemoGlob(MemoGlobField),
    SleepLevel(SleepLevelField),
    AntChannelId(AntChannelIdField),
    AntRx(AntRxField),
    AntTx(AntTxField),
    ExdScreenConfiguration(ExdScreenConfigurationField),
    ExdDataFieldConfiguration(ExdDataFieldConfigurationField),
    ExdDataConceptConfiguration(ExdDataConceptConfigurationField),
    DiveSummary(DiveSummaryField),
    AadAccelFeatures(AadAccelFeaturesField),
    Hrv(HrvField),
    BeatIntervals(BeatIntervalsField),
    HrvStatusSummary(HrvStatusSummaryField),
    HrvValue(HrvValueField),
    RawBbi(RawBbiField),
    RespirationRate(RespirationRateField),
    ChronoShotSession(ChronoShotSessionField),
    ChronoShotData(ChronoShotDataField),
    TankUpdate(TankUpdateField),
    TankSummary(TankSummaryField),
    SleepAssessment(SleepAssessmentField),
    SkinTempOvernight(SkinTempOvernightField),
    Custom(CustomField),
    UnknownVariant(u8),
}

#[derive(Debug, PartialEq, Clone)]
pub struct CustomField {
    pub name: Option<String>,
    pub units: Option<String>,
}
#[derive(Debug, PartialEq, Clone)]
pub enum FileIdField {
    Type,
    Manufacturer,
    Product,
    SerialNumber,
    TimeCreated,
    Number,
    ProductName,
    Unknown,
}
impl FileIdField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::Type,
            1 => Self::Manufacturer,
            2 => Self::Product,
            3 => Self::SerialNumber,
            4 => Self::TimeCreated,
            5 => Self::Number,
            8 => Self::ProductName,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(File::parse),
            1 => ParseFunction::Simple(Manufacturer::parse),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_unknown),
            4 => ParseFunction::Simple(DateTime::parse),
            5 => ParseFunction::Simple(parse_uint16),
            8 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum FileCreatorField {
    SoftwareVersion,
    HardwareVersion,
    Unknown,
}
impl FileCreatorField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::SoftwareVersion,
            1 => Self::HardwareVersion,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum TimestampCorrelationField {
    Timestamp,
    FractionalTimestamp,
    SystemTimestamp,
    FractionalSystemTimestamp,
    LocalTimestamp,
    TimestampMs,
    SystemTimestampMs,
    Unknown,
}
impl TimestampCorrelationField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::FractionalTimestamp,
            1 => Self::SystemTimestamp,
            2 => Self::FractionalSystemTimestamp,
            3 => Self::LocalTimestamp,
            4 => Self::TimestampMs,
            5 => Self::SystemTimestampMs,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(DateTime::parse),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(LocalDateTime::parse),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 32768_f32,
                offset: 0_f32,
            }),
            2 => Some(ScaleOffset {
                scale: 32768_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::TimestampCorrelation(
            TimestampCorrelationField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SoftwareField {
    MessageIndex,
    Version,
    PartNumber,
    Unknown,
}
impl SoftwareField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            3 => Self::Version,
            5 => Self::PartNumber,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            3 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            3 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SlaveDeviceField {
    Manufacturer,
    Product,
    Unknown,
}
impl SlaveDeviceField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::Manufacturer,
            1 => Self::Product,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(Manufacturer::parse),
            1 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum CapabilitiesField {
    Languages,
    Sports,
    WorkoutsSupported,
    ConnectivitySupported,
    Unknown,
}
impl CapabilitiesField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::Languages,
            1 => Self::Sports,
            21 => Self::WorkoutsSupported,
            23 => Self::ConnectivitySupported,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_unknown),
            1 => ParseFunction::Simple(SportBits0::parse),
            21 => ParseFunction::Simple(WorkoutCapabilities::parse),
            23 => ParseFunction::Simple(ConnectivityCapabilities::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum FileCapabilitiesField {
    MessageIndex,
    Type,
    Flags,
    Directory,
    MaxCount,
    MaxSize,
    Unknown,
}
impl FileCapabilitiesField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Type,
            1 => Self::Flags,
            2 => Self::Directory,
            3 => Self::MaxCount,
            4 => Self::MaxSize,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(File::parse),
            1 => ParseFunction::Simple(FileFlags::parse),
            2 => ParseFunction::Simple(parse_string),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum MesgCapabilitiesField {
    MessageIndex,
    File,
    MesgNum,
    CountType,
    Count,
    Unknown,
}
impl MesgCapabilitiesField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::File,
            1 => Self::MesgNum,
            2 => Self::CountType,
            3 => Self::Count,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(File::parse),
            1 => ParseFunction::Simple(MesgNum::parse),
            2 => ParseFunction::Simple(MesgCount::parse),
            3 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum FieldCapabilitiesField {
    MessageIndex,
    File,
    MesgNum,
    FieldNum,
    Count,
    Unknown,
}
impl FieldCapabilitiesField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::File,
            1 => Self::MesgNum,
            2 => Self::FieldNum,
            3 => Self::Count,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(File::parse),
            1 => ParseFunction::Simple(MesgNum::parse),
            2 => ParseFunction::Simple(parse_uint8),
            3 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DeviceSettingsField {
    ActiveTimeZone,
    UtcOffset,
    TimeOffset,
    TimeMode,
    TimeZoneOffset,
    BacklightMode,
    ActivityTrackerEnabled,
    ClockTime,
    PagesEnabled,
    MoveAlertEnabled,
    DateMode,
    DisplayOrientation,
    MountingSide,
    DefaultPage,
    AutosyncMinSteps,
    AutosyncMinTime,
    LactateThresholdAutodetectEnabled,
    BleAutoUploadEnabled,
    AutoSyncFrequency,
    AutoActivityDetect,
    NumberOfScreens,
    SmartNotificationDisplayOrientation,
    TapInterface,
    TapSensitivity,
    Unknown,
}
impl DeviceSettingsField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::ActiveTimeZone,
            1 => Self::UtcOffset,
            2 => Self::TimeOffset,
            4 => Self::TimeMode,
            5 => Self::TimeZoneOffset,
            12 => Self::BacklightMode,
            36 => Self::ActivityTrackerEnabled,
            39 => Self::ClockTime,
            40 => Self::PagesEnabled,
            46 => Self::MoveAlertEnabled,
            47 => Self::DateMode,
            55 => Self::DisplayOrientation,
            56 => Self::MountingSide,
            57 => Self::DefaultPage,
            58 => Self::AutosyncMinSteps,
            59 => Self::AutosyncMinTime,
            80 => Self::LactateThresholdAutodetectEnabled,
            86 => Self::BleAutoUploadEnabled,
            89 => Self::AutoSyncFrequency,
            90 => Self::AutoActivityDetect,
            94 => Self::NumberOfScreens,
            95 => Self::SmartNotificationDisplayOrientation,
            134 => Self::TapInterface,
            174 => Self::TapSensitivity,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_uint32),
            2 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(TimeMode::parse),
            5 => ParseFunction::Simple(parse_sint8),
            12 => ParseFunction::Simple(BacklightMode::parse),
            36 => ParseFunction::Simple(parse_unknown),
            39 => ParseFunction::Simple(DateTime::parse),
            40 => ParseFunction::Simple(parse_uint16),
            46 => ParseFunction::Simple(parse_unknown),
            47 => ParseFunction::Simple(DateMode::parse),
            55 => ParseFunction::Simple(DisplayOrientation::parse),
            56 => ParseFunction::Simple(Side::parse),
            57 => ParseFunction::Simple(parse_uint16),
            58 => ParseFunction::Simple(parse_uint16),
            59 => ParseFunction::Simple(parse_uint16),
            80 => ParseFunction::Simple(parse_unknown),
            86 => ParseFunction::Simple(parse_unknown),
            89 => ParseFunction::Simple(AutoSyncFrequency::parse),
            90 => ParseFunction::Simple(AutoActivityDetect::parse),
            94 => ParseFunction::Simple(parse_uint8),
            95 => ParseFunction::Simple(DisplayOrientation::parse),
            134 => ParseFunction::Simple(Switch::parse),
            174 => ParseFunction::Simple(TapSensitivity::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            5 => Some(ScaleOffset {
                scale: 4_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum UserProfileField {
    MessageIndex,
    FriendlyName,
    Gender,
    Age,
    Height,
    Weight,
    Language,
    ElevSetting,
    WeightSetting,
    RestingHeartRate,
    DefaultMaxRunningHeartRate,
    DefaultMaxBikingHeartRate,
    DefaultMaxHeartRate,
    HrSetting,
    SpeedSetting,
    DistSetting,
    PowerSetting,
    ActivityClass,
    PositionSetting,
    TemperatureSetting,
    LocalId,
    GlobalId,
    WakeTime,
    SleepTime,
    HeightSetting,
    UserRunningStepLength,
    UserWalkingStepLength,
    DepthSetting,
    DiveCount,
    Unknown,
}
impl UserProfileField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::FriendlyName,
            1 => Self::Gender,
            2 => Self::Age,
            3 => Self::Height,
            4 => Self::Weight,
            5 => Self::Language,
            6 => Self::ElevSetting,
            7 => Self::WeightSetting,
            8 => Self::RestingHeartRate,
            9 => Self::DefaultMaxRunningHeartRate,
            10 => Self::DefaultMaxBikingHeartRate,
            11 => Self::DefaultMaxHeartRate,
            12 => Self::HrSetting,
            13 => Self::SpeedSetting,
            14 => Self::DistSetting,
            16 => Self::PowerSetting,
            17 => Self::ActivityClass,
            18 => Self::PositionSetting,
            21 => Self::TemperatureSetting,
            22 => Self::LocalId,
            23 => Self::GlobalId,
            28 => Self::WakeTime,
            29 => Self::SleepTime,
            30 => Self::HeightSetting,
            31 => Self::UserRunningStepLength,
            32 => Self::UserWalkingStepLength,
            47 => Self::DepthSetting,
            49 => Self::DiveCount,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_string),
            1 => ParseFunction::Simple(Gender::parse),
            2 => ParseFunction::Simple(parse_uint8),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(Language::parse),
            6 => ParseFunction::Simple(DisplayMeasure::parse),
            7 => ParseFunction::Simple(DisplayMeasure::parse),
            8 => ParseFunction::Simple(parse_uint8),
            9 => ParseFunction::Simple(parse_uint8),
            10 => ParseFunction::Simple(parse_uint8),
            11 => ParseFunction::Simple(parse_uint8),
            12 => ParseFunction::Simple(DisplayHeart::parse),
            13 => ParseFunction::Simple(DisplayMeasure::parse),
            14 => ParseFunction::Simple(DisplayMeasure::parse),
            16 => ParseFunction::Simple(DisplayPower::parse),
            17 => ParseFunction::Simple(ActivityClass::parse),
            18 => ParseFunction::Simple(DisplayPosition::parse),
            21 => ParseFunction::Simple(DisplayMeasure::parse),
            22 => ParseFunction::Simple(UserLocalId::parse),
            23 => ParseFunction::Simple(parse_byte),
            28 => ParseFunction::Simple(LocaltimeIntoDay::parse),
            29 => ParseFunction::Simple(LocaltimeIntoDay::parse),
            30 => ParseFunction::Simple(DisplayMeasure::parse),
            31 => ParseFunction::Simple(parse_uint16),
            32 => ParseFunction::Simple(parse_uint16),
            47 => ParseFunction::Simple(DisplayMeasure::parse),
            49 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            3 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            31 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            32 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HrmProfileField {
    MessageIndex,
    Enabled,
    HrmAntId,
    LogHrv,
    HrmAntIdTransType,
    Unknown,
}
impl HrmProfileField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Enabled,
            1 => Self::HrmAntId,
            2 => Self::LogHrv,
            3 => Self::HrmAntIdTransType,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_unknown),
            1 => ParseFunction::Simple(parse_unknown),
            2 => ParseFunction::Simple(parse_unknown),
            3 => ParseFunction::Simple(parse_unknown),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SdmProfileField {
    MessageIndex,
    Enabled,
    SdmAntId,
    SdmCalFactor,
    Odometer,
    SpeedSource,
    SdmAntIdTransType,
    OdometerRollover,
    Unknown,
}
impl SdmProfileField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Enabled,
            1 => Self::SdmAntId,
            2 => Self::SdmCalFactor,
            3 => Self::Odometer,
            4 => Self::SpeedSource,
            5 => Self::SdmAntIdTransType,
            7 => Self::OdometerRollover,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_unknown),
            1 => ParseFunction::Simple(parse_unknown),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_unknown),
            5 => ParseFunction::Simple(parse_unknown),
            7 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum BikeProfileField {
    MessageIndex,
    Name,
    Sport,
    SubSport,
    Odometer,
    BikeSpdAntId,
    BikeCadAntId,
    BikeSpdcadAntId,
    BikePowerAntId,
    CustomWheelsize,
    AutoWheelsize,
    BikeWeight,
    PowerCalFactor,
    AutoWheelCal,
    AutoPowerZero,
    Id,
    SpdEnabled,
    CadEnabled,
    SpdcadEnabled,
    PowerEnabled,
    CrankLength,
    Enabled,
    BikeSpdAntIdTransType,
    BikeCadAntIdTransType,
    BikeSpdcadAntIdTransType,
    BikePowerAntIdTransType,
    OdometerRollover,
    FrontGearNum,
    FrontGear,
    RearGearNum,
    RearGear,
    ShimanoDi2Enabled,
    Unknown,
}
impl BikeProfileField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Name,
            1 => Self::Sport,
            2 => Self::SubSport,
            3 => Self::Odometer,
            4 => Self::BikeSpdAntId,
            5 => Self::BikeCadAntId,
            6 => Self::BikeSpdcadAntId,
            7 => Self::BikePowerAntId,
            8 => Self::CustomWheelsize,
            9 => Self::AutoWheelsize,
            10 => Self::BikeWeight,
            11 => Self::PowerCalFactor,
            12 => Self::AutoWheelCal,
            13 => Self::AutoPowerZero,
            14 => Self::Id,
            15 => Self::SpdEnabled,
            16 => Self::CadEnabled,
            17 => Self::SpdcadEnabled,
            18 => Self::PowerEnabled,
            19 => Self::CrankLength,
            20 => Self::Enabled,
            21 => Self::BikeSpdAntIdTransType,
            22 => Self::BikeCadAntIdTransType,
            23 => Self::BikeSpdcadAntIdTransType,
            24 => Self::BikePowerAntIdTransType,
            37 => Self::OdometerRollover,
            38 => Self::FrontGearNum,
            39 => Self::FrontGear,
            40 => Self::RearGearNum,
            41 => Self::RearGear,
            44 => Self::ShimanoDi2Enabled,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_string),
            1 => ParseFunction::Simple(Sport::parse),
            2 => ParseFunction::Simple(SubSport::parse),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_unknown),
            5 => ParseFunction::Simple(parse_unknown),
            6 => ParseFunction::Simple(parse_unknown),
            7 => ParseFunction::Simple(parse_unknown),
            8 => ParseFunction::Simple(parse_uint16),
            9 => ParseFunction::Simple(parse_uint16),
            10 => ParseFunction::Simple(parse_uint16),
            11 => ParseFunction::Simple(parse_uint16),
            12 => ParseFunction::Simple(parse_unknown),
            13 => ParseFunction::Simple(parse_unknown),
            14 => ParseFunction::Simple(parse_uint8),
            15 => ParseFunction::Simple(parse_unknown),
            16 => ParseFunction::Simple(parse_unknown),
            17 => ParseFunction::Simple(parse_unknown),
            18 => ParseFunction::Simple(parse_unknown),
            19 => ParseFunction::Simple(parse_uint8),
            20 => ParseFunction::Simple(parse_unknown),
            21 => ParseFunction::Simple(parse_unknown),
            22 => ParseFunction::Simple(parse_unknown),
            23 => ParseFunction::Simple(parse_unknown),
            24 => ParseFunction::Simple(parse_unknown),
            37 => ParseFunction::Simple(parse_uint8),
            38 => ParseFunction::Simple(parse_unknown),
            39 => ParseFunction::Simple(parse_unknown),
            40 => ParseFunction::Simple(parse_unknown),
            41 => ParseFunction::Simple(parse_unknown),
            44 => ParseFunction::Simple(parse_unknown),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            3 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            8 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            9 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            10 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            11 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            19 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ConnectivityField {
    BluetoothEnabled,
    BluetoothLeEnabled,
    AntEnabled,
    Name,
    LiveTrackingEnabled,
    WeatherConditionsEnabled,
    WeatherAlertsEnabled,
    AutoActivityUploadEnabled,
    CourseDownloadEnabled,
    WorkoutDownloadEnabled,
    GpsEphemerisDownloadEnabled,
    IncidentDetectionEnabled,
    GrouptrackEnabled,
    Unknown,
}
impl ConnectivityField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::BluetoothEnabled,
            1 => Self::BluetoothLeEnabled,
            2 => Self::AntEnabled,
            3 => Self::Name,
            4 => Self::LiveTrackingEnabled,
            5 => Self::WeatherConditionsEnabled,
            6 => Self::WeatherAlertsEnabled,
            7 => Self::AutoActivityUploadEnabled,
            8 => Self::CourseDownloadEnabled,
            9 => Self::WorkoutDownloadEnabled,
            10 => Self::GpsEphemerisDownloadEnabled,
            11 => Self::IncidentDetectionEnabled,
            12 => Self::GrouptrackEnabled,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_unknown),
            1 => ParseFunction::Simple(parse_unknown),
            2 => ParseFunction::Simple(parse_unknown),
            3 => ParseFunction::Simple(parse_string),
            4 => ParseFunction::Simple(parse_unknown),
            5 => ParseFunction::Simple(parse_unknown),
            6 => ParseFunction::Simple(parse_unknown),
            7 => ParseFunction::Simple(parse_unknown),
            8 => ParseFunction::Simple(parse_unknown),
            9 => ParseFunction::Simple(parse_unknown),
            10 => ParseFunction::Simple(parse_unknown),
            11 => ParseFunction::Simple(parse_unknown),
            12 => ParseFunction::Simple(parse_unknown),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum WatchfaceSettingsField {
    MessageIndex,
    Mode,
    Layout,
    Unknown,
}
impl WatchfaceSettingsField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Mode,
            1 => Self::Layout,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(WatchfaceMode::parse),
            1 => ParseFunction::Simple(parse_byte),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum OhrSettingsField {
    Timestamp,
    Enabled,
    Unknown,
}
impl OhrSettingsField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Enabled,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(Switch::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::OhrSettings(OhrSettingsField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum TimeInZoneField {
    Timestamp,
    ReferenceMesg,
    ReferenceIndex,
    TimeInHrZone,
    TimeInSpeedZone,
    TimeInCadenceZone,
    TimeInPowerZone,
    HrZoneHighBoundary,
    SpeedZoneHighBoundary,
    CadenceZoneHighBondary,
    PowerZoneHighBoundary,
    HrCalcType,
    MaxHeartRate,
    RestingHeartRate,
    ThresholdHeartRate,
    PwrCalcType,
    FunctionalThresholdPower,
    Unknown,
}
impl TimeInZoneField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ReferenceMesg,
            1 => Self::ReferenceIndex,
            2 => Self::TimeInHrZone,
            3 => Self::TimeInSpeedZone,
            4 => Self::TimeInCadenceZone,
            5 => Self::TimeInPowerZone,
            6 => Self::HrZoneHighBoundary,
            7 => Self::SpeedZoneHighBoundary,
            8 => Self::CadenceZoneHighBondary,
            9 => Self::PowerZoneHighBoundary,
            10 => Self::HrCalcType,
            11 => Self::MaxHeartRate,
            12 => Self::RestingHeartRate,
            13 => Self::ThresholdHeartRate,
            14 => Self::PwrCalcType,
            15 => Self::FunctionalThresholdPower,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(MesgNum::parse),
            1 => ParseFunction::Simple(MessageIndex::parse),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(parse_uint16),
            8 => ParseFunction::Simple(parse_uint8),
            9 => ParseFunction::Simple(parse_uint16),
            10 => ParseFunction::Simple(HrZoneCalc::parse),
            11 => ParseFunction::Simple(parse_uint8),
            12 => ParseFunction::Simple(parse_uint8),
            13 => ParseFunction::Simple(parse_uint8),
            14 => ParseFunction::Simple(PwrZoneCalc::parse),
            15 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            7 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::TimeInZone(TimeInZoneField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ZonesTargetField {
    MaxHeartRate,
    ThresholdHeartRate,
    FunctionalThresholdPower,
    HrCalcType,
    PwrCalcType,
    Unknown,
}
impl ZonesTargetField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            1 => Self::MaxHeartRate,
            2 => Self::ThresholdHeartRate,
            3 => Self::FunctionalThresholdPower,
            5 => Self::HrCalcType,
            7 => Self::PwrCalcType,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(parse_uint8),
            3 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(HrZoneCalc::parse),
            7 => ParseFunction::Simple(PwrZoneCalc::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SportField {
    Sport,
    SubSport,
    Name,
    Unknown,
}
impl SportField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::Sport,
            1 => Self::SubSport,
            3 => Self::Name,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(Sport::parse),
            1 => ParseFunction::Simple(SubSport::parse),
            3 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HrZoneField {
    MessageIndex,
    HighBpm,
    Name,
    Unknown,
}
impl HrZoneField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            1 => Self::HighBpm,
            2 => Self::Name,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SpeedZoneField {
    MessageIndex,
    HighValue,
    Name,
    Unknown,
}
impl SpeedZoneField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::HighValue,
            1 => Self::Name,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum CadenceZoneField {
    MessageIndex,
    HighValue,
    Name,
    Unknown,
}
impl CadenceZoneField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::HighValue,
            1 => Self::Name,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum PowerZoneField {
    MessageIndex,
    HighValue,
    Name,
    Unknown,
}
impl PowerZoneField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            1 => Self::HighValue,
            2 => Self::Name,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum MetZoneField {
    MessageIndex,
    HighBpm,
    Calories,
    FatCalories,
    Unknown,
}
impl MetZoneField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            1 => Self::HighBpm,
            2 => Self::Calories,
            3 => Self::FatCalories,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum TrainingSettingsField {
    TargetDistance,
    TargetSpeed,
    TargetTime,
    PreciseTargetSpeed,
    Unknown,
}
impl TrainingSettingsField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            31 => Self::TargetDistance,
            32 => Self::TargetSpeed,
            33 => Self::TargetTime,
            153 => Self::PreciseTargetSpeed,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            31 => ParseFunction::Simple(parse_uint32),
            32 => ParseFunction::Simple(parse_uint16),
            33 => ParseFunction::Simple(parse_uint32),
            153 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            31 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            32 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            153 => Some(ScaleOffset {
                scale: 1000000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DiveSettingsField {
    Timestamp,
    MessageIndex,
    Name,
    Model,
    GfLow,
    GfHigh,
    WaterType,
    WaterDensity,
    Po2Warn,
    Po2Critical,
    Po2Deco,
    SafetyStopEnabled,
    BottomDepth,
    BottomTime,
    ApneaCountdownEnabled,
    ApneaCountdownTime,
    BacklightMode,
    BacklightBrightness,
    BacklightTimeout,
    RepeatDiveInterval,
    SafetyStopTime,
    HeartRateSourceType,
    HeartRateSource,
    TravelGas,
    CcrLowSetpointSwitchMode,
    CcrLowSetpoint,
    CcrLowSetpointDepth,
    CcrHighSetpointSwitchMode,
    CcrHighSetpoint,
    CcrHighSetpointDepth,
    GasConsumptionDisplay,
    UpKeyEnabled,
    DiveSounds,
    LastStopMultiple,
    NoFlyTimeMode,
    Unknown,
}
impl DiveSettingsField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            254 => Self::MessageIndex,
            0 => Self::Name,
            1 => Self::Model,
            2 => Self::GfLow,
            3 => Self::GfHigh,
            4 => Self::WaterType,
            5 => Self::WaterDensity,
            6 => Self::Po2Warn,
            7 => Self::Po2Critical,
            8 => Self::Po2Deco,
            9 => Self::SafetyStopEnabled,
            10 => Self::BottomDepth,
            11 => Self::BottomTime,
            12 => Self::ApneaCountdownEnabled,
            13 => Self::ApneaCountdownTime,
            14 => Self::BacklightMode,
            15 => Self::BacklightBrightness,
            16 => Self::BacklightTimeout,
            17 => Self::RepeatDiveInterval,
            18 => Self::SafetyStopTime,
            19 => Self::HeartRateSourceType,
            20 => Self::HeartRateSource,
            21 => Self::TravelGas,
            22 => Self::CcrLowSetpointSwitchMode,
            23 => Self::CcrLowSetpoint,
            24 => Self::CcrLowSetpointDepth,
            25 => Self::CcrHighSetpointSwitchMode,
            26 => Self::CcrHighSetpoint,
            27 => Self::CcrHighSetpointDepth,
            29 => Self::GasConsumptionDisplay,
            30 => Self::UpKeyEnabled,
            35 => Self::DiveSounds,
            36 => Self::LastStopMultiple,
            37 => Self::NoFlyTimeMode,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_string),
            1 => ParseFunction::Simple(TissueModelType::parse),
            2 => ParseFunction::Simple(parse_uint8),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(WaterType::parse),
            5 => ParseFunction::Simple(parse_float32),
            6 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(parse_uint8),
            8 => ParseFunction::Simple(parse_uint8),
            9 => ParseFunction::Simple(parse_unknown),
            10 => ParseFunction::Simple(parse_float32),
            11 => ParseFunction::Simple(parse_uint32),
            12 => ParseFunction::Simple(parse_unknown),
            13 => ParseFunction::Simple(parse_uint32),
            14 => ParseFunction::Simple(DiveBacklightMode::parse),
            15 => ParseFunction::Simple(parse_uint8),
            16 => ParseFunction::Simple(BacklightTimeout::parse),
            17 => ParseFunction::Simple(parse_uint16),
            18 => ParseFunction::Simple(parse_uint16),
            19 => ParseFunction::Simple(SourceType::parse),
            20 => ParseFunction::Simple(parse_uint8),
            21 => ParseFunction::Simple(MessageIndex::parse),
            22 => ParseFunction::Simple(CcrSetpointSwitchMode::parse),
            23 => ParseFunction::Simple(parse_uint8),
            24 => ParseFunction::Simple(parse_uint32),
            25 => ParseFunction::Simple(CcrSetpointSwitchMode::parse),
            26 => ParseFunction::Simple(parse_uint8),
            27 => ParseFunction::Simple(parse_uint32),
            29 => ParseFunction::Simple(GasConsumptionRateType::parse),
            30 => ParseFunction::Simple(parse_unknown),
            35 => ParseFunction::Simple(Tone::parse),
            36 => ParseFunction::Simple(parse_uint8),
            37 => ParseFunction::Simple(NoFlyTimeMode::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            6 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            7 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            8 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            17 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            18 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            23 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            24 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            26 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            27 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            36 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::DiveSettings(DiveSettingsField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DiveAlarmField {
    MessageIndex,
    Depth,
    Time,
    Enabled,
    AlarmType,
    Sound,
    DiveTypes,
    Id,
    PopupEnabled,
    TriggerOnDescent,
    TriggerOnAscent,
    Repeating,
    Speed,
    Unknown,
}
impl DiveAlarmField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Depth,
            1 => Self::Time,
            2 => Self::Enabled,
            3 => Self::AlarmType,
            4 => Self::Sound,
            5 => Self::DiveTypes,
            6 => Self::Id,
            7 => Self::PopupEnabled,
            8 => Self::TriggerOnDescent,
            9 => Self::TriggerOnAscent,
            10 => Self::Repeating,
            11 => Self::Speed,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_uint32),
            1 => ParseFunction::Simple(parse_sint32),
            2 => ParseFunction::Simple(parse_unknown),
            3 => ParseFunction::Simple(DiveAlarmType::parse),
            4 => ParseFunction::Simple(Tone::parse),
            5 => ParseFunction::Simple(SubSport::parse),
            6 => ParseFunction::Simple(parse_uint32),
            7 => ParseFunction::Simple(parse_unknown),
            8 => ParseFunction::Simple(parse_unknown),
            9 => ParseFunction::Simple(parse_unknown),
            10 => ParseFunction::Simple(parse_unknown),
            11 => ParseFunction::Simple(parse_sint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            1 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            11 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DiveApneaAlarmField {
    MessageIndex,
    Depth,
    Time,
    Enabled,
    AlarmType,
    Sound,
    DiveTypes,
    Id,
    PopupEnabled,
    TriggerOnDescent,
    TriggerOnAscent,
    Repeating,
    Speed,
    Unknown,
}
impl DiveApneaAlarmField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Depth,
            1 => Self::Time,
            2 => Self::Enabled,
            3 => Self::AlarmType,
            4 => Self::Sound,
            5 => Self::DiveTypes,
            6 => Self::Id,
            7 => Self::PopupEnabled,
            8 => Self::TriggerOnDescent,
            9 => Self::TriggerOnAscent,
            10 => Self::Repeating,
            11 => Self::Speed,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_uint32),
            1 => ParseFunction::Simple(parse_sint32),
            2 => ParseFunction::Simple(parse_unknown),
            3 => ParseFunction::Simple(DiveAlarmType::parse),
            4 => ParseFunction::Simple(Tone::parse),
            5 => ParseFunction::Simple(SubSport::parse),
            6 => ParseFunction::Simple(parse_uint32),
            7 => ParseFunction::Simple(parse_unknown),
            8 => ParseFunction::Simple(parse_unknown),
            9 => ParseFunction::Simple(parse_unknown),
            10 => ParseFunction::Simple(parse_unknown),
            11 => ParseFunction::Simple(parse_sint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            1 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            11 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DiveGasField {
    MessageIndex,
    HeliumContent,
    OxygenContent,
    Status,
    Mode,
    Unknown,
}
impl DiveGasField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::HeliumContent,
            1 => Self::OxygenContent,
            2 => Self::Status,
            3 => Self::Mode,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(DiveGasStatus::parse),
            3 => ParseFunction::Simple(DiveGasMode::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum GoalField {
    MessageIndex,
    Sport,
    SubSport,
    StartDate,
    EndDate,
    Type,
    Value,
    Repeat,
    TargetValue,
    Recurrence,
    RecurrenceValue,
    Enabled,
    Source,
    Unknown,
}
impl GoalField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Sport,
            1 => Self::SubSport,
            2 => Self::StartDate,
            3 => Self::EndDate,
            4 => Self::Type,
            5 => Self::Value,
            6 => Self::Repeat,
            7 => Self::TargetValue,
            8 => Self::Recurrence,
            9 => Self::RecurrenceValue,
            10 => Self::Enabled,
            11 => Self::Source,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(Sport::parse),
            1 => ParseFunction::Simple(SubSport::parse),
            2 => ParseFunction::Simple(DateTime::parse),
            3 => ParseFunction::Simple(DateTime::parse),
            4 => ParseFunction::Simple(Goal::parse),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(parse_unknown),
            7 => ParseFunction::Simple(parse_uint32),
            8 => ParseFunction::Simple(GoalRecurrence::parse),
            9 => ParseFunction::Simple(parse_uint16),
            10 => ParseFunction::Simple(parse_unknown),
            11 => ParseFunction::Simple(GoalSource::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ActivityField {
    Timestamp,
    TotalTimerTime,
    NumSessions,
    Type,
    Event,
    EventType,
    LocalTimestamp,
    EventGroup,
    Unknown,
}
impl ActivityField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TotalTimerTime,
            1 => Self::NumSessions,
            2 => Self::Type,
            3 => Self::Event,
            4 => Self::EventType,
            5 => Self::LocalTimestamp,
            6 => Self::EventGroup,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint32),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(Activity::parse),
            3 => ParseFunction::Simple(Event::parse),
            4 => ParseFunction::Simple(EventType::parse),
            5 => ParseFunction::Simple(LocalDateTime::parse),
            6 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Activity(ActivityField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SessionField {
    MessageIndex,
    Timestamp,
    Event,
    EventType,
    StartTime,
    StartPositionLat,
    StartPositionLong,
    Sport,
    SubSport,
    TotalElapsedTime,
    TotalTimerTime,
    TotalDistance,
    TotalCycles,
    TotalCalories,
    TotalFatCalories,
    AvgSpeed,
    MaxSpeed,
    AvgHeartRate,
    MaxHeartRate,
    AvgCadence,
    MaxCadence,
    AvgPower,
    MaxPower,
    TotalAscent,
    TotalDescent,
    TotalTrainingEffect,
    FirstLapIndex,
    NumLaps,
    EventGroup,
    Trigger,
    NecLat,
    NecLong,
    SwcLat,
    SwcLong,
    NumLengths,
    NormalizedPower,
    TrainingStressScore,
    IntensityFactor,
    LeftRightBalance,
    EndPositionLat,
    EndPositionLong,
    AvgStrokeCount,
    AvgStrokeDistance,
    SwimStroke,
    PoolLength,
    ThresholdPower,
    PoolLengthUnit,
    NumActiveLengths,
    TotalWork,
    AvgAltitude,
    MaxAltitude,
    GpsAccuracy,
    AvgGrade,
    AvgPosGrade,
    AvgNegGrade,
    MaxPosGrade,
    MaxNegGrade,
    AvgTemperature,
    MaxTemperature,
    TotalMovingTime,
    AvgPosVerticalSpeed,
    AvgNegVerticalSpeed,
    MaxPosVerticalSpeed,
    MaxNegVerticalSpeed,
    MinHeartRate,
    TimeInHrZone,
    TimeInSpeedZone,
    TimeInCadenceZone,
    TimeInPowerZone,
    AvgLapTime,
    BestLapIndex,
    MinAltitude,
    PlayerScore,
    OpponentScore,
    OpponentName,
    StrokeCount,
    ZoneCount,
    MaxBallSpeed,
    AvgBallSpeed,
    AvgVerticalOscillation,
    AvgStanceTimePercent,
    AvgStanceTime,
    AvgFractionalCadence,
    MaxFractionalCadence,
    TotalFractionalCycles,
    AvgTotalHemoglobinConc,
    MinTotalHemoglobinConc,
    MaxTotalHemoglobinConc,
    AvgSaturatedHemoglobinPercent,
    MinSaturatedHemoglobinPercent,
    MaxSaturatedHemoglobinPercent,
    AvgLeftTorqueEffectiveness,
    AvgRightTorqueEffectiveness,
    AvgLeftPedalSmoothness,
    AvgRightPedalSmoothness,
    AvgCombinedPedalSmoothness,
    SportProfileName,
    SportIndex,
    TimeStanding,
    StandCount,
    AvgLeftPco,
    AvgRightPco,
    AvgLeftPowerPhase,
    AvgLeftPowerPhasePeak,
    AvgRightPowerPhase,
    AvgRightPowerPhasePeak,
    AvgPowerPosition,
    MaxPowerPosition,
    AvgCadencePosition,
    MaxCadencePosition,
    EnhancedAvgSpeed,
    EnhancedMaxSpeed,
    EnhancedAvgAltitude,
    EnhancedMinAltitude,
    EnhancedMaxAltitude,
    AvgLevMotorPower,
    MaxLevMotorPower,
    LevBatteryConsumption,
    AvgVerticalRatio,
    AvgStanceTimeBalance,
    AvgStepLength,
    TotalAnaerobicTrainingEffect,
    AvgVam,
    AvgDepth,
    MaxDepth,
    SurfaceInterval,
    StartCns,
    EndCns,
    StartN2,
    EndN2,
    AvgRespirationRate,
    MaxRespirationRate,
    MinRespirationRate,
    MinTemperature,
    O2Toxicity,
    DiveNumber,
    TrainingLoadPeak,
    EnhancedAvgRespirationRate,
    EnhancedMaxRespirationRate,
    EnhancedMinRespirationRate,
    TotalGrit,
    TotalFlow,
    JumpCount,
    AvgGrit,
    AvgFlow,
    WorkoutFeel,
    WorkoutRpe,
    AvgSpo2,
    AvgStress,
    SdrrHrv,
    RmssdHrv,
    TotalFractionalAscent,
    TotalFractionalDescent,
    AvgCoreTemperature,
    MinCoreTemperature,
    MaxCoreTemperature,
    Unknown,
}
impl SessionField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            253 => Self::Timestamp,
            0 => Self::Event,
            1 => Self::EventType,
            2 => Self::StartTime,
            3 => Self::StartPositionLat,
            4 => Self::StartPositionLong,
            5 => Self::Sport,
            6 => Self::SubSport,
            7 => Self::TotalElapsedTime,
            8 => Self::TotalTimerTime,
            9 => Self::TotalDistance,
            10 => Self::TotalCycles,
            11 => Self::TotalCalories,
            13 => Self::TotalFatCalories,
            14 => Self::AvgSpeed,
            15 => Self::MaxSpeed,
            16 => Self::AvgHeartRate,
            17 => Self::MaxHeartRate,
            18 => Self::AvgCadence,
            19 => Self::MaxCadence,
            20 => Self::AvgPower,
            21 => Self::MaxPower,
            22 => Self::TotalAscent,
            23 => Self::TotalDescent,
            24 => Self::TotalTrainingEffect,
            25 => Self::FirstLapIndex,
            26 => Self::NumLaps,
            27 => Self::EventGroup,
            28 => Self::Trigger,
            29 => Self::NecLat,
            30 => Self::NecLong,
            31 => Self::SwcLat,
            32 => Self::SwcLong,
            33 => Self::NumLengths,
            34 => Self::NormalizedPower,
            35 => Self::TrainingStressScore,
            36 => Self::IntensityFactor,
            37 => Self::LeftRightBalance,
            38 => Self::EndPositionLat,
            39 => Self::EndPositionLong,
            41 => Self::AvgStrokeCount,
            42 => Self::AvgStrokeDistance,
            43 => Self::SwimStroke,
            44 => Self::PoolLength,
            45 => Self::ThresholdPower,
            46 => Self::PoolLengthUnit,
            47 => Self::NumActiveLengths,
            48 => Self::TotalWork,
            49 => Self::AvgAltitude,
            50 => Self::MaxAltitude,
            51 => Self::GpsAccuracy,
            52 => Self::AvgGrade,
            53 => Self::AvgPosGrade,
            54 => Self::AvgNegGrade,
            55 => Self::MaxPosGrade,
            56 => Self::MaxNegGrade,
            57 => Self::AvgTemperature,
            58 => Self::MaxTemperature,
            59 => Self::TotalMovingTime,
            60 => Self::AvgPosVerticalSpeed,
            61 => Self::AvgNegVerticalSpeed,
            62 => Self::MaxPosVerticalSpeed,
            63 => Self::MaxNegVerticalSpeed,
            64 => Self::MinHeartRate,
            65 => Self::TimeInHrZone,
            66 => Self::TimeInSpeedZone,
            67 => Self::TimeInCadenceZone,
            68 => Self::TimeInPowerZone,
            69 => Self::AvgLapTime,
            70 => Self::BestLapIndex,
            71 => Self::MinAltitude,
            82 => Self::PlayerScore,
            83 => Self::OpponentScore,
            84 => Self::OpponentName,
            85 => Self::StrokeCount,
            86 => Self::ZoneCount,
            87 => Self::MaxBallSpeed,
            88 => Self::AvgBallSpeed,
            89 => Self::AvgVerticalOscillation,
            90 => Self::AvgStanceTimePercent,
            91 => Self::AvgStanceTime,
            92 => Self::AvgFractionalCadence,
            93 => Self::MaxFractionalCadence,
            94 => Self::TotalFractionalCycles,
            95 => Self::AvgTotalHemoglobinConc,
            96 => Self::MinTotalHemoglobinConc,
            97 => Self::MaxTotalHemoglobinConc,
            98 => Self::AvgSaturatedHemoglobinPercent,
            99 => Self::MinSaturatedHemoglobinPercent,
            100 => Self::MaxSaturatedHemoglobinPercent,
            101 => Self::AvgLeftTorqueEffectiveness,
            102 => Self::AvgRightTorqueEffectiveness,
            103 => Self::AvgLeftPedalSmoothness,
            104 => Self::AvgRightPedalSmoothness,
            105 => Self::AvgCombinedPedalSmoothness,
            110 => Self::SportProfileName,
            111 => Self::SportIndex,
            112 => Self::TimeStanding,
            113 => Self::StandCount,
            114 => Self::AvgLeftPco,
            115 => Self::AvgRightPco,
            116 => Self::AvgLeftPowerPhase,
            117 => Self::AvgLeftPowerPhasePeak,
            118 => Self::AvgRightPowerPhase,
            119 => Self::AvgRightPowerPhasePeak,
            120 => Self::AvgPowerPosition,
            121 => Self::MaxPowerPosition,
            122 => Self::AvgCadencePosition,
            123 => Self::MaxCadencePosition,
            124 => Self::EnhancedAvgSpeed,
            125 => Self::EnhancedMaxSpeed,
            126 => Self::EnhancedAvgAltitude,
            127 => Self::EnhancedMinAltitude,
            128 => Self::EnhancedMaxAltitude,
            129 => Self::AvgLevMotorPower,
            130 => Self::MaxLevMotorPower,
            131 => Self::LevBatteryConsumption,
            132 => Self::AvgVerticalRatio,
            133 => Self::AvgStanceTimeBalance,
            134 => Self::AvgStepLength,
            137 => Self::TotalAnaerobicTrainingEffect,
            139 => Self::AvgVam,
            140 => Self::AvgDepth,
            141 => Self::MaxDepth,
            142 => Self::SurfaceInterval,
            143 => Self::StartCns,
            144 => Self::EndCns,
            145 => Self::StartN2,
            146 => Self::EndN2,
            147 => Self::AvgRespirationRate,
            148 => Self::MaxRespirationRate,
            149 => Self::MinRespirationRate,
            150 => Self::MinTemperature,
            155 => Self::O2Toxicity,
            156 => Self::DiveNumber,
            168 => Self::TrainingLoadPeak,
            169 => Self::EnhancedAvgRespirationRate,
            170 => Self::EnhancedMaxRespirationRate,
            180 => Self::EnhancedMinRespirationRate,
            181 => Self::TotalGrit,
            182 => Self::TotalFlow,
            183 => Self::JumpCount,
            186 => Self::AvgGrit,
            187 => Self::AvgFlow,
            192 => Self::WorkoutFeel,
            193 => Self::WorkoutRpe,
            194 => Self::AvgSpo2,
            195 => Self::AvgStress,
            197 => Self::SdrrHrv,
            198 => Self::RmssdHrv,
            199 => Self::TotalFractionalAscent,
            200 => Self::TotalFractionalDescent,
            208 => Self::AvgCoreTemperature,
            209 => Self::MinCoreTemperature,
            210 => Self::MaxCoreTemperature,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(Event::parse),
            1 => ParseFunction::Simple(EventType::parse),
            2 => ParseFunction::Simple(DateTime::parse),
            3 => ParseFunction::Simple(parse_sint32),
            4 => ParseFunction::Simple(parse_sint32),
            5 => ParseFunction::Simple(Sport::parse),
            6 => ParseFunction::Simple(SubSport::parse),
            7 => ParseFunction::Simple(parse_uint32),
            8 => ParseFunction::Simple(parse_uint32),
            9 => ParseFunction::Simple(parse_uint32),
            10 => ParseFunction::Simple(parse_uint32),
            11 => ParseFunction::Simple(parse_uint16),
            13 => ParseFunction::Simple(parse_uint16),
            14 => ParseFunction::Simple(parse_uint16),
            15 => ParseFunction::Simple(parse_uint16),
            16 => ParseFunction::Simple(parse_uint8),
            17 => ParseFunction::Simple(parse_uint8),
            18 => ParseFunction::Simple(parse_uint8),
            19 => ParseFunction::Simple(parse_uint8),
            20 => ParseFunction::Simple(parse_uint16),
            21 => ParseFunction::Simple(parse_uint16),
            22 => ParseFunction::Simple(parse_uint16),
            23 => ParseFunction::Simple(parse_uint16),
            24 => ParseFunction::Simple(parse_uint8),
            25 => ParseFunction::Simple(parse_uint16),
            26 => ParseFunction::Simple(parse_uint16),
            27 => ParseFunction::Simple(parse_uint8),
            28 => ParseFunction::Simple(SessionTrigger::parse),
            29 => ParseFunction::Simple(parse_sint32),
            30 => ParseFunction::Simple(parse_sint32),
            31 => ParseFunction::Simple(parse_sint32),
            32 => ParseFunction::Simple(parse_sint32),
            33 => ParseFunction::Simple(parse_uint16),
            34 => ParseFunction::Simple(parse_uint16),
            35 => ParseFunction::Simple(parse_uint16),
            36 => ParseFunction::Simple(parse_uint16),
            37 => ParseFunction::Simple(LeftRightBalance100::parse),
            38 => ParseFunction::Simple(parse_sint32),
            39 => ParseFunction::Simple(parse_sint32),
            41 => ParseFunction::Simple(parse_uint32),
            42 => ParseFunction::Simple(parse_uint16),
            43 => ParseFunction::Simple(SwimStroke::parse),
            44 => ParseFunction::Simple(parse_uint16),
            45 => ParseFunction::Simple(parse_uint16),
            46 => ParseFunction::Simple(DisplayMeasure::parse),
            47 => ParseFunction::Simple(parse_uint16),
            48 => ParseFunction::Simple(parse_uint32),
            49 => ParseFunction::Simple(parse_uint16),
            50 => ParseFunction::Simple(parse_uint16),
            51 => ParseFunction::Simple(parse_uint8),
            52 => ParseFunction::Simple(parse_sint16),
            53 => ParseFunction::Simple(parse_sint16),
            54 => ParseFunction::Simple(parse_sint16),
            55 => ParseFunction::Simple(parse_sint16),
            56 => ParseFunction::Simple(parse_sint16),
            57 => ParseFunction::Simple(parse_sint8),
            58 => ParseFunction::Simple(parse_sint8),
            59 => ParseFunction::Simple(parse_uint32),
            60 => ParseFunction::Simple(parse_sint16),
            61 => ParseFunction::Simple(parse_sint16),
            62 => ParseFunction::Simple(parse_sint16),
            63 => ParseFunction::Simple(parse_sint16),
            64 => ParseFunction::Simple(parse_uint8),
            65 => ParseFunction::Simple(parse_uint32),
            66 => ParseFunction::Simple(parse_uint32),
            67 => ParseFunction::Simple(parse_uint32),
            68 => ParseFunction::Simple(parse_uint32),
            69 => ParseFunction::Simple(parse_uint32),
            70 => ParseFunction::Simple(parse_uint16),
            71 => ParseFunction::Simple(parse_uint16),
            82 => ParseFunction::Simple(parse_uint16),
            83 => ParseFunction::Simple(parse_uint16),
            84 => ParseFunction::Simple(parse_string),
            85 => ParseFunction::Simple(parse_uint16),
            86 => ParseFunction::Simple(parse_uint16),
            87 => ParseFunction::Simple(parse_uint16),
            88 => ParseFunction::Simple(parse_uint16),
            89 => ParseFunction::Simple(parse_uint16),
            90 => ParseFunction::Simple(parse_uint16),
            91 => ParseFunction::Simple(parse_uint16),
            92 => ParseFunction::Simple(parse_uint8),
            93 => ParseFunction::Simple(parse_uint8),
            94 => ParseFunction::Simple(parse_uint8),
            95 => ParseFunction::Simple(parse_uint16),
            96 => ParseFunction::Simple(parse_uint16),
            97 => ParseFunction::Simple(parse_uint16),
            98 => ParseFunction::Simple(parse_uint16),
            99 => ParseFunction::Simple(parse_uint16),
            100 => ParseFunction::Simple(parse_uint16),
            101 => ParseFunction::Simple(parse_uint8),
            102 => ParseFunction::Simple(parse_uint8),
            103 => ParseFunction::Simple(parse_uint8),
            104 => ParseFunction::Simple(parse_uint8),
            105 => ParseFunction::Simple(parse_uint8),
            110 => ParseFunction::Simple(parse_string),
            111 => ParseFunction::Simple(parse_uint8),
            112 => ParseFunction::Simple(parse_uint32),
            113 => ParseFunction::Simple(parse_uint16),
            114 => ParseFunction::Simple(parse_sint8),
            115 => ParseFunction::Simple(parse_sint8),
            116 => ParseFunction::Simple(parse_uint8),
            117 => ParseFunction::Simple(parse_uint8),
            118 => ParseFunction::Simple(parse_uint8),
            119 => ParseFunction::Simple(parse_uint8),
            120 => ParseFunction::Simple(parse_uint16),
            121 => ParseFunction::Simple(parse_uint16),
            122 => ParseFunction::Simple(parse_uint8),
            123 => ParseFunction::Simple(parse_uint8),
            124 => ParseFunction::Simple(parse_uint32),
            125 => ParseFunction::Simple(parse_uint32),
            126 => ParseFunction::Simple(parse_uint32),
            127 => ParseFunction::Simple(parse_uint32),
            128 => ParseFunction::Simple(parse_uint32),
            129 => ParseFunction::Simple(parse_uint16),
            130 => ParseFunction::Simple(parse_uint16),
            131 => ParseFunction::Simple(parse_uint8),
            132 => ParseFunction::Simple(parse_uint16),
            133 => ParseFunction::Simple(parse_uint16),
            134 => ParseFunction::Simple(parse_uint16),
            137 => ParseFunction::Simple(parse_uint8),
            139 => ParseFunction::Simple(parse_uint16),
            140 => ParseFunction::Simple(parse_uint32),
            141 => ParseFunction::Simple(parse_uint32),
            142 => ParseFunction::Simple(parse_uint32),
            143 => ParseFunction::Simple(parse_uint8),
            144 => ParseFunction::Simple(parse_uint8),
            145 => ParseFunction::Simple(parse_uint16),
            146 => ParseFunction::Simple(parse_uint16),
            147 => ParseFunction::Simple(parse_uint8),
            148 => ParseFunction::Simple(parse_uint8),
            149 => ParseFunction::Simple(parse_uint8),
            150 => ParseFunction::Simple(parse_sint8),
            155 => ParseFunction::Simple(parse_uint16),
            156 => ParseFunction::Simple(parse_uint32),
            168 => ParseFunction::Simple(parse_sint32),
            169 => ParseFunction::Simple(parse_uint16),
            170 => ParseFunction::Simple(parse_uint16),
            180 => ParseFunction::Simple(parse_uint16),
            181 => ParseFunction::Simple(parse_float32),
            182 => ParseFunction::Simple(parse_float32),
            183 => ParseFunction::Simple(parse_uint16),
            186 => ParseFunction::Simple(parse_float32),
            187 => ParseFunction::Simple(parse_float32),
            192 => ParseFunction::Simple(parse_uint8),
            193 => ParseFunction::Simple(parse_uint8),
            194 => ParseFunction::Simple(parse_uint8),
            195 => ParseFunction::Simple(parse_uint8),
            197 => ParseFunction::Simple(parse_uint8),
            198 => ParseFunction::Simple(parse_uint8),
            199 => ParseFunction::Simple(parse_uint8),
            200 => ParseFunction::Simple(parse_uint8),
            208 => ParseFunction::Simple(parse_uint16),
            209 => ParseFunction::Simple(parse_uint16),
            210 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            7 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            8 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            9 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            14 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            15 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            24 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            35 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            36 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            41 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            42 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            44 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            49 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            50 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            52 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            53 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            54 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            55 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            56 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            59 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            60 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            61 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            62 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            63 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            65 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            66 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            67 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            68 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            69 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            71 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            87 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            88 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            89 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            90 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            91 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            92 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            93 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            94 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            95 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            96 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            97 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            98 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            99 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            100 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            101 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            102 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            103 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            104 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            105 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            112 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            116 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            117 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            118 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            119 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            124 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            125 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            126 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            127 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            128 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            131 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            132 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            133 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            134 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            137 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            139 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            140 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            141 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            142 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            143 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            144 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            145 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            146 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            168 => Some(ScaleOffset {
                scale: 65536_f32,
                offset: 0_f32,
            }),
            169 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            170 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            180 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            199 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            200 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            208 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            209 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            210 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Session(SessionField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum LapField {
    MessageIndex,
    Timestamp,
    Event,
    EventType,
    StartTime,
    StartPositionLat,
    StartPositionLong,
    EndPositionLat,
    EndPositionLong,
    TotalElapsedTime,
    TotalTimerTime,
    TotalDistance,
    TotalCycles,
    TotalCalories,
    TotalFatCalories,
    AvgSpeed,
    MaxSpeed,
    AvgHeartRate,
    MaxHeartRate,
    AvgCadence,
    MaxCadence,
    AvgPower,
    MaxPower,
    TotalAscent,
    TotalDescent,
    Intensity,
    LapTrigger,
    Sport,
    EventGroup,
    NumLengths,
    NormalizedPower,
    LeftRightBalance,
    FirstLengthIndex,
    AvgStrokeDistance,
    SwimStroke,
    SubSport,
    NumActiveLengths,
    TotalWork,
    AvgAltitude,
    MaxAltitude,
    GpsAccuracy,
    AvgGrade,
    AvgPosGrade,
    AvgNegGrade,
    MaxPosGrade,
    MaxNegGrade,
    AvgTemperature,
    MaxTemperature,
    TotalMovingTime,
    AvgPosVerticalSpeed,
    AvgNegVerticalSpeed,
    MaxPosVerticalSpeed,
    MaxNegVerticalSpeed,
    TimeInHrZone,
    TimeInSpeedZone,
    TimeInCadenceZone,
    TimeInPowerZone,
    RepetitionNum,
    MinAltitude,
    MinHeartRate,
    WktStepIndex,
    OpponentScore,
    StrokeCount,
    ZoneCount,
    AvgVerticalOscillation,
    AvgStanceTimePercent,
    AvgStanceTime,
    AvgFractionalCadence,
    MaxFractionalCadence,
    TotalFractionalCycles,
    PlayerScore,
    AvgTotalHemoglobinConc,
    MinTotalHemoglobinConc,
    MaxTotalHemoglobinConc,
    AvgSaturatedHemoglobinPercent,
    MinSaturatedHemoglobinPercent,
    MaxSaturatedHemoglobinPercent,
    AvgLeftTorqueEffectiveness,
    AvgRightTorqueEffectiveness,
    AvgLeftPedalSmoothness,
    AvgRightPedalSmoothness,
    AvgCombinedPedalSmoothness,
    TimeStanding,
    StandCount,
    AvgLeftPco,
    AvgRightPco,
    AvgLeftPowerPhase,
    AvgLeftPowerPhasePeak,
    AvgRightPowerPhase,
    AvgRightPowerPhasePeak,
    AvgPowerPosition,
    MaxPowerPosition,
    AvgCadencePosition,
    MaxCadencePosition,
    EnhancedAvgSpeed,
    EnhancedMaxSpeed,
    EnhancedAvgAltitude,
    EnhancedMinAltitude,
    EnhancedMaxAltitude,
    AvgLevMotorPower,
    MaxLevMotorPower,
    LevBatteryConsumption,
    AvgVerticalRatio,
    AvgStanceTimeBalance,
    AvgStepLength,
    AvgVam,
    AvgDepth,
    MaxDepth,
    MinTemperature,
    EnhancedAvgRespirationRate,
    EnhancedMaxRespirationRate,
    AvgRespirationRate,
    MaxRespirationRate,
    TotalGrit,
    TotalFlow,
    JumpCount,
    AvgGrit,
    AvgFlow,
    TotalFractionalAscent,
    TotalFractionalDescent,
    AvgCoreTemperature,
    MinCoreTemperature,
    MaxCoreTemperature,
    Unknown,
}
impl LapField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            253 => Self::Timestamp,
            0 => Self::Event,
            1 => Self::EventType,
            2 => Self::StartTime,
            3 => Self::StartPositionLat,
            4 => Self::StartPositionLong,
            5 => Self::EndPositionLat,
            6 => Self::EndPositionLong,
            7 => Self::TotalElapsedTime,
            8 => Self::TotalTimerTime,
            9 => Self::TotalDistance,
            10 => Self::TotalCycles,
            11 => Self::TotalCalories,
            12 => Self::TotalFatCalories,
            13 => Self::AvgSpeed,
            14 => Self::MaxSpeed,
            15 => Self::AvgHeartRate,
            16 => Self::MaxHeartRate,
            17 => Self::AvgCadence,
            18 => Self::MaxCadence,
            19 => Self::AvgPower,
            20 => Self::MaxPower,
            21 => Self::TotalAscent,
            22 => Self::TotalDescent,
            23 => Self::Intensity,
            24 => Self::LapTrigger,
            25 => Self::Sport,
            26 => Self::EventGroup,
            32 => Self::NumLengths,
            33 => Self::NormalizedPower,
            34 => Self::LeftRightBalance,
            35 => Self::FirstLengthIndex,
            37 => Self::AvgStrokeDistance,
            38 => Self::SwimStroke,
            39 => Self::SubSport,
            40 => Self::NumActiveLengths,
            41 => Self::TotalWork,
            42 => Self::AvgAltitude,
            43 => Self::MaxAltitude,
            44 => Self::GpsAccuracy,
            45 => Self::AvgGrade,
            46 => Self::AvgPosGrade,
            47 => Self::AvgNegGrade,
            48 => Self::MaxPosGrade,
            49 => Self::MaxNegGrade,
            50 => Self::AvgTemperature,
            51 => Self::MaxTemperature,
            52 => Self::TotalMovingTime,
            53 => Self::AvgPosVerticalSpeed,
            54 => Self::AvgNegVerticalSpeed,
            55 => Self::MaxPosVerticalSpeed,
            56 => Self::MaxNegVerticalSpeed,
            57 => Self::TimeInHrZone,
            58 => Self::TimeInSpeedZone,
            59 => Self::TimeInCadenceZone,
            60 => Self::TimeInPowerZone,
            61 => Self::RepetitionNum,
            62 => Self::MinAltitude,
            63 => Self::MinHeartRate,
            71 => Self::WktStepIndex,
            74 => Self::OpponentScore,
            75 => Self::StrokeCount,
            76 => Self::ZoneCount,
            77 => Self::AvgVerticalOscillation,
            78 => Self::AvgStanceTimePercent,
            79 => Self::AvgStanceTime,
            80 => Self::AvgFractionalCadence,
            81 => Self::MaxFractionalCadence,
            82 => Self::TotalFractionalCycles,
            83 => Self::PlayerScore,
            84 => Self::AvgTotalHemoglobinConc,
            85 => Self::MinTotalHemoglobinConc,
            86 => Self::MaxTotalHemoglobinConc,
            87 => Self::AvgSaturatedHemoglobinPercent,
            88 => Self::MinSaturatedHemoglobinPercent,
            89 => Self::MaxSaturatedHemoglobinPercent,
            91 => Self::AvgLeftTorqueEffectiveness,
            92 => Self::AvgRightTorqueEffectiveness,
            93 => Self::AvgLeftPedalSmoothness,
            94 => Self::AvgRightPedalSmoothness,
            95 => Self::AvgCombinedPedalSmoothness,
            98 => Self::TimeStanding,
            99 => Self::StandCount,
            100 => Self::AvgLeftPco,
            101 => Self::AvgRightPco,
            102 => Self::AvgLeftPowerPhase,
            103 => Self::AvgLeftPowerPhasePeak,
            104 => Self::AvgRightPowerPhase,
            105 => Self::AvgRightPowerPhasePeak,
            106 => Self::AvgPowerPosition,
            107 => Self::MaxPowerPosition,
            108 => Self::AvgCadencePosition,
            109 => Self::MaxCadencePosition,
            110 => Self::EnhancedAvgSpeed,
            111 => Self::EnhancedMaxSpeed,
            112 => Self::EnhancedAvgAltitude,
            113 => Self::EnhancedMinAltitude,
            114 => Self::EnhancedMaxAltitude,
            115 => Self::AvgLevMotorPower,
            116 => Self::MaxLevMotorPower,
            117 => Self::LevBatteryConsumption,
            118 => Self::AvgVerticalRatio,
            119 => Self::AvgStanceTimeBalance,
            120 => Self::AvgStepLength,
            121 => Self::AvgVam,
            122 => Self::AvgDepth,
            123 => Self::MaxDepth,
            124 => Self::MinTemperature,
            136 => Self::EnhancedAvgRespirationRate,
            137 => Self::EnhancedMaxRespirationRate,
            147 => Self::AvgRespirationRate,
            148 => Self::MaxRespirationRate,
            149 => Self::TotalGrit,
            150 => Self::TotalFlow,
            151 => Self::JumpCount,
            153 => Self::AvgGrit,
            154 => Self::AvgFlow,
            156 => Self::TotalFractionalAscent,
            157 => Self::TotalFractionalDescent,
            158 => Self::AvgCoreTemperature,
            159 => Self::MinCoreTemperature,
            160 => Self::MaxCoreTemperature,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(Event::parse),
            1 => ParseFunction::Simple(EventType::parse),
            2 => ParseFunction::Simple(DateTime::parse),
            3 => ParseFunction::Simple(parse_sint32),
            4 => ParseFunction::Simple(parse_sint32),
            5 => ParseFunction::Simple(parse_sint32),
            6 => ParseFunction::Simple(parse_sint32),
            7 => ParseFunction::Simple(parse_uint32),
            8 => ParseFunction::Simple(parse_uint32),
            9 => ParseFunction::Simple(parse_uint32),
            10 => ParseFunction::Simple(parse_uint32),
            11 => ParseFunction::Simple(parse_uint16),
            12 => ParseFunction::Simple(parse_uint16),
            13 => ParseFunction::Simple(parse_uint16),
            14 => ParseFunction::Simple(parse_uint16),
            15 => ParseFunction::Simple(parse_uint8),
            16 => ParseFunction::Simple(parse_uint8),
            17 => ParseFunction::Simple(parse_uint8),
            18 => ParseFunction::Simple(parse_uint8),
            19 => ParseFunction::Simple(parse_uint16),
            20 => ParseFunction::Simple(parse_uint16),
            21 => ParseFunction::Simple(parse_uint16),
            22 => ParseFunction::Simple(parse_uint16),
            23 => ParseFunction::Simple(Intensity::parse),
            24 => ParseFunction::Simple(LapTrigger::parse),
            25 => ParseFunction::Simple(Sport::parse),
            26 => ParseFunction::Simple(parse_uint8),
            32 => ParseFunction::Simple(parse_uint16),
            33 => ParseFunction::Simple(parse_uint16),
            34 => ParseFunction::Simple(LeftRightBalance100::parse),
            35 => ParseFunction::Simple(parse_uint16),
            37 => ParseFunction::Simple(parse_uint16),
            38 => ParseFunction::Simple(SwimStroke::parse),
            39 => ParseFunction::Simple(SubSport::parse),
            40 => ParseFunction::Simple(parse_uint16),
            41 => ParseFunction::Simple(parse_uint32),
            42 => ParseFunction::Simple(parse_uint16),
            43 => ParseFunction::Simple(parse_uint16),
            44 => ParseFunction::Simple(parse_uint8),
            45 => ParseFunction::Simple(parse_sint16),
            46 => ParseFunction::Simple(parse_sint16),
            47 => ParseFunction::Simple(parse_sint16),
            48 => ParseFunction::Simple(parse_sint16),
            49 => ParseFunction::Simple(parse_sint16),
            50 => ParseFunction::Simple(parse_sint8),
            51 => ParseFunction::Simple(parse_sint8),
            52 => ParseFunction::Simple(parse_uint32),
            53 => ParseFunction::Simple(parse_sint16),
            54 => ParseFunction::Simple(parse_sint16),
            55 => ParseFunction::Simple(parse_sint16),
            56 => ParseFunction::Simple(parse_sint16),
            57 => ParseFunction::Simple(parse_uint32),
            58 => ParseFunction::Simple(parse_uint32),
            59 => ParseFunction::Simple(parse_uint32),
            60 => ParseFunction::Simple(parse_uint32),
            61 => ParseFunction::Simple(parse_uint16),
            62 => ParseFunction::Simple(parse_uint16),
            63 => ParseFunction::Simple(parse_uint8),
            71 => ParseFunction::Simple(MessageIndex::parse),
            74 => ParseFunction::Simple(parse_uint16),
            75 => ParseFunction::Simple(parse_uint16),
            76 => ParseFunction::Simple(parse_uint16),
            77 => ParseFunction::Simple(parse_uint16),
            78 => ParseFunction::Simple(parse_uint16),
            79 => ParseFunction::Simple(parse_uint16),
            80 => ParseFunction::Simple(parse_uint8),
            81 => ParseFunction::Simple(parse_uint8),
            82 => ParseFunction::Simple(parse_uint8),
            83 => ParseFunction::Simple(parse_uint16),
            84 => ParseFunction::Simple(parse_uint16),
            85 => ParseFunction::Simple(parse_uint16),
            86 => ParseFunction::Simple(parse_uint16),
            87 => ParseFunction::Simple(parse_uint16),
            88 => ParseFunction::Simple(parse_uint16),
            89 => ParseFunction::Simple(parse_uint16),
            91 => ParseFunction::Simple(parse_uint8),
            92 => ParseFunction::Simple(parse_uint8),
            93 => ParseFunction::Simple(parse_uint8),
            94 => ParseFunction::Simple(parse_uint8),
            95 => ParseFunction::Simple(parse_uint8),
            98 => ParseFunction::Simple(parse_uint32),
            99 => ParseFunction::Simple(parse_uint16),
            100 => ParseFunction::Simple(parse_sint8),
            101 => ParseFunction::Simple(parse_sint8),
            102 => ParseFunction::Simple(parse_uint8),
            103 => ParseFunction::Simple(parse_uint8),
            104 => ParseFunction::Simple(parse_uint8),
            105 => ParseFunction::Simple(parse_uint8),
            106 => ParseFunction::Simple(parse_uint16),
            107 => ParseFunction::Simple(parse_uint16),
            108 => ParseFunction::Simple(parse_uint8),
            109 => ParseFunction::Simple(parse_uint8),
            110 => ParseFunction::Simple(parse_uint32),
            111 => ParseFunction::Simple(parse_uint32),
            112 => ParseFunction::Simple(parse_uint32),
            113 => ParseFunction::Simple(parse_uint32),
            114 => ParseFunction::Simple(parse_uint32),
            115 => ParseFunction::Simple(parse_uint16),
            116 => ParseFunction::Simple(parse_uint16),
            117 => ParseFunction::Simple(parse_uint8),
            118 => ParseFunction::Simple(parse_uint16),
            119 => ParseFunction::Simple(parse_uint16),
            120 => ParseFunction::Simple(parse_uint16),
            121 => ParseFunction::Simple(parse_uint16),
            122 => ParseFunction::Simple(parse_uint32),
            123 => ParseFunction::Simple(parse_uint32),
            124 => ParseFunction::Simple(parse_sint8),
            136 => ParseFunction::Simple(parse_uint16),
            137 => ParseFunction::Simple(parse_uint16),
            147 => ParseFunction::Simple(parse_uint8),
            148 => ParseFunction::Simple(parse_uint8),
            149 => ParseFunction::Simple(parse_float32),
            150 => ParseFunction::Simple(parse_float32),
            151 => ParseFunction::Simple(parse_uint16),
            153 => ParseFunction::Simple(parse_float32),
            154 => ParseFunction::Simple(parse_float32),
            156 => ParseFunction::Simple(parse_uint8),
            157 => ParseFunction::Simple(parse_uint8),
            158 => ParseFunction::Simple(parse_uint16),
            159 => ParseFunction::Simple(parse_uint16),
            160 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            7 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            8 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            9 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            13 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            14 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            37 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            42 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            43 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            45 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            46 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            47 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            48 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            49 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            52 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            53 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            54 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            55 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            56 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            57 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            58 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            59 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            60 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            62 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            77 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            78 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            79 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            80 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            81 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            82 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            84 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            85 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            86 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            87 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            88 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            89 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            91 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            92 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            93 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            94 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            95 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            98 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            102 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            103 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            104 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            105 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            110 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            111 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            112 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            113 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            114 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            117 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            118 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            119 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            120 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            121 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            122 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            123 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            136 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            137 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            156 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            157 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            158 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            159 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            160 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Lap(LapField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum LengthField {
    MessageIndex,
    Timestamp,
    Event,
    EventType,
    StartTime,
    TotalElapsedTime,
    TotalTimerTime,
    TotalStrokes,
    AvgSpeed,
    SwimStroke,
    AvgSwimmingCadence,
    EventGroup,
    TotalCalories,
    LengthType,
    PlayerScore,
    OpponentScore,
    StrokeCount,
    ZoneCount,
    EnhancedAvgRespirationRate,
    EnhancedMaxRespirationRate,
    AvgRespirationRate,
    MaxRespirationRate,
    Unknown,
}
impl LengthField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            253 => Self::Timestamp,
            0 => Self::Event,
            1 => Self::EventType,
            2 => Self::StartTime,
            3 => Self::TotalElapsedTime,
            4 => Self::TotalTimerTime,
            5 => Self::TotalStrokes,
            6 => Self::AvgSpeed,
            7 => Self::SwimStroke,
            9 => Self::AvgSwimmingCadence,
            10 => Self::EventGroup,
            11 => Self::TotalCalories,
            12 => Self::LengthType,
            18 => Self::PlayerScore,
            19 => Self::OpponentScore,
            20 => Self::StrokeCount,
            21 => Self::ZoneCount,
            22 => Self::EnhancedAvgRespirationRate,
            23 => Self::EnhancedMaxRespirationRate,
            24 => Self::AvgRespirationRate,
            25 => Self::MaxRespirationRate,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(Event::parse),
            1 => ParseFunction::Simple(EventType::parse),
            2 => ParseFunction::Simple(DateTime::parse),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_uint16),
            6 => ParseFunction::Simple(parse_uint16),
            7 => ParseFunction::Simple(SwimStroke::parse),
            9 => ParseFunction::Simple(parse_uint8),
            10 => ParseFunction::Simple(parse_uint8),
            11 => ParseFunction::Simple(parse_uint16),
            12 => ParseFunction::Simple(LengthType::parse),
            18 => ParseFunction::Simple(parse_uint16),
            19 => ParseFunction::Simple(parse_uint16),
            20 => ParseFunction::Simple(parse_uint16),
            21 => ParseFunction::Simple(parse_uint16),
            22 => ParseFunction::Simple(parse_uint16),
            23 => ParseFunction::Simple(parse_uint16),
            24 => ParseFunction::Simple(parse_uint8),
            25 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            3 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            6 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            22 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            23 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Length(LengthField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum RecordField {
    Timestamp,
    PositionLat,
    PositionLong,
    Altitude,
    HeartRate,
    Cadence,
    Distance,
    Speed,
    Power,
    CompressedSpeedDistance,
    Grade,
    Resistance,
    TimeFromCourse,
    CycleLength,
    Temperature,
    Speed1s,
    Cycles,
    TotalCycles,
    CompressedAccumulatedPower,
    AccumulatedPower,
    LeftRightBalance,
    GpsAccuracy,
    VerticalSpeed,
    Calories,
    VerticalOscillation,
    StanceTimePercent,
    StanceTime,
    ActivityType,
    LeftTorqueEffectiveness,
    RightTorqueEffectiveness,
    LeftPedalSmoothness,
    RightPedalSmoothness,
    CombinedPedalSmoothness,
    Time128,
    StrokeType,
    Zone,
    BallSpeed,
    Cadence256,
    FractionalCadence,
    TotalHemoglobinConc,
    TotalHemoglobinConcMin,
    TotalHemoglobinConcMax,
    SaturatedHemoglobinPercent,
    SaturatedHemoglobinPercentMin,
    SaturatedHemoglobinPercentMax,
    DeviceIndex,
    LeftPco,
    RightPco,
    LeftPowerPhase,
    LeftPowerPhasePeak,
    RightPowerPhase,
    RightPowerPhasePeak,
    EnhancedSpeed,
    EnhancedAltitude,
    BatterySoc,
    MotorPower,
    VerticalRatio,
    StanceTimeBalance,
    StepLength,
    CycleLength16,
    AbsolutePressure,
    Depth,
    NextStopDepth,
    NextStopTime,
    TimeToSurface,
    NdlTime,
    CnsLoad,
    N2Load,
    RespirationRate,
    EnhancedRespirationRate,
    Grit,
    Flow,
    CurrentStress,
    EbikeTravelRange,
    EbikeBatteryLevel,
    EbikeAssistMode,
    EbikeAssistLevelPercent,
    AirTimeRemaining,
    PressureSac,
    VolumeSac,
    Rmv,
    AscentRate,
    Po2,
    CoreTemperature,
    Unknown,
}
impl RecordField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::PositionLat,
            1 => Self::PositionLong,
            2 => Self::Altitude,
            3 => Self::HeartRate,
            4 => Self::Cadence,
            5 => Self::Distance,
            6 => Self::Speed,
            7 => Self::Power,
            8 => Self::CompressedSpeedDistance,
            9 => Self::Grade,
            10 => Self::Resistance,
            11 => Self::TimeFromCourse,
            12 => Self::CycleLength,
            13 => Self::Temperature,
            17 => Self::Speed1s,
            18 => Self::Cycles,
            19 => Self::TotalCycles,
            28 => Self::CompressedAccumulatedPower,
            29 => Self::AccumulatedPower,
            30 => Self::LeftRightBalance,
            31 => Self::GpsAccuracy,
            32 => Self::VerticalSpeed,
            33 => Self::Calories,
            39 => Self::VerticalOscillation,
            40 => Self::StanceTimePercent,
            41 => Self::StanceTime,
            42 => Self::ActivityType,
            43 => Self::LeftTorqueEffectiveness,
            44 => Self::RightTorqueEffectiveness,
            45 => Self::LeftPedalSmoothness,
            46 => Self::RightPedalSmoothness,
            47 => Self::CombinedPedalSmoothness,
            48 => Self::Time128,
            49 => Self::StrokeType,
            50 => Self::Zone,
            51 => Self::BallSpeed,
            52 => Self::Cadence256,
            53 => Self::FractionalCadence,
            54 => Self::TotalHemoglobinConc,
            55 => Self::TotalHemoglobinConcMin,
            56 => Self::TotalHemoglobinConcMax,
            57 => Self::SaturatedHemoglobinPercent,
            58 => Self::SaturatedHemoglobinPercentMin,
            59 => Self::SaturatedHemoglobinPercentMax,
            62 => Self::DeviceIndex,
            67 => Self::LeftPco,
            68 => Self::RightPco,
            69 => Self::LeftPowerPhase,
            70 => Self::LeftPowerPhasePeak,
            71 => Self::RightPowerPhase,
            72 => Self::RightPowerPhasePeak,
            73 => Self::EnhancedSpeed,
            78 => Self::EnhancedAltitude,
            81 => Self::BatterySoc,
            82 => Self::MotorPower,
            83 => Self::VerticalRatio,
            84 => Self::StanceTimeBalance,
            85 => Self::StepLength,
            87 => Self::CycleLength16,
            91 => Self::AbsolutePressure,
            92 => Self::Depth,
            93 => Self::NextStopDepth,
            94 => Self::NextStopTime,
            95 => Self::TimeToSurface,
            96 => Self::NdlTime,
            97 => Self::CnsLoad,
            98 => Self::N2Load,
            99 => Self::RespirationRate,
            108 => Self::EnhancedRespirationRate,
            114 => Self::Grit,
            115 => Self::Flow,
            116 => Self::CurrentStress,
            117 => Self::EbikeTravelRange,
            118 => Self::EbikeBatteryLevel,
            119 => Self::EbikeAssistMode,
            120 => Self::EbikeAssistLevelPercent,
            123 => Self::AirTimeRemaining,
            124 => Self::PressureSac,
            125 => Self::VolumeSac,
            126 => Self::Rmv,
            127 => Self::AscentRate,
            129 => Self::Po2,
            139 => Self::CoreTemperature,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_sint32),
            1 => ParseFunction::Simple(parse_sint32),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_uint8),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(parse_uint16),
            7 => ParseFunction::Simple(parse_uint16),
            8 => ParseFunction::Simple(parse_byte),
            9 => ParseFunction::Simple(parse_sint16),
            10 => ParseFunction::Simple(parse_uint8),
            11 => ParseFunction::Simple(parse_sint32),
            12 => ParseFunction::Simple(parse_uint8),
            13 => ParseFunction::Simple(parse_sint8),
            17 => ParseFunction::Simple(parse_uint8),
            18 => ParseFunction::Simple(parse_uint8),
            19 => ParseFunction::Simple(parse_uint32),
            28 => ParseFunction::Simple(parse_uint16),
            29 => ParseFunction::Simple(parse_uint32),
            30 => ParseFunction::Simple(LeftRightBalance::parse),
            31 => ParseFunction::Simple(parse_uint8),
            32 => ParseFunction::Simple(parse_sint16),
            33 => ParseFunction::Simple(parse_uint16),
            39 => ParseFunction::Simple(parse_uint16),
            40 => ParseFunction::Simple(parse_uint16),
            41 => ParseFunction::Simple(parse_uint16),
            42 => ParseFunction::Simple(ActivityType::parse),
            43 => ParseFunction::Simple(parse_uint8),
            44 => ParseFunction::Simple(parse_uint8),
            45 => ParseFunction::Simple(parse_uint8),
            46 => ParseFunction::Simple(parse_uint8),
            47 => ParseFunction::Simple(parse_uint8),
            48 => ParseFunction::Simple(parse_uint8),
            49 => ParseFunction::Simple(StrokeType::parse),
            50 => ParseFunction::Simple(parse_uint8),
            51 => ParseFunction::Simple(parse_uint16),
            52 => ParseFunction::Simple(parse_uint16),
            53 => ParseFunction::Simple(parse_uint8),
            54 => ParseFunction::Simple(parse_uint16),
            55 => ParseFunction::Simple(parse_uint16),
            56 => ParseFunction::Simple(parse_uint16),
            57 => ParseFunction::Simple(parse_uint16),
            58 => ParseFunction::Simple(parse_uint16),
            59 => ParseFunction::Simple(parse_uint16),
            62 => ParseFunction::Simple(DeviceIndex::parse),
            67 => ParseFunction::Simple(parse_sint8),
            68 => ParseFunction::Simple(parse_sint8),
            69 => ParseFunction::Simple(parse_uint8),
            70 => ParseFunction::Simple(parse_uint8),
            71 => ParseFunction::Simple(parse_uint8),
            72 => ParseFunction::Simple(parse_uint8),
            73 => ParseFunction::Simple(parse_uint32),
            78 => ParseFunction::Simple(parse_uint32),
            81 => ParseFunction::Simple(parse_uint8),
            82 => ParseFunction::Simple(parse_uint16),
            83 => ParseFunction::Simple(parse_uint16),
            84 => ParseFunction::Simple(parse_uint16),
            85 => ParseFunction::Simple(parse_uint16),
            87 => ParseFunction::Simple(parse_uint16),
            91 => ParseFunction::Simple(parse_uint32),
            92 => ParseFunction::Simple(parse_uint32),
            93 => ParseFunction::Simple(parse_uint32),
            94 => ParseFunction::Simple(parse_uint32),
            95 => ParseFunction::Simple(parse_uint32),
            96 => ParseFunction::Simple(parse_uint32),
            97 => ParseFunction::Simple(parse_uint8),
            98 => ParseFunction::Simple(parse_uint16),
            99 => ParseFunction::Simple(parse_uint8),
            108 => ParseFunction::Simple(parse_uint16),
            114 => ParseFunction::Simple(parse_float32),
            115 => ParseFunction::Simple(parse_float32),
            116 => ParseFunction::Simple(parse_uint16),
            117 => ParseFunction::Simple(parse_uint16),
            118 => ParseFunction::Simple(parse_uint8),
            119 => ParseFunction::Simple(parse_uint8),
            120 => ParseFunction::Simple(parse_uint8),
            123 => ParseFunction::Simple(parse_uint32),
            124 => ParseFunction::Simple(parse_uint16),
            125 => ParseFunction::Simple(parse_uint16),
            126 => ParseFunction::Simple(parse_uint16),
            127 => ParseFunction::Simple(parse_sint32),
            129 => ParseFunction::Simple(parse_uint8),
            139 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            6 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            9 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            11 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            12 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            17 => Some(ScaleOffset {
                scale: 16_f32,
                offset: 0_f32,
            }),
            32 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            39 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            40 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            41 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            43 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            44 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            45 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            46 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            47 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            48 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            51 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            52 => Some(ScaleOffset {
                scale: 256_f32,
                offset: 0_f32,
            }),
            53 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            54 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            55 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            56 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            57 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            58 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            59 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            69 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            70 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            71 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            72 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            73 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            78 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            81 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            83 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            84 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            85 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            87 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            92 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            93 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            94 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            95 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            96 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            98 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            99 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            108 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            116 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            124 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            125 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            126 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            127 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            129 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            139 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Record(RecordField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum EventField {
    Timestamp,
    Event,
    EventType,
    Data16,
    Data,
    EventGroup,
    Score,
    OpponentScore,
    FrontGearNum,
    FrontGear,
    RearGearNum,
    RearGear,
    DeviceIndex,
    ActivityType,
    StartTimestamp,
    RadarThreatLevelMax,
    RadarThreatCount,
    RadarThreatAvgApproachSpeed,
    RadarThreatMaxApproachSpeed,
    Unknown,
}
impl EventField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Event,
            1 => Self::EventType,
            2 => Self::Data16,
            3 => Self::Data,
            4 => Self::EventGroup,
            7 => Self::Score,
            8 => Self::OpponentScore,
            9 => Self::FrontGearNum,
            10 => Self::FrontGear,
            11 => Self::RearGearNum,
            12 => Self::RearGear,
            13 => Self::DeviceIndex,
            14 => Self::ActivityType,
            15 => Self::StartTimestamp,
            21 => Self::RadarThreatLevelMax,
            22 => Self::RadarThreatCount,
            23 => Self::RadarThreatAvgApproachSpeed,
            24 => Self::RadarThreatMaxApproachSpeed,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(Event::parse),
            1 => ParseFunction::Simple(EventType::parse),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(parse_uint16),
            8 => ParseFunction::Simple(parse_uint16),
            9 => ParseFunction::Simple(parse_unknown),
            10 => ParseFunction::Simple(parse_unknown),
            11 => ParseFunction::Simple(parse_unknown),
            12 => ParseFunction::Simple(parse_unknown),
            13 => ParseFunction::Simple(DeviceIndex::parse),
            14 => ParseFunction::Simple(ActivityType::parse),
            15 => ParseFunction::Simple(DateTime::parse),
            21 => ParseFunction::Simple(RadarThreatLevelType::parse),
            22 => ParseFunction::Simple(parse_uint8),
            23 => ParseFunction::Simple(parse_uint8),
            24 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            23 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            24 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Event(EventField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DeviceInfoField {
    Timestamp,
    DeviceIndex,
    DeviceType,
    Manufacturer,
    SerialNumber,
    Product,
    SoftwareVersion,
    HardwareVersion,
    CumOperatingTime,
    BatteryVoltage,
    BatteryStatus,
    SensorPosition,
    Descriptor,
    AntTransmissionType,
    AntDeviceNumber,
    AntNetwork,
    SourceType,
    ProductName,
    BatteryLevel,
    Unknown,
}
impl DeviceInfoField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::DeviceIndex,
            1 => Self::DeviceType,
            2 => Self::Manufacturer,
            3 => Self::SerialNumber,
            4 => Self::Product,
            5 => Self::SoftwareVersion,
            6 => Self::HardwareVersion,
            7 => Self::CumOperatingTime,
            10 => Self::BatteryVoltage,
            11 => Self::BatteryStatus,
            18 => Self::SensorPosition,
            19 => Self::Descriptor,
            20 => Self::AntTransmissionType,
            21 => Self::AntDeviceNumber,
            22 => Self::AntNetwork,
            25 => Self::SourceType,
            27 => Self::ProductName,
            32 => Self::BatteryLevel,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(DeviceIndex::parse),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(Manufacturer::parse),
            3 => ParseFunction::Simple(parse_unknown),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_uint16),
            6 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(parse_uint32),
            10 => ParseFunction::Simple(parse_uint16),
            11 => ParseFunction::Simple(BatteryStatus::parse),
            18 => ParseFunction::Simple(BodyLocation::parse),
            19 => ParseFunction::Simple(parse_string),
            20 => ParseFunction::Simple(parse_unknown),
            21 => ParseFunction::Simple(parse_unknown),
            22 => ParseFunction::Simple(AntNetwork::parse),
            25 => ParseFunction::Simple(SourceType::parse),
            27 => ParseFunction::Simple(parse_string),
            32 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            5 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            10 => Some(ScaleOffset {
                scale: 256_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::DeviceInfo(DeviceInfoField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DeviceAuxBatteryInfoField {
    Timestamp,
    DeviceIndex,
    BatteryVoltage,
    BatteryStatus,
    BatteryIdentifier,
    Unknown,
}
impl DeviceAuxBatteryInfoField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::DeviceIndex,
            1 => Self::BatteryVoltage,
            2 => Self::BatteryStatus,
            3 => Self::BatteryIdentifier,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(DeviceIndex::parse),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(BatteryStatus::parse),
            3 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            1 => Some(ScaleOffset {
                scale: 256_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::DeviceAuxBatteryInfo(
            DeviceAuxBatteryInfoField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum TrainingFileField {
    Timestamp,
    Type,
    Manufacturer,
    Product,
    SerialNumber,
    TimeCreated,
    Unknown,
}
impl TrainingFileField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Type,
            1 => Self::Manufacturer,
            2 => Self::Product,
            3 => Self::SerialNumber,
            4 => Self::TimeCreated,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(File::parse),
            1 => ParseFunction::Simple(Manufacturer::parse),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_unknown),
            4 => ParseFunction::Simple(DateTime::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::TrainingFile(TrainingFileField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum WeatherConditionsField {
    Timestamp,
    WeatherReport,
    Temperature,
    Condition,
    WindDirection,
    WindSpeed,
    PrecipitationProbability,
    TemperatureFeelsLike,
    RelativeHumidity,
    Location,
    ObservedAtTime,
    ObservedLocationLat,
    ObservedLocationLong,
    DayOfWeek,
    HighTemperature,
    LowTemperature,
    Unknown,
}
impl WeatherConditionsField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::WeatherReport,
            1 => Self::Temperature,
            2 => Self::Condition,
            3 => Self::WindDirection,
            4 => Self::WindSpeed,
            5 => Self::PrecipitationProbability,
            6 => Self::TemperatureFeelsLike,
            7 => Self::RelativeHumidity,
            8 => Self::Location,
            9 => Self::ObservedAtTime,
            10 => Self::ObservedLocationLat,
            11 => Self::ObservedLocationLong,
            12 => Self::DayOfWeek,
            13 => Self::HighTemperature,
            14 => Self::LowTemperature,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(WeatherReport::parse),
            1 => ParseFunction::Simple(parse_sint8),
            2 => ParseFunction::Simple(WeatherStatus::parse),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_uint8),
            6 => ParseFunction::Simple(parse_sint8),
            7 => ParseFunction::Simple(parse_uint8),
            8 => ParseFunction::Simple(parse_string),
            9 => ParseFunction::Simple(DateTime::parse),
            10 => ParseFunction::Simple(parse_sint32),
            11 => ParseFunction::Simple(parse_sint32),
            12 => ParseFunction::Simple(DayOfWeek::parse),
            13 => ParseFunction::Simple(parse_sint8),
            14 => ParseFunction::Simple(parse_sint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            4 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::WeatherConditions(
            WeatherConditionsField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum WeatherAlertField {
    Timestamp,
    ReportId,
    IssueTime,
    ExpireTime,
    Severity,
    Type,
    Unknown,
}
impl WeatherAlertField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ReportId,
            1 => Self::IssueTime,
            2 => Self::ExpireTime,
            3 => Self::Severity,
            4 => Self::Type,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_string),
            1 => ParseFunction::Simple(DateTime::parse),
            2 => ParseFunction::Simple(DateTime::parse),
            3 => ParseFunction::Simple(WeatherSeverity::parse),
            4 => ParseFunction::Simple(WeatherSevereType::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::WeatherAlert(WeatherAlertField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum GpsMetadataField {
    Timestamp,
    TimestampMs,
    PositionLat,
    PositionLong,
    EnhancedAltitude,
    EnhancedSpeed,
    Heading,
    UtcTimestamp,
    Velocity,
    Unknown,
}
impl GpsMetadataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::PositionLat,
            2 => Self::PositionLong,
            3 => Self::EnhancedAltitude,
            4 => Self::EnhancedSpeed,
            5 => Self::Heading,
            6 => Self::UtcTimestamp,
            7 => Self::Velocity,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_sint32),
            2 => ParseFunction::Simple(parse_sint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_uint16),
            6 => ParseFunction::Simple(DateTime::parse),
            7 => ParseFunction::Simple(parse_sint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            3 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            7 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::GpsMetadata(GpsMetadataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum CameraEventField {
    Timestamp,
    TimestampMs,
    CameraEventType,
    CameraFileUuid,
    CameraOrientation,
    Unknown,
}
impl CameraEventField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::CameraEventType,
            2 => Self::CameraFileUuid,
            3 => Self::CameraOrientation,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(CameraEventType::parse),
            2 => ParseFunction::Simple(parse_string),
            3 => ParseFunction::Simple(CameraOrientationType::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::CameraEvent(CameraEventField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum GyroscopeDataField {
    Timestamp,
    TimestampMs,
    SampleTimeOffset,
    GyroX,
    GyroY,
    GyroZ,
    CalibratedGyroX,
    CalibratedGyroY,
    CalibratedGyroZ,
    Unknown,
}
impl GyroscopeDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::SampleTimeOffset,
            2 => Self::GyroX,
            3 => Self::GyroY,
            4 => Self::GyroZ,
            5 => Self::CalibratedGyroX,
            6 => Self::CalibratedGyroY,
            7 => Self::CalibratedGyroZ,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_float32),
            6 => ParseFunction::Simple(parse_float32),
            7 => ParseFunction::Simple(parse_float32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::GyroscopeData(GyroscopeDataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum AccelerometerDataField {
    Timestamp,
    TimestampMs,
    SampleTimeOffset,
    AccelX,
    AccelY,
    AccelZ,
    CalibratedAccelX,
    CalibratedAccelY,
    CalibratedAccelZ,
    CompressedCalibratedAccelX,
    CompressedCalibratedAccelY,
    CompressedCalibratedAccelZ,
    Unknown,
}
impl AccelerometerDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::SampleTimeOffset,
            2 => Self::AccelX,
            3 => Self::AccelY,
            4 => Self::AccelZ,
            5 => Self::CalibratedAccelX,
            6 => Self::CalibratedAccelY,
            7 => Self::CalibratedAccelZ,
            8 => Self::CompressedCalibratedAccelX,
            9 => Self::CompressedCalibratedAccelY,
            10 => Self::CompressedCalibratedAccelZ,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_float32),
            6 => ParseFunction::Simple(parse_float32),
            7 => ParseFunction::Simple(parse_float32),
            8 => ParseFunction::Simple(parse_sint16),
            9 => ParseFunction::Simple(parse_sint16),
            10 => ParseFunction::Simple(parse_sint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::AccelerometerData(
            AccelerometerDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum MagnetometerDataField {
    Timestamp,
    TimestampMs,
    SampleTimeOffset,
    MagX,
    MagY,
    MagZ,
    CalibratedMagX,
    CalibratedMagY,
    CalibratedMagZ,
    Unknown,
}
impl MagnetometerDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::SampleTimeOffset,
            2 => Self::MagX,
            3 => Self::MagY,
            4 => Self::MagZ,
            5 => Self::CalibratedMagX,
            6 => Self::CalibratedMagY,
            7 => Self::CalibratedMagZ,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_float32),
            6 => ParseFunction::Simple(parse_float32),
            7 => ParseFunction::Simple(parse_float32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::MagnetometerData(
            MagnetometerDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum BarometerDataField {
    Timestamp,
    TimestampMs,
    SampleTimeOffset,
    BaroPres,
    Unknown,
}
impl BarometerDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::SampleTimeOffset,
            2 => Self::BaroPres,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::BarometerData(BarometerDataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ThreeDSensorCalibrationField {
    Timestamp,
    SensorType,
    CalibrationFactor,
    CalibrationDivisor,
    LevelShift,
    OffsetCal,
    OrientationMatrix,
    Unknown,
}
impl ThreeDSensorCalibrationField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::SensorType,
            1 => Self::CalibrationFactor,
            2 => Self::CalibrationDivisor,
            3 => Self::LevelShift,
            4 => Self::OffsetCal,
            5 => Self::OrientationMatrix,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(SensorType::parse),
            1 => ParseFunction::Simple(parse_uint32),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_sint32),
            5 => ParseFunction::Simple(parse_sint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            5 => Some(ScaleOffset {
                scale: 65535_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::ThreeDSensorCalibration(
            ThreeDSensorCalibrationField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum OneDSensorCalibrationField {
    Timestamp,
    SensorType,
    CalibrationFactor,
    CalibrationDivisor,
    LevelShift,
    OffsetCal,
    Unknown,
}
impl OneDSensorCalibrationField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::SensorType,
            1 => Self::CalibrationFactor,
            2 => Self::CalibrationDivisor,
            3 => Self::LevelShift,
            4 => Self::OffsetCal,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(SensorType::parse),
            1 => ParseFunction::Simple(parse_uint32),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_sint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::OneDSensorCalibration(
            OneDSensorCalibrationField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum VideoFrameField {
    Timestamp,
    TimestampMs,
    FrameNumber,
    Unknown,
}
impl VideoFrameField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::FrameNumber,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::VideoFrame(VideoFrameField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ObdiiDataField {
    Timestamp,
    TimestampMs,
    TimeOffset,
    Pid,
    RawData,
    PidDataSize,
    SystemTime,
    StartTimestamp,
    StartTimestampMs,
    Unknown,
}
impl ObdiiDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::TimeOffset,
            2 => Self::Pid,
            3 => Self::RawData,
            4 => Self::PidDataSize,
            5 => Self::SystemTime,
            6 => Self::StartTimestamp,
            7 => Self::StartTimestampMs,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_byte),
            3 => ParseFunction::Simple(parse_byte),
            4 => ParseFunction::Simple(parse_uint8),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(DateTime::parse),
            7 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::ObdiiData(ObdiiDataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum NmeaSentenceField {
    Timestamp,
    TimestampMs,
    Sentence,
    Unknown,
}
impl NmeaSentenceField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::Sentence,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::NmeaSentence(NmeaSentenceField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum AviationAttitudeField {
    Timestamp,
    TimestampMs,
    SystemTime,
    Pitch,
    Roll,
    AccelLateral,
    AccelNormal,
    TurnRate,
    Stage,
    AttitudeStageComplete,
    Track,
    Validity,
    Unknown,
}
impl AviationAttitudeField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::SystemTime,
            2 => Self::Pitch,
            3 => Self::Roll,
            4 => Self::AccelLateral,
            5 => Self::AccelNormal,
            6 => Self::TurnRate,
            7 => Self::Stage,
            8 => Self::AttitudeStageComplete,
            9 => Self::Track,
            10 => Self::Validity,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint32),
            2 => ParseFunction::Simple(parse_sint16),
            3 => ParseFunction::Simple(parse_sint16),
            4 => ParseFunction::Simple(parse_sint16),
            5 => ParseFunction::Simple(parse_sint16),
            6 => ParseFunction::Simple(parse_sint16),
            7 => ParseFunction::Simple(AttitudeStage::parse),
            8 => ParseFunction::Simple(parse_uint8),
            9 => ParseFunction::Simple(parse_uint16),
            10 => ParseFunction::Simple(AttitudeValidity::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 10430.38_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 10430.38_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            6 => Some(ScaleOffset {
                scale: 1024_f32,
                offset: 0_f32,
            }),
            9 => Some(ScaleOffset {
                scale: 10430.38_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::AviationAttitude(
            AviationAttitudeField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum VideoField {
    Url,
    HostingProvider,
    Duration,
    Unknown,
}
impl VideoField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::Url,
            1 => Self::HostingProvider,
            2 => Self::Duration,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_string),
            1 => ParseFunction::Simple(parse_string),
            2 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum VideoTitleField {
    MessageIndex,
    MessageCount,
    Text,
    Unknown,
}
impl VideoTitleField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::MessageCount,
            1 => Self::Text,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum VideoDescriptionField {
    MessageIndex,
    MessageCount,
    Text,
    Unknown,
}
impl VideoDescriptionField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::MessageCount,
            1 => Self::Text,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum VideoClipField {
    ClipNumber,
    StartTimestamp,
    StartTimestampMs,
    EndTimestamp,
    EndTimestampMs,
    ClipStart,
    ClipEnd,
    Unknown,
}
impl VideoClipField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::ClipNumber,
            1 => Self::StartTimestamp,
            2 => Self::StartTimestampMs,
            3 => Self::EndTimestamp,
            4 => Self::EndTimestampMs,
            6 => Self::ClipStart,
            7 => Self::ClipEnd,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(DateTime::parse),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(DateTime::parse),
            4 => ParseFunction::Simple(parse_uint16),
            6 => ParseFunction::Simple(parse_uint32),
            7 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SetField {
    Timestamp,
    Duration,
    Repetitions,
    Weight,
    SetType,
    StartTime,
    Category,
    CategorySubtype,
    WeightDisplayUnit,
    MessageIndex,
    WktStepIndex,
    Unknown,
}
impl SetField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::Timestamp,
            0 => Self::Duration,
            3 => Self::Repetitions,
            4 => Self::Weight,
            5 => Self::SetType,
            6 => Self::StartTime,
            7 => Self::Category,
            8 => Self::CategorySubtype,
            9 => Self::WeightDisplayUnit,
            10 => Self::MessageIndex,
            11 => Self::WktStepIndex,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(SetType::parse),
            6 => ParseFunction::Simple(DateTime::parse),
            7 => ParseFunction::Simple(ExerciseCategory::parse),
            8 => ParseFunction::Simple(parse_uint16),
            9 => ParseFunction::Simple(FitBaseUnit::parse),
            10 => ParseFunction::Simple(MessageIndex::parse),
            11 => ParseFunction::Simple(MessageIndex::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 16_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Set(SetField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum JumpField {
    Timestamp,
    Distance,
    Height,
    Rotations,
    HangTime,
    Score,
    PositionLat,
    PositionLong,
    Speed,
    EnhancedSpeed,
    Unknown,
}
impl JumpField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Distance,
            1 => Self::Height,
            2 => Self::Rotations,
            3 => Self::HangTime,
            4 => Self::Score,
            5 => Self::PositionLat,
            6 => Self::PositionLong,
            7 => Self::Speed,
            8 => Self::EnhancedSpeed,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_float32),
            1 => ParseFunction::Simple(parse_float32),
            2 => ParseFunction::Simple(parse_uint8),
            3 => ParseFunction::Simple(parse_float32),
            4 => ParseFunction::Simple(parse_float32),
            5 => ParseFunction::Simple(parse_sint32),
            6 => ParseFunction::Simple(parse_sint32),
            7 => ParseFunction::Simple(parse_uint16),
            8 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            7 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            8 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Jump(JumpField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SplitField {
    MessageIndex,
    SplitType,
    TotalElapsedTime,
    TotalTimerTime,
    TotalDistance,
    AvgSpeed,
    StartTime,
    TotalAscent,
    TotalDescent,
    StartPositionLat,
    StartPositionLong,
    EndPositionLat,
    EndPositionLong,
    MaxSpeed,
    AvgVertSpeed,
    EndTime,
    TotalCalories,
    StartElevation,
    TotalMovingTime,
    Unknown,
}
impl SplitField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::SplitType,
            1 => Self::TotalElapsedTime,
            2 => Self::TotalTimerTime,
            3 => Self::TotalDistance,
            4 => Self::AvgSpeed,
            9 => Self::StartTime,
            13 => Self::TotalAscent,
            14 => Self::TotalDescent,
            21 => Self::StartPositionLat,
            22 => Self::StartPositionLong,
            23 => Self::EndPositionLat,
            24 => Self::EndPositionLong,
            25 => Self::MaxSpeed,
            26 => Self::AvgVertSpeed,
            27 => Self::EndTime,
            28 => Self::TotalCalories,
            74 => Self::StartElevation,
            110 => Self::TotalMovingTime,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(SplitType::parse),
            1 => ParseFunction::Simple(parse_uint32),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint32),
            9 => ParseFunction::Simple(DateTime::parse),
            13 => ParseFunction::Simple(parse_uint16),
            14 => ParseFunction::Simple(parse_uint16),
            21 => ParseFunction::Simple(parse_sint32),
            22 => ParseFunction::Simple(parse_sint32),
            23 => ParseFunction::Simple(parse_sint32),
            24 => ParseFunction::Simple(parse_sint32),
            25 => ParseFunction::Simple(parse_uint32),
            26 => ParseFunction::Simple(parse_sint32),
            27 => ParseFunction::Simple(DateTime::parse),
            28 => ParseFunction::Simple(parse_uint32),
            74 => ParseFunction::Simple(parse_uint32),
            110 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            1 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            2 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            25 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            26 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            74 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            110 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SplitSummaryField {
    MessageIndex,
    SplitType,
    NumSplits,
    TotalTimerTime,
    TotalDistance,
    AvgSpeed,
    MaxSpeed,
    TotalAscent,
    TotalDescent,
    AvgHeartRate,
    MaxHeartRate,
    AvgVertSpeed,
    TotalCalories,
    TotalMovingTime,
    Unknown,
}
impl SplitSummaryField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::SplitType,
            3 => Self::NumSplits,
            4 => Self::TotalTimerTime,
            5 => Self::TotalDistance,
            6 => Self::AvgSpeed,
            7 => Self::MaxSpeed,
            8 => Self::TotalAscent,
            9 => Self::TotalDescent,
            10 => Self::AvgHeartRate,
            11 => Self::MaxHeartRate,
            12 => Self::AvgVertSpeed,
            13 => Self::TotalCalories,
            77 => Self::TotalMovingTime,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(SplitType::parse),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(parse_uint32),
            7 => ParseFunction::Simple(parse_uint32),
            8 => ParseFunction::Simple(parse_uint16),
            9 => ParseFunction::Simple(parse_uint16),
            10 => ParseFunction::Simple(parse_uint8),
            11 => ParseFunction::Simple(parse_uint8),
            12 => ParseFunction::Simple(parse_sint32),
            13 => ParseFunction::Simple(parse_uint32),
            77 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            4 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            6 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            7 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            12 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            77 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ClimbProField {
    Timestamp,
    PositionLat,
    PositionLong,
    ClimbProEvent,
    ClimbNumber,
    ClimbCategory,
    CurrentDist,
    Unknown,
}
impl ClimbProField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::PositionLat,
            1 => Self::PositionLong,
            2 => Self::ClimbProEvent,
            3 => Self::ClimbNumber,
            4 => Self::ClimbCategory,
            5 => Self::CurrentDist,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_sint32),
            1 => ParseFunction::Simple(parse_sint32),
            2 => ParseFunction::Simple(ClimbProEvent::parse),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint8),
            5 => ParseFunction::Simple(parse_float32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::ClimbPro(ClimbProField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum FieldDescriptionField {
    DeveloperDataIndex,
    FieldDefinitionNumber,
    FitBaseTypeId,
    FieldName,
    Array,
    Components,
    Scale,
    Offset,
    Units,
    Bits,
    Accumulate,
    FitBaseUnitId,
    NativeMesgNum,
    NativeFieldNum,
    Unknown,
}
impl FieldDescriptionField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::DeveloperDataIndex,
            1 => Self::FieldDefinitionNumber,
            2 => Self::FitBaseTypeId,
            3 => Self::FieldName,
            4 => Self::Array,
            5 => Self::Components,
            6 => Self::Scale,
            7 => Self::Offset,
            8 => Self::Units,
            9 => Self::Bits,
            10 => Self::Accumulate,
            13 => Self::FitBaseUnitId,
            14 => Self::NativeMesgNum,
            15 => Self::NativeFieldNum,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(FitBaseType::parse),
            3 => ParseFunction::Simple(parse_string),
            4 => ParseFunction::Simple(parse_uint8),
            5 => ParseFunction::Simple(parse_string),
            6 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(parse_sint8),
            8 => ParseFunction::Simple(parse_string),
            9 => ParseFunction::Simple(parse_string),
            10 => ParseFunction::Simple(parse_string),
            13 => ParseFunction::Simple(FitBaseUnit::parse),
            14 => ParseFunction::Simple(MesgNum::parse),
            15 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DeveloperDataIdField {
    DeveloperId,
    ApplicationId,
    ManufacturerId,
    DeveloperDataIndex,
    ApplicationVersion,
    Unknown,
}
impl DeveloperDataIdField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::DeveloperId,
            1 => Self::ApplicationId,
            2 => Self::ManufacturerId,
            3 => Self::DeveloperDataIndex,
            4 => Self::ApplicationVersion,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_byte),
            1 => ParseFunction::Simple(parse_byte),
            2 => ParseFunction::Simple(Manufacturer::parse),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum CourseField {
    Sport,
    Name,
    Capabilities,
    SubSport,
    Unknown,
}
impl CourseField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            4 => Self::Sport,
            5 => Self::Name,
            6 => Self::Capabilities,
            7 => Self::SubSport,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            4 => ParseFunction::Simple(Sport::parse),
            5 => ParseFunction::Simple(parse_string),
            6 => ParseFunction::Simple(CourseCapabilities::parse),
            7 => ParseFunction::Simple(SubSport::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum CoursePointField {
    MessageIndex,
    Timestamp,
    PositionLat,
    PositionLong,
    Distance,
    Type,
    Name,
    Favorite,
    Unknown,
}
impl CoursePointField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            1 => Self::Timestamp,
            2 => Self::PositionLat,
            3 => Self::PositionLong,
            4 => Self::Distance,
            5 => Self::Type,
            6 => Self::Name,
            8 => Self::Favorite,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            1 => ParseFunction::Simple(DateTime::parse),
            2 => ParseFunction::Simple(parse_sint32),
            3 => ParseFunction::Simple(parse_sint32),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(CoursePoint::parse),
            6 => ParseFunction::Simple(parse_string),
            8 => ParseFunction::Simple(parse_unknown),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            4 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::CoursePoint(CoursePointField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SegmentIdField {
    Name,
    Uuid,
    Sport,
    Enabled,
    UserProfilePrimaryKey,
    DeviceId,
    DefaultRaceLeader,
    DeleteStatus,
    SelectionType,
    Unknown,
}
impl SegmentIdField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::Name,
            1 => Self::Uuid,
            2 => Self::Sport,
            3 => Self::Enabled,
            4 => Self::UserProfilePrimaryKey,
            5 => Self::DeviceId,
            6 => Self::DefaultRaceLeader,
            7 => Self::DeleteStatus,
            8 => Self::SelectionType,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_string),
            1 => ParseFunction::Simple(parse_string),
            2 => ParseFunction::Simple(Sport::parse),
            3 => ParseFunction::Simple(parse_unknown),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(SegmentDeleteStatus::parse),
            8 => ParseFunction::Simple(SegmentSelectionType::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SegmentLeaderboardEntryField {
    MessageIndex,
    Name,
    Type,
    GroupPrimaryKey,
    ActivityId,
    SegmentTime,
    ActivityIdString,
    Unknown,
}
impl SegmentLeaderboardEntryField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Name,
            1 => Self::Type,
            2 => Self::GroupPrimaryKey,
            3 => Self::ActivityId,
            4 => Self::SegmentTime,
            5 => Self::ActivityIdString,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_string),
            1 => ParseFunction::Simple(SegmentLeaderboardType::parse),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            4 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SegmentPointField {
    MessageIndex,
    PositionLat,
    PositionLong,
    Distance,
    Altitude,
    LeaderTime,
    EnhancedAltitude,
    Unknown,
}
impl SegmentPointField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            1 => Self::PositionLat,
            2 => Self::PositionLong,
            3 => Self::Distance,
            4 => Self::Altitude,
            5 => Self::LeaderTime,
            6 => Self::EnhancedAltitude,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            1 => ParseFunction::Simple(parse_sint32),
            2 => ParseFunction::Simple(parse_sint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            3 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            6 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SegmentLapField {
    MessageIndex,
    Timestamp,
    Event,
    EventType,
    StartTime,
    StartPositionLat,
    StartPositionLong,
    EndPositionLat,
    EndPositionLong,
    TotalElapsedTime,
    TotalTimerTime,
    TotalDistance,
    TotalCycles,
    TotalCalories,
    TotalFatCalories,
    AvgSpeed,
    MaxSpeed,
    AvgHeartRate,
    MaxHeartRate,
    AvgCadence,
    MaxCadence,
    AvgPower,
    MaxPower,
    TotalAscent,
    TotalDescent,
    Sport,
    EventGroup,
    NecLat,
    NecLong,
    SwcLat,
    SwcLong,
    Name,
    NormalizedPower,
    LeftRightBalance,
    SubSport,
    TotalWork,
    AvgAltitude,
    MaxAltitude,
    GpsAccuracy,
    AvgGrade,
    AvgPosGrade,
    AvgNegGrade,
    MaxPosGrade,
    MaxNegGrade,
    AvgTemperature,
    MaxTemperature,
    TotalMovingTime,
    AvgPosVerticalSpeed,
    AvgNegVerticalSpeed,
    MaxPosVerticalSpeed,
    MaxNegVerticalSpeed,
    TimeInHrZone,
    TimeInSpeedZone,
    TimeInCadenceZone,
    TimeInPowerZone,
    RepetitionNum,
    MinAltitude,
    MinHeartRate,
    ActiveTime,
    WktStepIndex,
    SportEvent,
    AvgLeftTorqueEffectiveness,
    AvgRightTorqueEffectiveness,
    AvgLeftPedalSmoothness,
    AvgRightPedalSmoothness,
    AvgCombinedPedalSmoothness,
    Status,
    Uuid,
    AvgFractionalCadence,
    MaxFractionalCadence,
    TotalFractionalCycles,
    FrontGearShiftCount,
    RearGearShiftCount,
    TimeStanding,
    StandCount,
    AvgLeftPco,
    AvgRightPco,
    AvgLeftPowerPhase,
    AvgLeftPowerPhasePeak,
    AvgRightPowerPhase,
    AvgRightPowerPhasePeak,
    AvgPowerPosition,
    MaxPowerPosition,
    AvgCadencePosition,
    MaxCadencePosition,
    Manufacturer,
    TotalGrit,
    TotalFlow,
    AvgGrit,
    AvgFlow,
    TotalFractionalAscent,
    TotalFractionalDescent,
    EnhancedAvgAltitude,
    EnhancedMaxAltitude,
    EnhancedMinAltitude,
    Unknown,
}
impl SegmentLapField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            253 => Self::Timestamp,
            0 => Self::Event,
            1 => Self::EventType,
            2 => Self::StartTime,
            3 => Self::StartPositionLat,
            4 => Self::StartPositionLong,
            5 => Self::EndPositionLat,
            6 => Self::EndPositionLong,
            7 => Self::TotalElapsedTime,
            8 => Self::TotalTimerTime,
            9 => Self::TotalDistance,
            10 => Self::TotalCycles,
            11 => Self::TotalCalories,
            12 => Self::TotalFatCalories,
            13 => Self::AvgSpeed,
            14 => Self::MaxSpeed,
            15 => Self::AvgHeartRate,
            16 => Self::MaxHeartRate,
            17 => Self::AvgCadence,
            18 => Self::MaxCadence,
            19 => Self::AvgPower,
            20 => Self::MaxPower,
            21 => Self::TotalAscent,
            22 => Self::TotalDescent,
            23 => Self::Sport,
            24 => Self::EventGroup,
            25 => Self::NecLat,
            26 => Self::NecLong,
            27 => Self::SwcLat,
            28 => Self::SwcLong,
            29 => Self::Name,
            30 => Self::NormalizedPower,
            31 => Self::LeftRightBalance,
            32 => Self::SubSport,
            33 => Self::TotalWork,
            34 => Self::AvgAltitude,
            35 => Self::MaxAltitude,
            36 => Self::GpsAccuracy,
            37 => Self::AvgGrade,
            38 => Self::AvgPosGrade,
            39 => Self::AvgNegGrade,
            40 => Self::MaxPosGrade,
            41 => Self::MaxNegGrade,
            42 => Self::AvgTemperature,
            43 => Self::MaxTemperature,
            44 => Self::TotalMovingTime,
            45 => Self::AvgPosVerticalSpeed,
            46 => Self::AvgNegVerticalSpeed,
            47 => Self::MaxPosVerticalSpeed,
            48 => Self::MaxNegVerticalSpeed,
            49 => Self::TimeInHrZone,
            50 => Self::TimeInSpeedZone,
            51 => Self::TimeInCadenceZone,
            52 => Self::TimeInPowerZone,
            53 => Self::RepetitionNum,
            54 => Self::MinAltitude,
            55 => Self::MinHeartRate,
            56 => Self::ActiveTime,
            57 => Self::WktStepIndex,
            58 => Self::SportEvent,
            59 => Self::AvgLeftTorqueEffectiveness,
            60 => Self::AvgRightTorqueEffectiveness,
            61 => Self::AvgLeftPedalSmoothness,
            62 => Self::AvgRightPedalSmoothness,
            63 => Self::AvgCombinedPedalSmoothness,
            64 => Self::Status,
            65 => Self::Uuid,
            66 => Self::AvgFractionalCadence,
            67 => Self::MaxFractionalCadence,
            68 => Self::TotalFractionalCycles,
            69 => Self::FrontGearShiftCount,
            70 => Self::RearGearShiftCount,
            71 => Self::TimeStanding,
            72 => Self::StandCount,
            73 => Self::AvgLeftPco,
            74 => Self::AvgRightPco,
            75 => Self::AvgLeftPowerPhase,
            76 => Self::AvgLeftPowerPhasePeak,
            77 => Self::AvgRightPowerPhase,
            78 => Self::AvgRightPowerPhasePeak,
            79 => Self::AvgPowerPosition,
            80 => Self::MaxPowerPosition,
            81 => Self::AvgCadencePosition,
            82 => Self::MaxCadencePosition,
            83 => Self::Manufacturer,
            84 => Self::TotalGrit,
            85 => Self::TotalFlow,
            86 => Self::AvgGrit,
            87 => Self::AvgFlow,
            89 => Self::TotalFractionalAscent,
            90 => Self::TotalFractionalDescent,
            91 => Self::EnhancedAvgAltitude,
            92 => Self::EnhancedMaxAltitude,
            93 => Self::EnhancedMinAltitude,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(Event::parse),
            1 => ParseFunction::Simple(EventType::parse),
            2 => ParseFunction::Simple(DateTime::parse),
            3 => ParseFunction::Simple(parse_sint32),
            4 => ParseFunction::Simple(parse_sint32),
            5 => ParseFunction::Simple(parse_sint32),
            6 => ParseFunction::Simple(parse_sint32),
            7 => ParseFunction::Simple(parse_uint32),
            8 => ParseFunction::Simple(parse_uint32),
            9 => ParseFunction::Simple(parse_uint32),
            10 => ParseFunction::Simple(parse_uint32),
            11 => ParseFunction::Simple(parse_uint16),
            12 => ParseFunction::Simple(parse_uint16),
            13 => ParseFunction::Simple(parse_uint16),
            14 => ParseFunction::Simple(parse_uint16),
            15 => ParseFunction::Simple(parse_uint8),
            16 => ParseFunction::Simple(parse_uint8),
            17 => ParseFunction::Simple(parse_uint8),
            18 => ParseFunction::Simple(parse_uint8),
            19 => ParseFunction::Simple(parse_uint16),
            20 => ParseFunction::Simple(parse_uint16),
            21 => ParseFunction::Simple(parse_uint16),
            22 => ParseFunction::Simple(parse_uint16),
            23 => ParseFunction::Simple(Sport::parse),
            24 => ParseFunction::Simple(parse_uint8),
            25 => ParseFunction::Simple(parse_sint32),
            26 => ParseFunction::Simple(parse_sint32),
            27 => ParseFunction::Simple(parse_sint32),
            28 => ParseFunction::Simple(parse_sint32),
            29 => ParseFunction::Simple(parse_string),
            30 => ParseFunction::Simple(parse_uint16),
            31 => ParseFunction::Simple(LeftRightBalance100::parse),
            32 => ParseFunction::Simple(SubSport::parse),
            33 => ParseFunction::Simple(parse_uint32),
            34 => ParseFunction::Simple(parse_uint16),
            35 => ParseFunction::Simple(parse_uint16),
            36 => ParseFunction::Simple(parse_uint8),
            37 => ParseFunction::Simple(parse_sint16),
            38 => ParseFunction::Simple(parse_sint16),
            39 => ParseFunction::Simple(parse_sint16),
            40 => ParseFunction::Simple(parse_sint16),
            41 => ParseFunction::Simple(parse_sint16),
            42 => ParseFunction::Simple(parse_sint8),
            43 => ParseFunction::Simple(parse_sint8),
            44 => ParseFunction::Simple(parse_uint32),
            45 => ParseFunction::Simple(parse_sint16),
            46 => ParseFunction::Simple(parse_sint16),
            47 => ParseFunction::Simple(parse_sint16),
            48 => ParseFunction::Simple(parse_sint16),
            49 => ParseFunction::Simple(parse_uint32),
            50 => ParseFunction::Simple(parse_uint32),
            51 => ParseFunction::Simple(parse_uint32),
            52 => ParseFunction::Simple(parse_uint32),
            53 => ParseFunction::Simple(parse_uint16),
            54 => ParseFunction::Simple(parse_uint16),
            55 => ParseFunction::Simple(parse_uint8),
            56 => ParseFunction::Simple(parse_uint32),
            57 => ParseFunction::Simple(MessageIndex::parse),
            58 => ParseFunction::Simple(SportEvent::parse),
            59 => ParseFunction::Simple(parse_uint8),
            60 => ParseFunction::Simple(parse_uint8),
            61 => ParseFunction::Simple(parse_uint8),
            62 => ParseFunction::Simple(parse_uint8),
            63 => ParseFunction::Simple(parse_uint8),
            64 => ParseFunction::Simple(SegmentLapStatus::parse),
            65 => ParseFunction::Simple(parse_string),
            66 => ParseFunction::Simple(parse_uint8),
            67 => ParseFunction::Simple(parse_uint8),
            68 => ParseFunction::Simple(parse_uint8),
            69 => ParseFunction::Simple(parse_uint16),
            70 => ParseFunction::Simple(parse_uint16),
            71 => ParseFunction::Simple(parse_uint32),
            72 => ParseFunction::Simple(parse_uint16),
            73 => ParseFunction::Simple(parse_sint8),
            74 => ParseFunction::Simple(parse_sint8),
            75 => ParseFunction::Simple(parse_uint8),
            76 => ParseFunction::Simple(parse_uint8),
            77 => ParseFunction::Simple(parse_uint8),
            78 => ParseFunction::Simple(parse_uint8),
            79 => ParseFunction::Simple(parse_uint16),
            80 => ParseFunction::Simple(parse_uint16),
            81 => ParseFunction::Simple(parse_uint8),
            82 => ParseFunction::Simple(parse_uint8),
            83 => ParseFunction::Simple(Manufacturer::parse),
            84 => ParseFunction::Simple(parse_float32),
            85 => ParseFunction::Simple(parse_float32),
            86 => ParseFunction::Simple(parse_float32),
            87 => ParseFunction::Simple(parse_float32),
            89 => ParseFunction::Simple(parse_uint8),
            90 => ParseFunction::Simple(parse_uint8),
            91 => ParseFunction::Simple(parse_uint32),
            92 => ParseFunction::Simple(parse_uint32),
            93 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            7 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            8 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            9 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            13 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            14 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            34 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            35 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            37 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            38 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            39 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            40 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            41 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            44 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            45 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            46 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            47 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            48 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            49 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            50 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            51 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            52 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            54 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            56 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            59 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            60 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            61 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            62 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            63 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            66 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            67 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            68 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            71 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            75 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            76 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            77 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            78 => Some(ScaleOffset {
                scale: 0.7111111_f32,
                offset: 0_f32,
            }),
            89 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            90 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            91 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            92 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            93 => Some(ScaleOffset {
                scale: 5_f32,
                offset: 500_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::SegmentLap(SegmentLapField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SegmentFileField {
    MessageIndex,
    FileUuid,
    Enabled,
    UserProfilePrimaryKey,
    LeaderType,
    LeaderGroupPrimaryKey,
    LeaderActivityId,
    LeaderActivityIdString,
    DefaultRaceLeader,
    Unknown,
}
impl SegmentFileField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            1 => Self::FileUuid,
            3 => Self::Enabled,
            4 => Self::UserProfilePrimaryKey,
            7 => Self::LeaderType,
            8 => Self::LeaderGroupPrimaryKey,
            9 => Self::LeaderActivityId,
            10 => Self::LeaderActivityIdString,
            11 => Self::DefaultRaceLeader,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            1 => ParseFunction::Simple(parse_string),
            3 => ParseFunction::Simple(parse_unknown),
            4 => ParseFunction::Simple(parse_uint32),
            7 => ParseFunction::Simple(SegmentLeaderboardType::parse),
            8 => ParseFunction::Simple(parse_uint32),
            9 => ParseFunction::Simple(parse_uint32),
            10 => ParseFunction::Simple(parse_string),
            11 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum WorkoutField {
    MessageIndex,
    Sport,
    Capabilities,
    NumValidSteps,
    WktName,
    SubSport,
    PoolLength,
    PoolLengthUnit,
    WktDescription,
    Unknown,
}
impl WorkoutField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            4 => Self::Sport,
            5 => Self::Capabilities,
            6 => Self::NumValidSteps,
            8 => Self::WktName,
            11 => Self::SubSport,
            14 => Self::PoolLength,
            15 => Self::PoolLengthUnit,
            17 => Self::WktDescription,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            4 => ParseFunction::Simple(Sport::parse),
            5 => ParseFunction::Simple(WorkoutCapabilities::parse),
            6 => ParseFunction::Simple(parse_uint16),
            8 => ParseFunction::Simple(parse_string),
            11 => ParseFunction::Simple(SubSport::parse),
            14 => ParseFunction::Simple(parse_uint16),
            15 => ParseFunction::Simple(DisplayMeasure::parse),
            17 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            14 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum WorkoutSessionField {
    MessageIndex,
    Sport,
    SubSport,
    NumValidSteps,
    FirstStepIndex,
    PoolLength,
    PoolLengthUnit,
    Unknown,
}
impl WorkoutSessionField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::Sport,
            1 => Self::SubSport,
            2 => Self::NumValidSteps,
            3 => Self::FirstStepIndex,
            4 => Self::PoolLength,
            5 => Self::PoolLengthUnit,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(Sport::parse),
            1 => ParseFunction::Simple(SubSport::parse),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(DisplayMeasure::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            4 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum WorkoutStepField {
    MessageIndex,
    WktStepName,
    DurationType,
    DurationValue,
    TargetType,
    TargetValue,
    CustomTargetValueLow,
    CustomTargetValueHigh,
    Intensity,
    Notes,
    Equipment,
    ExerciseCategory,
    ExerciseName,
    ExerciseWeight,
    WeightDisplayUnit,
    SecondaryTargetType,
    SecondaryTargetValue,
    SecondaryCustomTargetValueLow,
    SecondaryCustomTargetValueHigh,
    Unknown,
}
impl WorkoutStepField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::WktStepName,
            1 => Self::DurationType,
            2 => Self::DurationValue,
            3 => Self::TargetType,
            4 => Self::TargetValue,
            5 => Self::CustomTargetValueLow,
            6 => Self::CustomTargetValueHigh,
            7 => Self::Intensity,
            8 => Self::Notes,
            9 => Self::Equipment,
            10 => Self::ExerciseCategory,
            11 => Self::ExerciseName,
            12 => Self::ExerciseWeight,
            13 => Self::WeightDisplayUnit,
            19 => Self::SecondaryTargetType,
            20 => Self::SecondaryTargetValue,
            21 => Self::SecondaryCustomTargetValueLow,
            22 => Self::SecondaryCustomTargetValueHigh,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(parse_string),
            1 => ParseFunction::Simple(WktStepDuration::parse),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(WktStepTarget::parse),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(parse_uint32),
            7 => ParseFunction::Simple(Intensity::parse),
            8 => ParseFunction::Simple(parse_string),
            9 => ParseFunction::Simple(WorkoutEquipment::parse),
            10 => ParseFunction::Simple(ExerciseCategory::parse),
            11 => ParseFunction::Simple(parse_uint16),
            12 => ParseFunction::Simple(parse_uint16),
            13 => ParseFunction::Simple(FitBaseUnit::parse),
            19 => ParseFunction::Simple(WktStepTarget::parse),
            20 => ParseFunction::Simple(parse_uint32),
            21 => ParseFunction::Simple(parse_uint32),
            22 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            12 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ExerciseTitleField {
    MessageIndex,
    ExerciseCategory,
    ExerciseName,
    WktStepName,
    Unknown,
}
impl ExerciseTitleField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            0 => Self::ExerciseCategory,
            1 => Self::ExerciseName,
            2 => Self::WktStepName,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            0 => ParseFunction::Simple(ExerciseCategory::parse),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ScheduleField {
    Manufacturer,
    Product,
    SerialNumber,
    TimeCreated,
    Completed,
    Type,
    ScheduledTime,
    Unknown,
}
impl ScheduleField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::Manufacturer,
            1 => Self::Product,
            2 => Self::SerialNumber,
            3 => Self::TimeCreated,
            4 => Self::Completed,
            5 => Self::Type,
            6 => Self::ScheduledTime,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(Manufacturer::parse),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_unknown),
            3 => ParseFunction::Simple(DateTime::parse),
            4 => ParseFunction::Simple(parse_unknown),
            5 => ParseFunction::Simple(Schedule::parse),
            6 => ParseFunction::Simple(LocalDateTime::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum TotalsField {
    MessageIndex,
    Timestamp,
    TimerTime,
    Distance,
    Calories,
    Sport,
    ElapsedTime,
    Sessions,
    ActiveTime,
    SportIndex,
    Unknown,
}
impl TotalsField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            254 => Self::MessageIndex,
            253 => Self::Timestamp,
            0 => Self::TimerTime,
            1 => Self::Distance,
            2 => Self::Calories,
            3 => Self::Sport,
            4 => Self::ElapsedTime,
            5 => Self::Sessions,
            6 => Self::ActiveTime,
            9 => Self::SportIndex,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            254 => ParseFunction::Simple(MessageIndex::parse),
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint32),
            1 => ParseFunction::Simple(parse_uint32),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(Sport::parse),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_uint16),
            6 => ParseFunction::Simple(parse_uint32),
            9 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Totals(TotalsField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum WeightScaleField {
    Timestamp,
    Weight,
    PercentFat,
    PercentHydration,
    VisceralFatMass,
    BoneMass,
    MuscleMass,
    BasalMet,
    PhysiqueRating,
    ActiveMet,
    MetabolicAge,
    VisceralFatRating,
    UserProfileIndex,
    Bmi,
    Unknown,
}
impl WeightScaleField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Weight,
            1 => Self::PercentFat,
            2 => Self::PercentHydration,
            3 => Self::VisceralFatMass,
            4 => Self::BoneMass,
            5 => Self::MuscleMass,
            7 => Self::BasalMet,
            8 => Self::PhysiqueRating,
            9 => Self::ActiveMet,
            10 => Self::MetabolicAge,
            11 => Self::VisceralFatRating,
            12 => Self::UserProfileIndex,
            13 => Self::Bmi,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(Weight::parse),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_uint16),
            7 => ParseFunction::Simple(parse_uint16),
            8 => ParseFunction::Simple(parse_uint8),
            9 => ParseFunction::Simple(parse_uint16),
            10 => ParseFunction::Simple(parse_uint8),
            11 => ParseFunction::Simple(parse_uint8),
            12 => ParseFunction::Simple(MessageIndex::parse),
            13 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            1 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            2 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            7 => Some(ScaleOffset {
                scale: 4_f32,
                offset: 0_f32,
            }),
            9 => Some(ScaleOffset {
                scale: 4_f32,
                offset: 0_f32,
            }),
            13 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::WeightScale(WeightScaleField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum BloodPressureField {
    Timestamp,
    SystolicPressure,
    DiastolicPressure,
    MeanArterialPressure,
    Map3SampleMean,
    MapMorningValues,
    MapEveningValues,
    HeartRate,
    HeartRateType,
    Status,
    UserProfileIndex,
    Unknown,
}
impl BloodPressureField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::SystolicPressure,
            1 => Self::DiastolicPressure,
            2 => Self::MeanArterialPressure,
            3 => Self::Map3SampleMean,
            4 => Self::MapMorningValues,
            5 => Self::MapEveningValues,
            6 => Self::HeartRate,
            7 => Self::HeartRateType,
            8 => Self::Status,
            9 => Self::UserProfileIndex,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_uint16),
            6 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(HrType::parse),
            8 => ParseFunction::Simple(BpStatus::parse),
            9 => ParseFunction::Simple(MessageIndex::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::BloodPressure(BloodPressureField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum MonitoringInfoField {
    Timestamp,
    LocalTimestamp,
    ActivityType,
    CyclesToDistance,
    CyclesToCalories,
    RestingMetabolicRate,
    Unknown,
}
impl MonitoringInfoField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::LocalTimestamp,
            1 => Self::ActivityType,
            3 => Self::CyclesToDistance,
            4 => Self::CyclesToCalories,
            5 => Self::RestingMetabolicRate,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(LocalDateTime::parse),
            1 => ParseFunction::Simple(ActivityType::parse),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            3 => Some(ScaleOffset {
                scale: 5000_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 5000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::MonitoringInfo(MonitoringInfoField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum MonitoringField {
    Timestamp,
    DeviceIndex,
    Calories,
    Distance,
    Cycles,
    ActiveTime,
    ActivityType,
    ActivitySubtype,
    ActivityLevel,
    Distance16,
    Cycles16,
    ActiveTime16,
    LocalTimestamp,
    Temperature,
    TemperatureMin,
    TemperatureMax,
    ActivityTime,
    ActiveCalories,
    CurrentActivityTypeIntensity,
    TimestampMin8,
    Timestamp16,
    HeartRate,
    Intensity,
    DurationMin,
    Duration,
    Ascent,
    Descent,
    ModerateActivityMinutes,
    VigorousActivityMinutes,
    Unknown,
}
impl MonitoringField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::DeviceIndex,
            1 => Self::Calories,
            2 => Self::Distance,
            3 => Self::Cycles,
            4 => Self::ActiveTime,
            5 => Self::ActivityType,
            6 => Self::ActivitySubtype,
            7 => Self::ActivityLevel,
            8 => Self::Distance16,
            9 => Self::Cycles16,
            10 => Self::ActiveTime16,
            11 => Self::LocalTimestamp,
            12 => Self::Temperature,
            14 => Self::TemperatureMin,
            15 => Self::TemperatureMax,
            16 => Self::ActivityTime,
            19 => Self::ActiveCalories,
            24 => Self::CurrentActivityTypeIntensity,
            25 => Self::TimestampMin8,
            26 => Self::Timestamp16,
            27 => Self::HeartRate,
            28 => Self::Intensity,
            29 => Self::DurationMin,
            30 => Self::Duration,
            31 => Self::Ascent,
            32 => Self::Descent,
            33 => Self::ModerateActivityMinutes,
            34 => Self::VigorousActivityMinutes,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(DeviceIndex::parse),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(ActivityType::parse),
            6 => ParseFunction::Simple(ActivitySubtype::parse),
            7 => ParseFunction::Simple(ActivityLevel::parse),
            8 => ParseFunction::Simple(parse_uint16),
            9 => ParseFunction::Simple(parse_uint16),
            10 => ParseFunction::Simple(parse_uint16),
            11 => ParseFunction::Simple(LocalDateTime::parse),
            12 => ParseFunction::Simple(parse_sint16),
            14 => ParseFunction::Simple(parse_sint16),
            15 => ParseFunction::Simple(parse_sint16),
            16 => ParseFunction::Simple(parse_uint16),
            19 => ParseFunction::Simple(parse_uint16),
            24 => ParseFunction::Simple(parse_byte),
            25 => ParseFunction::Simple(parse_uint8),
            26 => ParseFunction::Simple(parse_uint16),
            27 => ParseFunction::Simple(parse_uint8),
            28 => ParseFunction::Simple(parse_uint8),
            29 => ParseFunction::Simple(parse_uint16),
            30 => ParseFunction::Simple(parse_uint32),
            31 => ParseFunction::Simple(parse_uint32),
            32 => ParseFunction::Simple(parse_uint32),
            33 => ParseFunction::Simple(parse_uint16),
            34 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 2_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            12 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            14 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            15 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            28 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            31 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            32 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Monitoring(MonitoringField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum MonitoringHrDataField {
    Timestamp,
    RestingHeartRate,
    CurrentDayRestingHeartRate,
    Unknown,
}
impl MonitoringHrDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::RestingHeartRate,
            1 => Self::CurrentDayRestingHeartRate,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::MonitoringHrData(
            MonitoringHrDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum Spo2DataField {
    Timestamp,
    ReadingSpo2,
    ReadingConfidence,
    Mode,
    Unknown,
}
impl Spo2DataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ReadingSpo2,
            1 => Self::ReadingConfidence,
            2 => Self::Mode,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(Spo2MeasurementType::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            1 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Spo2Data(Spo2DataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HrField {
    Timestamp,
    FractionalTimestamp,
    Time256,
    FilteredBpm,
    EventTimestamp,
    EventTimestamp12,
    Unknown,
}
impl HrField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::FractionalTimestamp,
            1 => Self::Time256,
            6 => Self::FilteredBpm,
            9 => Self::EventTimestamp,
            10 => Self::EventTimestamp12,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint8),
            6 => ParseFunction::Simple(parse_uint8),
            9 => ParseFunction::Simple(parse_uint32),
            10 => ParseFunction::Simple(parse_byte),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 32768_f32,
                offset: 0_f32,
            }),
            1 => Some(ScaleOffset {
                scale: 256_f32,
                offset: 0_f32,
            }),
            9 => Some(ScaleOffset {
                scale: 1024_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::Hr(HrField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum StressLevelField {
    StressLevelValue,
    StressLevelTime,
    Unknown,
}
impl StressLevelField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::StressLevelValue,
            1 => Self::StressLevelTime,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_sint16),
            1 => ParseFunction::Simple(DateTime::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum MaxMetDataField {
    UpdateTime,
    Vo2Max,
    Sport,
    SubSport,
    MaxMetCategory,
    CalibratedData,
    HrSource,
    SpeedSource,
    Unknown,
}
impl MaxMetDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::UpdateTime,
            2 => Self::Vo2Max,
            5 => Self::Sport,
            6 => Self::SubSport,
            8 => Self::MaxMetCategory,
            9 => Self::CalibratedData,
            12 => Self::HrSource,
            13 => Self::SpeedSource,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(DateTime::parse),
            2 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(Sport::parse),
            6 => ParseFunction::Simple(SubSport::parse),
            8 => ParseFunction::Simple(MaxMetCategory::parse),
            9 => ParseFunction::Simple(parse_unknown),
            12 => ParseFunction::Simple(MaxMetHeartRateSource::parse),
            13 => ParseFunction::Simple(MaxMetSpeedSource::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaBodyBatteryDataField {
    Timestamp,
    ProcessingInterval,
    Level,
    Charged,
    Uncharged,
    Unknown,
}
impl HsaBodyBatteryDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ProcessingInterval,
            1 => Self::Level,
            2 => Self::Charged,
            3 => Self::Uncharged,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_sint8),
            2 => ParseFunction::Simple(parse_sint16),
            3 => ParseFunction::Simple(parse_sint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaBodyBatteryData(
            HsaBodyBatteryDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaEventField {
    Timestamp,
    EventId,
    Unknown,
}
impl HsaEventField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::EventId,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaEvent(HsaEventField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaAccelerometerDataField {
    Timestamp,
    TimestampMs,
    SamplingInterval,
    AccelX,
    AccelY,
    AccelZ,
    Timestamp32k,
    Unknown,
}
impl HsaAccelerometerDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::SamplingInterval,
            2 => Self::AccelX,
            3 => Self::AccelY,
            4 => Self::AccelZ,
            5 => Self::Timestamp32k,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_sint16),
            3 => ParseFunction::Simple(parse_sint16),
            4 => ParseFunction::Simple(parse_sint16),
            5 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 1.024_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 1.024_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 1.024_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaAccelerometerData(
            HsaAccelerometerDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaGyroscopeDataField {
    Timestamp,
    TimestampMs,
    SamplingInterval,
    GyroX,
    GyroY,
    GyroZ,
    Timestamp32k,
    Unknown,
}
impl HsaGyroscopeDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::SamplingInterval,
            2 => Self::GyroX,
            3 => Self::GyroY,
            4 => Self::GyroZ,
            5 => Self::Timestamp32k,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_sint16),
            3 => ParseFunction::Simple(parse_sint16),
            4 => ParseFunction::Simple(parse_sint16),
            5 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 28.57143_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 28.57143_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 28.57143_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaGyroscopeData(
            HsaGyroscopeDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaStepDataField {
    Timestamp,
    ProcessingInterval,
    Steps,
    Unknown,
}
impl HsaStepDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ProcessingInterval,
            1 => Self::Steps,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            1 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaStepData(HsaStepDataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaSpo2DataField {
    Timestamp,
    ProcessingInterval,
    ReadingSpo2,
    Confidence,
    Unknown,
}
impl HsaSpo2DataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ProcessingInterval,
            1 => Self::ReadingSpo2,
            2 => Self::Confidence,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaSpo2Data(HsaSpo2DataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaStressDataField {
    Timestamp,
    ProcessingInterval,
    StressLevel,
    Unknown,
}
impl HsaStressDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ProcessingInterval,
            1 => Self::StressLevel,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_sint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            1 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaStressData(HsaStressDataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaRespirationDataField {
    Timestamp,
    ProcessingInterval,
    RespirationRate,
    Unknown,
}
impl HsaRespirationDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ProcessingInterval,
            1 => Self::RespirationRate,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_sint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            1 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaRespirationData(
            HsaRespirationDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaHeartRateDataField {
    Timestamp,
    ProcessingInterval,
    Status,
    HeartRate,
    Unknown,
}
impl HsaHeartRateDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ProcessingInterval,
            1 => Self::Status,
            2 => Self::HeartRate,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaHeartRateData(
            HsaHeartRateDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaConfigurationDataField {
    Timestamp,
    Data,
    DataSize,
    Unknown,
}
impl HsaConfigurationDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Data,
            1 => Self::DataSize,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_byte),
            1 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaConfigurationData(
            HsaConfigurationDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HsaWristTemperatureDataField {
    Timestamp,
    ProcessingInterval,
    Value,
    Unknown,
}
impl HsaWristTemperatureDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ProcessingInterval,
            1 => Self::Value,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            1 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HsaWristTemperatureData(
            HsaWristTemperatureDataField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum MemoGlobField {
    PartIndex,
    Memo,
    MesgNum,
    ParentIndex,
    FieldNum,
    Data,
    Unknown,
}
impl MemoGlobField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            250 => Self::PartIndex,
            0 => Self::Memo,
            1 => Self::MesgNum,
            2 => Self::ParentIndex,
            3 => Self::FieldNum,
            4 => Self::Data,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            250 => ParseFunction::Simple(parse_uint32),
            0 => ParseFunction::Simple(parse_byte),
            1 => ParseFunction::Simple(MesgNum::parse),
            2 => ParseFunction::Simple(MessageIndex::parse),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_unknown),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SleepLevelField {
    Timestamp,
    SleepLevel,
    Unknown,
}
impl SleepLevelField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::SleepLevel,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(SleepLevel::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::SleepLevel(SleepLevelField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum AntChannelIdField {
    ChannelNumber,
    DeviceType,
    DeviceNumber,
    TransmissionType,
    DeviceIndex,
    Unknown,
}
impl AntChannelIdField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::ChannelNumber,
            1 => Self::DeviceType,
            2 => Self::DeviceNumber,
            3 => Self::TransmissionType,
            4 => Self::DeviceIndex,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_unknown),
            2 => ParseFunction::Simple(parse_unknown),
            3 => ParseFunction::Simple(parse_unknown),
            4 => ParseFunction::Simple(DeviceIndex::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum AntRxField {
    Timestamp,
    FractionalTimestamp,
    MesgId,
    MesgData,
    ChannelNumber,
    Data,
    Unknown,
}
impl AntRxField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::FractionalTimestamp,
            1 => Self::MesgId,
            2 => Self::MesgData,
            3 => Self::ChannelNumber,
            4 => Self::Data,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_byte),
            2 => ParseFunction::Simple(parse_byte),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_byte),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 32768_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::AntRx(AntRxField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum AntTxField {
    Timestamp,
    FractionalTimestamp,
    MesgId,
    MesgData,
    ChannelNumber,
    Data,
    Unknown,
}
impl AntTxField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::FractionalTimestamp,
            1 => Self::MesgId,
            2 => Self::MesgData,
            3 => Self::ChannelNumber,
            4 => Self::Data,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_byte),
            2 => ParseFunction::Simple(parse_byte),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_byte),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 32768_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::AntTx(AntTxField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ExdScreenConfigurationField {
    ScreenIndex,
    FieldCount,
    Layout,
    ScreenEnabled,
    Unknown,
}
impl ExdScreenConfigurationField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::ScreenIndex,
            1 => Self::FieldCount,
            2 => Self::Layout,
            3 => Self::ScreenEnabled,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(ExdLayout::parse),
            3 => ParseFunction::Simple(parse_unknown),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ExdDataFieldConfigurationField {
    ScreenIndex,
    ConceptField,
    FieldId,
    ConceptCount,
    DisplayType,
    Title,
    Unknown,
}
impl ExdDataFieldConfigurationField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::ScreenIndex,
            1 => Self::ConceptField,
            2 => Self::FieldId,
            3 => Self::ConceptCount,
            4 => Self::DisplayType,
            5 => Self::Title,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_byte),
            2 => ParseFunction::Simple(parse_uint8),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(ExdDisplayType::parse),
            5 => ParseFunction::Simple(parse_string),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ExdDataConceptConfigurationField {
    ScreenIndex,
    ConceptField,
    FieldId,
    ConceptIndex,
    DataPage,
    ConceptKey,
    Scaling,
    DataUnits,
    Qualifier,
    Descriptor,
    IsSigned,
    Unknown,
}
impl ExdDataConceptConfigurationField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::ScreenIndex,
            1 => Self::ConceptField,
            2 => Self::FieldId,
            3 => Self::ConceptIndex,
            4 => Self::DataPage,
            5 => Self::ConceptKey,
            6 => Self::Scaling,
            8 => Self::DataUnits,
            9 => Self::Qualifier,
            10 => Self::Descriptor,
            11 => Self::IsSigned,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_byte),
            2 => ParseFunction::Simple(parse_uint8),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_uint8),
            5 => ParseFunction::Simple(parse_uint8),
            6 => ParseFunction::Simple(parse_uint8),
            8 => ParseFunction::Simple(ExdDataUnits::parse),
            9 => ParseFunction::Simple(ExdQualifiers::parse),
            10 => ParseFunction::Simple(ExdDescriptors::parse),
            11 => ParseFunction::Simple(parse_unknown),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum DiveSummaryField {
    Timestamp,
    ReferenceMesg,
    ReferenceIndex,
    AvgDepth,
    MaxDepth,
    SurfaceInterval,
    StartCns,
    EndCns,
    StartN2,
    EndN2,
    O2Toxicity,
    DiveNumber,
    BottomTime,
    AvgPressureSac,
    AvgVolumeSac,
    AvgRmv,
    DescentTime,
    AscentTime,
    AvgAscentRate,
    AvgDescentRate,
    MaxAscentRate,
    MaxDescentRate,
    HangTime,
    Unknown,
}
impl DiveSummaryField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ReferenceMesg,
            1 => Self::ReferenceIndex,
            2 => Self::AvgDepth,
            3 => Self::MaxDepth,
            4 => Self::SurfaceInterval,
            5 => Self::StartCns,
            6 => Self::EndCns,
            7 => Self::StartN2,
            8 => Self::EndN2,
            9 => Self::O2Toxicity,
            10 => Self::DiveNumber,
            11 => Self::BottomTime,
            12 => Self::AvgPressureSac,
            13 => Self::AvgVolumeSac,
            14 => Self::AvgRmv,
            15 => Self::DescentTime,
            16 => Self::AscentTime,
            17 => Self::AvgAscentRate,
            22 => Self::AvgDescentRate,
            23 => Self::MaxAscentRate,
            24 => Self::MaxDescentRate,
            25 => Self::HangTime,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(MesgNum::parse),
            1 => ParseFunction::Simple(MessageIndex::parse),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint32),
            4 => ParseFunction::Simple(parse_uint32),
            5 => ParseFunction::Simple(parse_uint8),
            6 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(parse_uint16),
            8 => ParseFunction::Simple(parse_uint16),
            9 => ParseFunction::Simple(parse_uint16),
            10 => ParseFunction::Simple(parse_uint32),
            11 => ParseFunction::Simple(parse_uint32),
            12 => ParseFunction::Simple(parse_uint16),
            13 => ParseFunction::Simple(parse_uint16),
            14 => ParseFunction::Simple(parse_uint16),
            15 => ParseFunction::Simple(parse_uint32),
            16 => ParseFunction::Simple(parse_uint32),
            17 => ParseFunction::Simple(parse_sint32),
            22 => ParseFunction::Simple(parse_uint32),
            23 => ParseFunction::Simple(parse_uint32),
            24 => ParseFunction::Simple(parse_uint32),
            25 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            2 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            6 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            7 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            8 => Some(ScaleOffset {
                scale: 1_f32,
                offset: 0_f32,
            }),
            11 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            12 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            13 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            14 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            15 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            16 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            17 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            22 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            23 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            24 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            25 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::DiveSummary(DiveSummaryField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum AadAccelFeaturesField {
    Timestamp,
    Time,
    EnergyTotal,
    ZeroCrossCnt,
    Instance,
    TimeAboveThreshold,
    Unknown,
}
impl AadAccelFeaturesField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Time,
            1 => Self::EnergyTotal,
            2 => Self::ZeroCrossCnt,
            3 => Self::Instance,
            4 => Self::TimeAboveThreshold,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint32),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            4 => Some(ScaleOffset {
                scale: 25_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::AadAccelFeatures(
            AadAccelFeaturesField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HrvField {
    Time,
    Unknown,
}
impl HrvField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::Time,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum BeatIntervalsField {
    Timestamp,
    TimestampMs,
    Time,
    Unknown,
}
impl BeatIntervalsField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::Time,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::BeatIntervals(BeatIntervalsField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HrvStatusSummaryField {
    Timestamp,
    WeeklyAverage,
    LastNightAverage,
    LastNight5MinHigh,
    BaselineLowUpper,
    BaselineBalancedLower,
    BaselineBalancedUpper,
    Status,
    Unknown,
}
impl HrvStatusSummaryField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::WeeklyAverage,
            1 => Self::LastNightAverage,
            2 => Self::LastNight5MinHigh,
            3 => Self::BaselineLowUpper,
            4 => Self::BaselineBalancedLower,
            5 => Self::BaselineBalancedUpper,
            6 => Self::Status,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(parse_uint16),
            5 => ParseFunction::Simple(parse_uint16),
            6 => ParseFunction::Simple(HrvStatus::parse),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            1 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            2 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            4 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HrvStatusSummary(
            HrvStatusSummaryField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum HrvValueField {
    Timestamp,
    Value,
    Unknown,
}
impl HrvValueField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Value,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 128_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::HrvValue(HrvValueField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum RawBbiField {
    Timestamp,
    TimestampMs,
    Data,
    Time,
    Quality,
    Gap,
    Unknown,
}
impl RawBbiField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::TimestampMs,
            1 => Self::Data,
            2 => Self::Time,
            3 => Self::Quality,
            4 => Self::Gap,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint16),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_uint8),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::RawBbi(RawBbiField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum RespirationRateField {
    Timestamp,
    RespirationRate,
    Unknown,
}
impl RespirationRateField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::RespirationRate,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_sint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::RespirationRate(RespirationRateField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ChronoShotSessionField {
    Timestamp,
    MinSpeed,
    MaxSpeed,
    AvgSpeed,
    ShotCount,
    ProjectileType,
    GrainWeight,
    StandardDeviation,
    Unknown,
}
impl ChronoShotSessionField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::MinSpeed,
            1 => Self::MaxSpeed,
            2 => Self::AvgSpeed,
            3 => Self::ShotCount,
            4 => Self::ProjectileType,
            5 => Self::GrainWeight,
            6 => Self::StandardDeviation,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint32),
            1 => ParseFunction::Simple(parse_uint32),
            2 => ParseFunction::Simple(parse_uint32),
            3 => ParseFunction::Simple(parse_uint16),
            4 => ParseFunction::Simple(ProjectileType::parse),
            5 => ParseFunction::Simple(parse_uint32),
            6 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            1 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            2 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            5 => Some(ScaleOffset {
                scale: 10_f32,
                offset: 0_f32,
            }),
            6 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::ChronoShotSession(
            ChronoShotSessionField::Timestamp,
        ))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum ChronoShotDataField {
    Timestamp,
    ShotSpeed,
    ShotNum,
    Unknown,
}
impl ChronoShotDataField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::ShotSpeed,
            1 => Self::ShotNum,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(parse_uint32),
            1 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            0 => Some(ScaleOffset {
                scale: 1000_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::ChronoShotData(ChronoShotDataField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum TankUpdateField {
    Timestamp,
    Sensor,
    Pressure,
    Unknown,
}
impl TankUpdateField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Sensor,
            1 => Self::Pressure,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(AntChannelId::parse),
            1 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            1 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::TankUpdate(TankUpdateField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum TankSummaryField {
    Timestamp,
    Sensor,
    StartPressure,
    EndPressure,
    VolumeUsed,
    Unknown,
}
impl TankSummaryField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::Sensor,
            1 => Self::StartPressure,
            2 => Self::EndPressure,
            3 => Self::VolumeUsed,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(AntChannelId::parse),
            1 => ParseFunction::Simple(parse_uint16),
            2 => ParseFunction::Simple(parse_uint16),
            3 => ParseFunction::Simple(parse_uint32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            1 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            2 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            3 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::TankSummary(TankSummaryField::Timestamp))
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SleepAssessmentField {
    CombinedAwakeScore,
    AwakeTimeScore,
    AwakeningsCountScore,
    DeepSleepScore,
    SleepDurationScore,
    LightSleepScore,
    OverallSleepScore,
    SleepQualityScore,
    SleepRecoveryScore,
    RemSleepScore,
    SleepRestlessnessScore,
    AwakeningsCount,
    InterruptionsScore,
    AverageStressDuringSleep,
    Unknown,
}
impl SleepAssessmentField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            0 => Self::CombinedAwakeScore,
            1 => Self::AwakeTimeScore,
            2 => Self::AwakeningsCountScore,
            3 => Self::DeepSleepScore,
            4 => Self::SleepDurationScore,
            5 => Self::LightSleepScore,
            6 => Self::OverallSleepScore,
            7 => Self::SleepQualityScore,
            8 => Self::SleepRecoveryScore,
            9 => Self::RemSleepScore,
            10 => Self::SleepRestlessnessScore,
            11 => Self::AwakeningsCount,
            14 => Self::InterruptionsScore,
            15 => Self::AverageStressDuringSleep,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            0 => ParseFunction::Simple(parse_uint8),
            1 => ParseFunction::Simple(parse_uint8),
            2 => ParseFunction::Simple(parse_uint8),
            3 => ParseFunction::Simple(parse_uint8),
            4 => ParseFunction::Simple(parse_uint8),
            5 => ParseFunction::Simple(parse_uint8),
            6 => ParseFunction::Simple(parse_uint8),
            7 => ParseFunction::Simple(parse_uint8),
            8 => ParseFunction::Simple(parse_uint8),
            9 => ParseFunction::Simple(parse_uint8),
            10 => ParseFunction::Simple(parse_uint8),
            11 => ParseFunction::Simple(parse_uint8),
            14 => ParseFunction::Simple(parse_uint8),
            15 => ParseFunction::Simple(parse_uint16),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            15 => Some(ScaleOffset {
                scale: 100_f32,
                offset: 0_f32,
            }),
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        None
    }
}
#[derive(Debug, PartialEq, Clone)]
pub enum SkinTempOvernightField {
    Timestamp,
    LocalTimestamp,
    AverageDeviation,
    Average7DayDeviation,
    NightlyValue,
    Unknown,
}
impl SkinTempOvernightField {
    fn from(definition_field: u8) -> Self {
        match definition_field {
            253 => Self::Timestamp,
            0 => Self::LocalTimestamp,
            1 => Self::AverageDeviation,
            2 => Self::Average7DayDeviation,
            4 => Self::NightlyValue,
            _ => Self::Unknown,
        }
    }

    fn get_parse_function(def_number: u8) -> ParseFunction {
        match def_number {
            253 => ParseFunction::Simple(DateTime::parse),
            0 => ParseFunction::Simple(LocalDateTime::parse),
            1 => ParseFunction::Simple(parse_float32),
            2 => ParseFunction::Simple(parse_float32),
            4 => ParseFunction::Simple(parse_float32),
            _ => ParseFunction::Simple(parse_uint8),
        }
    }

    fn get_scale_offset(def_number: u8) -> Option<ScaleOffset> {
        match def_number {
            _ => None,
        }
    }

    fn timestamp_field() -> Option<FitMessage> {
        Some(FitMessage::SkinTempOvernight(
            SkinTempOvernightField::Timestamp,
        ))
    }
}
