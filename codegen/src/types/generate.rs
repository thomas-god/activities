use itertools::join;

use crate::{
    MESSAGES_TO_IMPORT,
    types::{EnumName, EnumType, EnumVariant},
    utils::snake_to_camel_case,
};

pub fn generate_enums_code(enums: &[(EnumName, EnumType, Vec<(usize, EnumVariant)>)]) -> String {
    let mut code = String::new();
    code.push_str("// Code generated by build.rs - do not modify manually\n");
    code.push_str("#![allow(dead_code)]\n");
    code.push_str("#![allow(unused_imports)]\n");
    code.push_str("#![allow(unused_variables)]\n");
    code.push_str("#![allow(unreachable_patterns)]\n\n");
    code.push_str("#![allow(clippy::enum_variant_names)]\n");
    code.push_str("#![allow(clippy::upper_case_acronyms)]\n\n");
    code.push_str("#![allow(clippy::identity_op)]\n\n");
    code.push_str("#![allow(clippy::type_complexity)]\n\n");
    code.push_str("#![allow(clippy::match_single_binding)]\n\n");
    code.push_str("#![allow(clippy::match_overlapping_arm)]\n\n");
    code.push_str("use crate::{parser::reader::Reader};\n");
    code.push_str("use crate::{parser::records::DataMessageField};\n");
    code.push_str(
        "use crate::parser::types::{parse_uint8, parse_uint8z, parse_sint8,
        parse_uint16, parse_uint16z, parse_sint16,
        parse_uint32, parse_uint32z, parse_sint32,
        parse_uint64, parse_uint64z, parse_sint64,
        parse_float32, parse_float64, parse_string,
        parse_unknown, parse_byte_array as parse_byte, ScaleOffset,
        DataValue, DataTypeError};",
    );
    code.push_str("use crate::parser::definition::{Endianness};\n\n");

    code.push_str(&main_fit_enum_code(enums));

    for (enum_name, enum_type, enum_variants) in enums.iter() {
        if enum_name.contains("date_time") {
            code.push_str(&generate_datetime_like_code(enum_name));
        } else {
            code.push_str(&generate_enum_code(enum_name, enum_type, enum_variants));
        }
    }

    code.push_str(&fit_base_type_enum_code());

    code
}

fn main_fit_enum_code(enums: &[(EnumName, EnumType, Vec<(usize, EnumVariant)>)]) -> String {
    let enum_names: Vec<String> = enums.iter().map(|(name, _, __)| name.to_string()).collect();
    let variants = join(
        enum_names.iter().map(|name| {
            format!(
                "{}({})",
                snake_to_camel_case(name),
                snake_to_camel_case(name)
            )
        }),
        ",\n",
    );

    format!(
        r#"
#[derive(Debug, PartialEq, Clone)]
pub enum FitEnum {{
    {variants}
}}
"#
    )
}

fn fit_base_type_enum_code() -> String {
    "
impl FitBaseType {
    pub fn get_parse_fn(
        &self
    ) -> fn(&mut Reader, &Endianness, u8) -> Result<Vec<DataValue>, DataTypeError> {
        match self {
            Self::Byte => parse_byte,
            Self::Enum => parse_unknown,
            Self::Float32 => parse_float32,
            Self::Float64 => parse_float64,
            Self::Sint8 => parse_sint8,
            Self::Sint16 => parse_sint16,
            Self::Sint32 => parse_sint32,
            Self::Sint64 => parse_sint64,
            Self::String => parse_string,
            Self::Uint8 => parse_uint8,
            Self::Uint8z => parse_uint8z,
            Self::Uint16 => parse_uint16,
            Self::Uint16z => parse_uint16z,
            Self::Uint32 => parse_uint32,
            Self::Uint32z => parse_uint32z,
            Self::Uint64 => parse_uint64,
            Self::Uint64z => parse_uint64z,
            Self::UnknownVariant(_) => parse_unknown,
        }
    }
}
    "
    .to_string()
}

fn generate_datetime_like_code(name: &str) -> String {
    let name = snake_to_camel_case(name);

    // Datetime like "enums" are directly defined as a struct(u32)
    format!(
        r#"
#[derive(Debug, PartialEq, Clone)]
pub struct {name}(u32);

impl {name} {{
    pub fn from(content: u32) -> {name} {{
        Self(content)
    }}

    pub fn parse(
        reader: &mut Reader,
        endianness: &Endianness,
        number_of_bytes: u8
    ) -> Result<Vec<DataValue>, DataTypeError> {{
        let mut values = Vec::new();

        for _ in 0..number_of_bytes / 4 {{
            values.push(DataValue::DateTime(reader.next_u32(endianness)?));
        }}

        Ok(values)
    }}
}}
            "#
    )
    .to_string()
}

fn generate_enum_code(name: &str, base_type: &str, mapping: &[(usize, EnumVariant)]) -> String {
    let mut code = String::new();
    let enum_name = snake_to_camel_case(name);
    let enum_type = map_fit_type_to_rust_type(base_type).expect("Expected not None enum type");
    let enum_type_size = fit_type_size(base_type).expect("Expected not None enum type");

    let variants = join(
        mapping
            .iter()
            .map(|(_, v)| snake_to_camel_case(v))
            .chain(vec![format!("UnknownVariant({enum_type})").to_string()]),
        ",\n",
    );

    // Define the enum and its variants
    code.push_str(&format!(
        "
#[derive(Debug, PartialEq, Clone)]
pub enum {enum_name} {{
    {variants}
}}"
    ));

    // Start impl block
    code.push_str(&format!("impl {enum_name} {{").to_string());

    // Define the mapping from u8 to enum's variants
    let enum_mapping = join(
        mapping
            .iter()
            .map(|(definition_number, variant)| {
                format!(
                    "{definition_number} => {enum_name}::{}",
                    snake_to_camel_case(variant)
                )
            })
            .chain(vec![format!("val => {enum_name}::UnknownVariant(val)")]),
        ",\n",
    );
    code.push_str(&format!(
        r#"

    pub fn from(content: {enum_type}) -> {enum_name} {{
        match content {{
            {enum_mapping}
        }}
    }}
        "#
    ));

    // Define parsing function
    let parse_arguments = if enum_type.contains("8") {
        ""
    } else {
        "endianness"
    };
    code.push_str(&format!(
        "
        pub fn parse(
            reader: &mut Reader,
            endianness: &Endianness,
            number_of_bytes: u8
        ) -> Result<Vec<DataValue>, DataTypeError> {{
            let mut values = Vec::new();
            for _ in 0..number_of_bytes / {enum_type_size} {{
                values.push(DataValue::Enum(FitEnum::{enum_name}(
                    Self::from(reader.next_{enum_type}({parse_arguments})?)
                )));
            }}
            Ok(values)
        }}"
    ));

    // MesgNum need special treatment to be able to link to a FitMessage
    if enum_name == "MesgNum" {
        code.push_str(&generate_mesg_num_mappings(mapping));
    }

    // Close impl block
    code.push_str("}\n");

    code
}

fn generate_mesg_num_mappings(mapping: &[(usize, String)]) -> String {
    let mut code = String::new();
    let mapping_field = join(
        mapping
            .iter()
            .filter(|(_, v)| {
                if !MESSAGES_TO_IMPORT.is_empty() {
                    MESSAGES_TO_IMPORT.contains(&snake_to_camel_case(v).as_str())
                } else {
                    true
                }
            })
            .map(|(_, v)| {
                format!(
                    "Self::{} => FitMessage::{}({}Field::from(def_number))",
                    snake_to_camel_case(v),
                    snake_to_camel_case(v),
                    snake_to_camel_case(v)
                )
            })
            .chain(vec![
                "_ => FitMessage::UnknownVariant(def_number)".to_string(),
            ]),
        ",\n",
    );

    let mapping_parse = join(
        mapping
            .iter()
            .filter(|(_, v)| {
                if !MESSAGES_TO_IMPORT.is_empty() {
                    MESSAGES_TO_IMPORT.contains(&snake_to_camel_case(v).as_str())
                } else {
                    true
                }
            })
            .map(|(_, v)| {
                format!(
                    "Self::{} => {}Field::get_parse_function(def_number)",
                    snake_to_camel_case(v),
                    snake_to_camel_case(v)
                )
            })
            .chain(vec![
                "_ => ParseFunction::Simple(parse_unknown)".to_string(),
            ]),
        ",\n",
    );

    let mapping_scale_offset = join(
        mapping
            .iter()
            .filter(|(_, v)| {
                if !MESSAGES_TO_IMPORT.is_empty() {
                    MESSAGES_TO_IMPORT.contains(&snake_to_camel_case(v).as_str())
                } else {
                    true
                }
            })
            .map(|(_, v)| {
                format!(
                    "Self::{} => {}Field::get_scale_offset(def_number)",
                    snake_to_camel_case(v),
                    snake_to_camel_case(v)
                )
            })
            .chain(vec!["_ => None".to_string()]),
        ",\n",
    );

    let mapping_timestamp_field = join(
        mapping
            .iter()
            .filter(|(_, v)| {
                if !MESSAGES_TO_IMPORT.is_empty() {
                    MESSAGES_TO_IMPORT.contains(&snake_to_camel_case(v).as_str())
                } else {
                    true
                }
            })
            .map(|(_, v)| {
                format!(
                    "Self::{} => {}Field::timestamp_field()",
                    snake_to_camel_case(v),
                    snake_to_camel_case(v)
                )
            })
            .chain(vec!["_ => None".to_string()]),
        ",\n",
    );

    code.push_str(&format!(
        "
    pub fn message_field(&self, def_number: u8) -> FitMessage {{
        match self {{
            {mapping_field}
        }}
    }}

    pub fn field_parse(
        &self, def_number: u8
    ) -> ParseFunction {{
        match self {{
            {mapping_parse}
        }}
    }}

    pub fn scale_offset(
        &self,
        def_number: u8
    ) -> Option<ScaleOffset> {{
        match self {{
            {mapping_scale_offset}
        }}
    }}

    pub fn timestamp_field(
        &self,
    ) -> Option<FitMessage> {{
        match self {{
            {mapping_timestamp_field}
        }}
    }}"
    ));
    code
}

fn fit_type_size(val: &str) -> Option<u8> {
    match val {
        "enum" => Some(1),
        "uint8" => Some(1),
        "uint8z" => Some(1),
        "uint16" => Some(2),
        "uint32" => Some(4),
        "uint32z" => Some(4),
        _ => None,
    }
}

fn map_fit_type_to_rust_type(val: &str) -> Option<String> {
    match val {
        "enum" => Some("u8".to_string()),
        "uint8" => Some("u8".to_string()),
        "uint8z" => Some("u8".to_string()),
        "uint16" => Some("u16".to_string()),
        "uint32" => Some("u32".to_string()),
        "uint32z" => Some("u32".to_string()),
        _ => None,
    }
}
